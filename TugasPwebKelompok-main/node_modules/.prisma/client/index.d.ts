
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Station
 * 
 */
export type Station = $Result.DefaultSelection<Prisma.$StationPayload>
/**
 * Model Train
 * 
 */
export type Train = $Result.DefaultSelection<Prisma.$TrainPayload>
/**
 * Model TrainClass
 * 
 */
export type TrainClass = $Result.DefaultSelection<Prisma.$TrainClassPayload>
/**
 * Model RouteStop
 * 
 */
export type RouteStop = $Result.DefaultSelection<Prisma.$RouteStopPayload>
/**
 * Model Schedule
 * 
 */
export type Schedule = $Result.DefaultSelection<Prisma.$SchedulePayload>
/**
 * Model FavoriteRoute
 * 
 */
export type FavoriteRoute = $Result.DefaultSelection<Prisma.$FavoriteRoutePayload>
/**
 * Model SearchHistory
 * 
 */
export type SearchHistory = $Result.DefaultSelection<Prisma.$SearchHistoryPayload>
/**
 * Model Booking
 * 
 */
export type Booking = $Result.DefaultSelection<Prisma.$BookingPayload>
/**
 * Model Payment
 * 
 */
export type Payment = $Result.DefaultSelection<Prisma.$PaymentPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Stations
 * const stations = await prisma.station.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Stations
   * const stations = await prisma.station.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.station`: Exposes CRUD operations for the **Station** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Stations
    * const stations = await prisma.station.findMany()
    * ```
    */
  get station(): Prisma.StationDelegate<ExtArgs>;

  /**
   * `prisma.train`: Exposes CRUD operations for the **Train** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Trains
    * const trains = await prisma.train.findMany()
    * ```
    */
  get train(): Prisma.TrainDelegate<ExtArgs>;

  /**
   * `prisma.trainClass`: Exposes CRUD operations for the **TrainClass** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TrainClasses
    * const trainClasses = await prisma.trainClass.findMany()
    * ```
    */
  get trainClass(): Prisma.TrainClassDelegate<ExtArgs>;

  /**
   * `prisma.routeStop`: Exposes CRUD operations for the **RouteStop** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RouteStops
    * const routeStops = await prisma.routeStop.findMany()
    * ```
    */
  get routeStop(): Prisma.RouteStopDelegate<ExtArgs>;

  /**
   * `prisma.schedule`: Exposes CRUD operations for the **Schedule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Schedules
    * const schedules = await prisma.schedule.findMany()
    * ```
    */
  get schedule(): Prisma.ScheduleDelegate<ExtArgs>;

  /**
   * `prisma.favoriteRoute`: Exposes CRUD operations for the **FavoriteRoute** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FavoriteRoutes
    * const favoriteRoutes = await prisma.favoriteRoute.findMany()
    * ```
    */
  get favoriteRoute(): Prisma.FavoriteRouteDelegate<ExtArgs>;

  /**
   * `prisma.searchHistory`: Exposes CRUD operations for the **SearchHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SearchHistories
    * const searchHistories = await prisma.searchHistory.findMany()
    * ```
    */
  get searchHistory(): Prisma.SearchHistoryDelegate<ExtArgs>;

  /**
   * `prisma.booking`: Exposes CRUD operations for the **Booking** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bookings
    * const bookings = await prisma.booking.findMany()
    * ```
    */
  get booking(): Prisma.BookingDelegate<ExtArgs>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.PaymentDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Station: 'Station',
    Train: 'Train',
    TrainClass: 'TrainClass',
    RouteStop: 'RouteStop',
    Schedule: 'Schedule',
    FavoriteRoute: 'FavoriteRoute',
    SearchHistory: 'SearchHistory',
    Booking: 'Booking',
    Payment: 'Payment'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "station" | "train" | "trainClass" | "routeStop" | "schedule" | "favoriteRoute" | "searchHistory" | "booking" | "payment"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Station: {
        payload: Prisma.$StationPayload<ExtArgs>
        fields: Prisma.StationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StationPayload>
          }
          findFirst: {
            args: Prisma.StationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StationPayload>
          }
          findMany: {
            args: Prisma.StationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StationPayload>[]
          }
          create: {
            args: Prisma.StationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StationPayload>
          }
          createMany: {
            args: Prisma.StationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StationPayload>[]
          }
          delete: {
            args: Prisma.StationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StationPayload>
          }
          update: {
            args: Prisma.StationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StationPayload>
          }
          deleteMany: {
            args: Prisma.StationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.StationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StationPayload>
          }
          aggregate: {
            args: Prisma.StationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStation>
          }
          groupBy: {
            args: Prisma.StationGroupByArgs<ExtArgs>
            result: $Utils.Optional<StationGroupByOutputType>[]
          }
          count: {
            args: Prisma.StationCountArgs<ExtArgs>
            result: $Utils.Optional<StationCountAggregateOutputType> | number
          }
        }
      }
      Train: {
        payload: Prisma.$TrainPayload<ExtArgs>
        fields: Prisma.TrainFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TrainFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TrainFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainPayload>
          }
          findFirst: {
            args: Prisma.TrainFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TrainFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainPayload>
          }
          findMany: {
            args: Prisma.TrainFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainPayload>[]
          }
          create: {
            args: Prisma.TrainCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainPayload>
          }
          createMany: {
            args: Prisma.TrainCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TrainCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainPayload>[]
          }
          delete: {
            args: Prisma.TrainDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainPayload>
          }
          update: {
            args: Prisma.TrainUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainPayload>
          }
          deleteMany: {
            args: Prisma.TrainDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TrainUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TrainUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainPayload>
          }
          aggregate: {
            args: Prisma.TrainAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTrain>
          }
          groupBy: {
            args: Prisma.TrainGroupByArgs<ExtArgs>
            result: $Utils.Optional<TrainGroupByOutputType>[]
          }
          count: {
            args: Prisma.TrainCountArgs<ExtArgs>
            result: $Utils.Optional<TrainCountAggregateOutputType> | number
          }
        }
      }
      TrainClass: {
        payload: Prisma.$TrainClassPayload<ExtArgs>
        fields: Prisma.TrainClassFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TrainClassFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainClassPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TrainClassFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainClassPayload>
          }
          findFirst: {
            args: Prisma.TrainClassFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainClassPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TrainClassFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainClassPayload>
          }
          findMany: {
            args: Prisma.TrainClassFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainClassPayload>[]
          }
          create: {
            args: Prisma.TrainClassCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainClassPayload>
          }
          createMany: {
            args: Prisma.TrainClassCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TrainClassCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainClassPayload>[]
          }
          delete: {
            args: Prisma.TrainClassDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainClassPayload>
          }
          update: {
            args: Prisma.TrainClassUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainClassPayload>
          }
          deleteMany: {
            args: Prisma.TrainClassDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TrainClassUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TrainClassUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainClassPayload>
          }
          aggregate: {
            args: Prisma.TrainClassAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTrainClass>
          }
          groupBy: {
            args: Prisma.TrainClassGroupByArgs<ExtArgs>
            result: $Utils.Optional<TrainClassGroupByOutputType>[]
          }
          count: {
            args: Prisma.TrainClassCountArgs<ExtArgs>
            result: $Utils.Optional<TrainClassCountAggregateOutputType> | number
          }
        }
      }
      RouteStop: {
        payload: Prisma.$RouteStopPayload<ExtArgs>
        fields: Prisma.RouteStopFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RouteStopFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteStopPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RouteStopFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteStopPayload>
          }
          findFirst: {
            args: Prisma.RouteStopFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteStopPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RouteStopFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteStopPayload>
          }
          findMany: {
            args: Prisma.RouteStopFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteStopPayload>[]
          }
          create: {
            args: Prisma.RouteStopCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteStopPayload>
          }
          createMany: {
            args: Prisma.RouteStopCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RouteStopCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteStopPayload>[]
          }
          delete: {
            args: Prisma.RouteStopDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteStopPayload>
          }
          update: {
            args: Prisma.RouteStopUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteStopPayload>
          }
          deleteMany: {
            args: Prisma.RouteStopDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RouteStopUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RouteStopUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RouteStopPayload>
          }
          aggregate: {
            args: Prisma.RouteStopAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRouteStop>
          }
          groupBy: {
            args: Prisma.RouteStopGroupByArgs<ExtArgs>
            result: $Utils.Optional<RouteStopGroupByOutputType>[]
          }
          count: {
            args: Prisma.RouteStopCountArgs<ExtArgs>
            result: $Utils.Optional<RouteStopCountAggregateOutputType> | number
          }
        }
      }
      Schedule: {
        payload: Prisma.$SchedulePayload<ExtArgs>
        fields: Prisma.ScheduleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ScheduleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ScheduleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>
          }
          findFirst: {
            args: Prisma.ScheduleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ScheduleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>
          }
          findMany: {
            args: Prisma.ScheduleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>[]
          }
          create: {
            args: Prisma.ScheduleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>
          }
          createMany: {
            args: Prisma.ScheduleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ScheduleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>[]
          }
          delete: {
            args: Prisma.ScheduleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>
          }
          update: {
            args: Prisma.ScheduleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>
          }
          deleteMany: {
            args: Prisma.ScheduleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ScheduleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ScheduleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchedulePayload>
          }
          aggregate: {
            args: Prisma.ScheduleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSchedule>
          }
          groupBy: {
            args: Prisma.ScheduleGroupByArgs<ExtArgs>
            result: $Utils.Optional<ScheduleGroupByOutputType>[]
          }
          count: {
            args: Prisma.ScheduleCountArgs<ExtArgs>
            result: $Utils.Optional<ScheduleCountAggregateOutputType> | number
          }
        }
      }
      FavoriteRoute: {
        payload: Prisma.$FavoriteRoutePayload<ExtArgs>
        fields: Prisma.FavoriteRouteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FavoriteRouteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoriteRoutePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FavoriteRouteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoriteRoutePayload>
          }
          findFirst: {
            args: Prisma.FavoriteRouteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoriteRoutePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FavoriteRouteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoriteRoutePayload>
          }
          findMany: {
            args: Prisma.FavoriteRouteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoriteRoutePayload>[]
          }
          create: {
            args: Prisma.FavoriteRouteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoriteRoutePayload>
          }
          createMany: {
            args: Prisma.FavoriteRouteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FavoriteRouteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoriteRoutePayload>[]
          }
          delete: {
            args: Prisma.FavoriteRouteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoriteRoutePayload>
          }
          update: {
            args: Prisma.FavoriteRouteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoriteRoutePayload>
          }
          deleteMany: {
            args: Prisma.FavoriteRouteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FavoriteRouteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FavoriteRouteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FavoriteRoutePayload>
          }
          aggregate: {
            args: Prisma.FavoriteRouteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFavoriteRoute>
          }
          groupBy: {
            args: Prisma.FavoriteRouteGroupByArgs<ExtArgs>
            result: $Utils.Optional<FavoriteRouteGroupByOutputType>[]
          }
          count: {
            args: Prisma.FavoriteRouteCountArgs<ExtArgs>
            result: $Utils.Optional<FavoriteRouteCountAggregateOutputType> | number
          }
        }
      }
      SearchHistory: {
        payload: Prisma.$SearchHistoryPayload<ExtArgs>
        fields: Prisma.SearchHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SearchHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SearchHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchHistoryPayload>
          }
          findFirst: {
            args: Prisma.SearchHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SearchHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchHistoryPayload>
          }
          findMany: {
            args: Prisma.SearchHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchHistoryPayload>[]
          }
          create: {
            args: Prisma.SearchHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchHistoryPayload>
          }
          createMany: {
            args: Prisma.SearchHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SearchHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchHistoryPayload>[]
          }
          delete: {
            args: Prisma.SearchHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchHistoryPayload>
          }
          update: {
            args: Prisma.SearchHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchHistoryPayload>
          }
          deleteMany: {
            args: Prisma.SearchHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SearchHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SearchHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SearchHistoryPayload>
          }
          aggregate: {
            args: Prisma.SearchHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSearchHistory>
          }
          groupBy: {
            args: Prisma.SearchHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<SearchHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.SearchHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<SearchHistoryCountAggregateOutputType> | number
          }
        }
      }
      Booking: {
        payload: Prisma.$BookingPayload<ExtArgs>
        fields: Prisma.BookingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BookingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BookingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          findFirst: {
            args: Prisma.BookingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BookingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          findMany: {
            args: Prisma.BookingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>[]
          }
          create: {
            args: Prisma.BookingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          createMany: {
            args: Prisma.BookingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BookingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>[]
          }
          delete: {
            args: Prisma.BookingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          update: {
            args: Prisma.BookingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          deleteMany: {
            args: Prisma.BookingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BookingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BookingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          aggregate: {
            args: Prisma.BookingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBooking>
          }
          groupBy: {
            args: Prisma.BookingGroupByArgs<ExtArgs>
            result: $Utils.Optional<BookingGroupByOutputType>[]
          }
          count: {
            args: Prisma.BookingCountArgs<ExtArgs>
            result: $Utils.Optional<BookingCountAggregateOutputType> | number
          }
        }
      }
      Payment: {
        payload: Prisma.$PaymentPayload<ExtArgs>
        fields: Prisma.PaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findFirst: {
            args: Prisma.PaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findMany: {
            args: Prisma.PaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          create: {
            args: Prisma.PaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          createMany: {
            args: Prisma.PaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          delete: {
            args: Prisma.PaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          update: {
            args: Prisma.PaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          deleteMany: {
            args: Prisma.PaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.PaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type StationCountOutputType
   */

  export type StationCountOutputType = {
    routes: number
    departureSchedules: number
    arrivalSchedules: number
    favoriteOriginRoutes: number
    favoriteDestinationRoutes: number
    historyOriginRoutes: number
    historyDestinationRoutes: number
  }

  export type StationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    routes?: boolean | StationCountOutputTypeCountRoutesArgs
    departureSchedules?: boolean | StationCountOutputTypeCountDepartureSchedulesArgs
    arrivalSchedules?: boolean | StationCountOutputTypeCountArrivalSchedulesArgs
    favoriteOriginRoutes?: boolean | StationCountOutputTypeCountFavoriteOriginRoutesArgs
    favoriteDestinationRoutes?: boolean | StationCountOutputTypeCountFavoriteDestinationRoutesArgs
    historyOriginRoutes?: boolean | StationCountOutputTypeCountHistoryOriginRoutesArgs
    historyDestinationRoutes?: boolean | StationCountOutputTypeCountHistoryDestinationRoutesArgs
  }

  // Custom InputTypes
  /**
   * StationCountOutputType without action
   */
  export type StationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StationCountOutputType
     */
    select?: StationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StationCountOutputType without action
   */
  export type StationCountOutputTypeCountRoutesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RouteStopWhereInput
  }

  /**
   * StationCountOutputType without action
   */
  export type StationCountOutputTypeCountDepartureSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScheduleWhereInput
  }

  /**
   * StationCountOutputType without action
   */
  export type StationCountOutputTypeCountArrivalSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScheduleWhereInput
  }

  /**
   * StationCountOutputType without action
   */
  export type StationCountOutputTypeCountFavoriteOriginRoutesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FavoriteRouteWhereInput
  }

  /**
   * StationCountOutputType without action
   */
  export type StationCountOutputTypeCountFavoriteDestinationRoutesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FavoriteRouteWhereInput
  }

  /**
   * StationCountOutputType without action
   */
  export type StationCountOutputTypeCountHistoryOriginRoutesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SearchHistoryWhereInput
  }

  /**
   * StationCountOutputType without action
   */
  export type StationCountOutputTypeCountHistoryDestinationRoutesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SearchHistoryWhereInput
  }


  /**
   * Count Type TrainCountOutputType
   */

  export type TrainCountOutputType = {
    classes: number
    routeStops: number
    schedules: number
  }

  export type TrainCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    classes?: boolean | TrainCountOutputTypeCountClassesArgs
    routeStops?: boolean | TrainCountOutputTypeCountRouteStopsArgs
    schedules?: boolean | TrainCountOutputTypeCountSchedulesArgs
  }

  // Custom InputTypes
  /**
   * TrainCountOutputType without action
   */
  export type TrainCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainCountOutputType
     */
    select?: TrainCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TrainCountOutputType without action
   */
  export type TrainCountOutputTypeCountClassesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainClassWhereInput
  }

  /**
   * TrainCountOutputType without action
   */
  export type TrainCountOutputTypeCountRouteStopsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RouteStopWhereInput
  }

  /**
   * TrainCountOutputType without action
   */
  export type TrainCountOutputTypeCountSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScheduleWhereInput
  }


  /**
   * Count Type ScheduleCountOutputType
   */

  export type ScheduleCountOutputType = {
    bookings: number
  }

  export type ScheduleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookings?: boolean | ScheduleCountOutputTypeCountBookingsArgs
  }

  // Custom InputTypes
  /**
   * ScheduleCountOutputType without action
   */
  export type ScheduleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleCountOutputType
     */
    select?: ScheduleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ScheduleCountOutputType without action
   */
  export type ScheduleCountOutputTypeCountBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Station
   */

  export type AggregateStation = {
    _count: StationCountAggregateOutputType | null
    _avg: StationAvgAggregateOutputType | null
    _sum: StationSumAggregateOutputType | null
    _min: StationMinAggregateOutputType | null
    _max: StationMaxAggregateOutputType | null
  }

  export type StationAvgAggregateOutputType = {
    id: number | null
  }

  export type StationSumAggregateOutputType = {
    id: number | null
  }

  export type StationMinAggregateOutputType = {
    id: number | null
    code: string | null
    name: string | null
    city: string | null
    stationType: string | null
  }

  export type StationMaxAggregateOutputType = {
    id: number | null
    code: string | null
    name: string | null
    city: string | null
    stationType: string | null
  }

  export type StationCountAggregateOutputType = {
    id: number
    code: number
    name: number
    city: number
    stationType: number
    _all: number
  }


  export type StationAvgAggregateInputType = {
    id?: true
  }

  export type StationSumAggregateInputType = {
    id?: true
  }

  export type StationMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    city?: true
    stationType?: true
  }

  export type StationMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    city?: true
    stationType?: true
  }

  export type StationCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    city?: true
    stationType?: true
    _all?: true
  }

  export type StationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Station to aggregate.
     */
    where?: StationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stations to fetch.
     */
    orderBy?: StationOrderByWithRelationInput | StationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Stations
    **/
    _count?: true | StationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StationMaxAggregateInputType
  }

  export type GetStationAggregateType<T extends StationAggregateArgs> = {
        [P in keyof T & keyof AggregateStation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStation[P]>
      : GetScalarType<T[P], AggregateStation[P]>
  }




  export type StationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StationWhereInput
    orderBy?: StationOrderByWithAggregationInput | StationOrderByWithAggregationInput[]
    by: StationScalarFieldEnum[] | StationScalarFieldEnum
    having?: StationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StationCountAggregateInputType | true
    _avg?: StationAvgAggregateInputType
    _sum?: StationSumAggregateInputType
    _min?: StationMinAggregateInputType
    _max?: StationMaxAggregateInputType
  }

  export type StationGroupByOutputType = {
    id: number
    code: string
    name: string
    city: string
    stationType: string
    _count: StationCountAggregateOutputType | null
    _avg: StationAvgAggregateOutputType | null
    _sum: StationSumAggregateOutputType | null
    _min: StationMinAggregateOutputType | null
    _max: StationMaxAggregateOutputType | null
  }

  type GetStationGroupByPayload<T extends StationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StationGroupByOutputType[P]>
            : GetScalarType<T[P], StationGroupByOutputType[P]>
        }
      >
    >


  export type StationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    city?: boolean
    stationType?: boolean
    routes?: boolean | Station$routesArgs<ExtArgs>
    departureSchedules?: boolean | Station$departureSchedulesArgs<ExtArgs>
    arrivalSchedules?: boolean | Station$arrivalSchedulesArgs<ExtArgs>
    favoriteOriginRoutes?: boolean | Station$favoriteOriginRoutesArgs<ExtArgs>
    favoriteDestinationRoutes?: boolean | Station$favoriteDestinationRoutesArgs<ExtArgs>
    historyOriginRoutes?: boolean | Station$historyOriginRoutesArgs<ExtArgs>
    historyDestinationRoutes?: boolean | Station$historyDestinationRoutesArgs<ExtArgs>
    _count?: boolean | StationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["station"]>

  export type StationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    city?: boolean
    stationType?: boolean
  }, ExtArgs["result"]["station"]>

  export type StationSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    city?: boolean
    stationType?: boolean
  }

  export type StationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    routes?: boolean | Station$routesArgs<ExtArgs>
    departureSchedules?: boolean | Station$departureSchedulesArgs<ExtArgs>
    arrivalSchedules?: boolean | Station$arrivalSchedulesArgs<ExtArgs>
    favoriteOriginRoutes?: boolean | Station$favoriteOriginRoutesArgs<ExtArgs>
    favoriteDestinationRoutes?: boolean | Station$favoriteDestinationRoutesArgs<ExtArgs>
    historyOriginRoutes?: boolean | Station$historyOriginRoutesArgs<ExtArgs>
    historyDestinationRoutes?: boolean | Station$historyDestinationRoutesArgs<ExtArgs>
    _count?: boolean | StationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $StationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Station"
    objects: {
      routes: Prisma.$RouteStopPayload<ExtArgs>[]
      departureSchedules: Prisma.$SchedulePayload<ExtArgs>[]
      arrivalSchedules: Prisma.$SchedulePayload<ExtArgs>[]
      favoriteOriginRoutes: Prisma.$FavoriteRoutePayload<ExtArgs>[]
      favoriteDestinationRoutes: Prisma.$FavoriteRoutePayload<ExtArgs>[]
      historyOriginRoutes: Prisma.$SearchHistoryPayload<ExtArgs>[]
      historyDestinationRoutes: Prisma.$SearchHistoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      code: string
      name: string
      city: string
      stationType: string
    }, ExtArgs["result"]["station"]>
    composites: {}
  }

  type StationGetPayload<S extends boolean | null | undefined | StationDefaultArgs> = $Result.GetResult<Prisma.$StationPayload, S>

  type StationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StationCountAggregateInputType | true
    }

  export interface StationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Station'], meta: { name: 'Station' } }
    /**
     * Find zero or one Station that matches the filter.
     * @param {StationFindUniqueArgs} args - Arguments to find a Station
     * @example
     * // Get one Station
     * const station = await prisma.station.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StationFindUniqueArgs>(args: SelectSubset<T, StationFindUniqueArgs<ExtArgs>>): Prisma__StationClient<$Result.GetResult<Prisma.$StationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Station that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StationFindUniqueOrThrowArgs} args - Arguments to find a Station
     * @example
     * // Get one Station
     * const station = await prisma.station.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StationFindUniqueOrThrowArgs>(args: SelectSubset<T, StationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StationClient<$Result.GetResult<Prisma.$StationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Station that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StationFindFirstArgs} args - Arguments to find a Station
     * @example
     * // Get one Station
     * const station = await prisma.station.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StationFindFirstArgs>(args?: SelectSubset<T, StationFindFirstArgs<ExtArgs>>): Prisma__StationClient<$Result.GetResult<Prisma.$StationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Station that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StationFindFirstOrThrowArgs} args - Arguments to find a Station
     * @example
     * // Get one Station
     * const station = await prisma.station.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StationFindFirstOrThrowArgs>(args?: SelectSubset<T, StationFindFirstOrThrowArgs<ExtArgs>>): Prisma__StationClient<$Result.GetResult<Prisma.$StationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Stations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Stations
     * const stations = await prisma.station.findMany()
     * 
     * // Get first 10 Stations
     * const stations = await prisma.station.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const stationWithIdOnly = await prisma.station.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StationFindManyArgs>(args?: SelectSubset<T, StationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Station.
     * @param {StationCreateArgs} args - Arguments to create a Station.
     * @example
     * // Create one Station
     * const Station = await prisma.station.create({
     *   data: {
     *     // ... data to create a Station
     *   }
     * })
     * 
     */
    create<T extends StationCreateArgs>(args: SelectSubset<T, StationCreateArgs<ExtArgs>>): Prisma__StationClient<$Result.GetResult<Prisma.$StationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Stations.
     * @param {StationCreateManyArgs} args - Arguments to create many Stations.
     * @example
     * // Create many Stations
     * const station = await prisma.station.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StationCreateManyArgs>(args?: SelectSubset<T, StationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Stations and returns the data saved in the database.
     * @param {StationCreateManyAndReturnArgs} args - Arguments to create many Stations.
     * @example
     * // Create many Stations
     * const station = await prisma.station.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Stations and only return the `id`
     * const stationWithIdOnly = await prisma.station.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StationCreateManyAndReturnArgs>(args?: SelectSubset<T, StationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Station.
     * @param {StationDeleteArgs} args - Arguments to delete one Station.
     * @example
     * // Delete one Station
     * const Station = await prisma.station.delete({
     *   where: {
     *     // ... filter to delete one Station
     *   }
     * })
     * 
     */
    delete<T extends StationDeleteArgs>(args: SelectSubset<T, StationDeleteArgs<ExtArgs>>): Prisma__StationClient<$Result.GetResult<Prisma.$StationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Station.
     * @param {StationUpdateArgs} args - Arguments to update one Station.
     * @example
     * // Update one Station
     * const station = await prisma.station.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StationUpdateArgs>(args: SelectSubset<T, StationUpdateArgs<ExtArgs>>): Prisma__StationClient<$Result.GetResult<Prisma.$StationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Stations.
     * @param {StationDeleteManyArgs} args - Arguments to filter Stations to delete.
     * @example
     * // Delete a few Stations
     * const { count } = await prisma.station.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StationDeleteManyArgs>(args?: SelectSubset<T, StationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Stations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Stations
     * const station = await prisma.station.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StationUpdateManyArgs>(args: SelectSubset<T, StationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Station.
     * @param {StationUpsertArgs} args - Arguments to update or create a Station.
     * @example
     * // Update or create a Station
     * const station = await prisma.station.upsert({
     *   create: {
     *     // ... data to create a Station
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Station we want to update
     *   }
     * })
     */
    upsert<T extends StationUpsertArgs>(args: SelectSubset<T, StationUpsertArgs<ExtArgs>>): Prisma__StationClient<$Result.GetResult<Prisma.$StationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Stations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StationCountArgs} args - Arguments to filter Stations to count.
     * @example
     * // Count the number of Stations
     * const count = await prisma.station.count({
     *   where: {
     *     // ... the filter for the Stations we want to count
     *   }
     * })
    **/
    count<T extends StationCountArgs>(
      args?: Subset<T, StationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Station.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StationAggregateArgs>(args: Subset<T, StationAggregateArgs>): Prisma.PrismaPromise<GetStationAggregateType<T>>

    /**
     * Group by Station.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StationGroupByArgs['orderBy'] }
        : { orderBy?: StationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Station model
   */
  readonly fields: StationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Station.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    routes<T extends Station$routesArgs<ExtArgs> = {}>(args?: Subset<T, Station$routesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RouteStopPayload<ExtArgs>, T, "findMany"> | Null>
    departureSchedules<T extends Station$departureSchedulesArgs<ExtArgs> = {}>(args?: Subset<T, Station$departureSchedulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "findMany"> | Null>
    arrivalSchedules<T extends Station$arrivalSchedulesArgs<ExtArgs> = {}>(args?: Subset<T, Station$arrivalSchedulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "findMany"> | Null>
    favoriteOriginRoutes<T extends Station$favoriteOriginRoutesArgs<ExtArgs> = {}>(args?: Subset<T, Station$favoriteOriginRoutesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FavoriteRoutePayload<ExtArgs>, T, "findMany"> | Null>
    favoriteDestinationRoutes<T extends Station$favoriteDestinationRoutesArgs<ExtArgs> = {}>(args?: Subset<T, Station$favoriteDestinationRoutesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FavoriteRoutePayload<ExtArgs>, T, "findMany"> | Null>
    historyOriginRoutes<T extends Station$historyOriginRoutesArgs<ExtArgs> = {}>(args?: Subset<T, Station$historyOriginRoutesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SearchHistoryPayload<ExtArgs>, T, "findMany"> | Null>
    historyDestinationRoutes<T extends Station$historyDestinationRoutesArgs<ExtArgs> = {}>(args?: Subset<T, Station$historyDestinationRoutesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SearchHistoryPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Station model
   */ 
  interface StationFieldRefs {
    readonly id: FieldRef<"Station", 'Int'>
    readonly code: FieldRef<"Station", 'String'>
    readonly name: FieldRef<"Station", 'String'>
    readonly city: FieldRef<"Station", 'String'>
    readonly stationType: FieldRef<"Station", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Station findUnique
   */
  export type StationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Station
     */
    select?: StationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StationInclude<ExtArgs> | null
    /**
     * Filter, which Station to fetch.
     */
    where: StationWhereUniqueInput
  }

  /**
   * Station findUniqueOrThrow
   */
  export type StationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Station
     */
    select?: StationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StationInclude<ExtArgs> | null
    /**
     * Filter, which Station to fetch.
     */
    where: StationWhereUniqueInput
  }

  /**
   * Station findFirst
   */
  export type StationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Station
     */
    select?: StationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StationInclude<ExtArgs> | null
    /**
     * Filter, which Station to fetch.
     */
    where?: StationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stations to fetch.
     */
    orderBy?: StationOrderByWithRelationInput | StationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Stations.
     */
    cursor?: StationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Stations.
     */
    distinct?: StationScalarFieldEnum | StationScalarFieldEnum[]
  }

  /**
   * Station findFirstOrThrow
   */
  export type StationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Station
     */
    select?: StationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StationInclude<ExtArgs> | null
    /**
     * Filter, which Station to fetch.
     */
    where?: StationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stations to fetch.
     */
    orderBy?: StationOrderByWithRelationInput | StationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Stations.
     */
    cursor?: StationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Stations.
     */
    distinct?: StationScalarFieldEnum | StationScalarFieldEnum[]
  }

  /**
   * Station findMany
   */
  export type StationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Station
     */
    select?: StationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StationInclude<ExtArgs> | null
    /**
     * Filter, which Stations to fetch.
     */
    where?: StationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Stations to fetch.
     */
    orderBy?: StationOrderByWithRelationInput | StationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Stations.
     */
    cursor?: StationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Stations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Stations.
     */
    skip?: number
    distinct?: StationScalarFieldEnum | StationScalarFieldEnum[]
  }

  /**
   * Station create
   */
  export type StationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Station
     */
    select?: StationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StationInclude<ExtArgs> | null
    /**
     * The data needed to create a Station.
     */
    data: XOR<StationCreateInput, StationUncheckedCreateInput>
  }

  /**
   * Station createMany
   */
  export type StationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Stations.
     */
    data: StationCreateManyInput | StationCreateManyInput[]
  }

  /**
   * Station createManyAndReturn
   */
  export type StationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Station
     */
    select?: StationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Stations.
     */
    data: StationCreateManyInput | StationCreateManyInput[]
  }

  /**
   * Station update
   */
  export type StationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Station
     */
    select?: StationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StationInclude<ExtArgs> | null
    /**
     * The data needed to update a Station.
     */
    data: XOR<StationUpdateInput, StationUncheckedUpdateInput>
    /**
     * Choose, which Station to update.
     */
    where: StationWhereUniqueInput
  }

  /**
   * Station updateMany
   */
  export type StationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Stations.
     */
    data: XOR<StationUpdateManyMutationInput, StationUncheckedUpdateManyInput>
    /**
     * Filter which Stations to update
     */
    where?: StationWhereInput
  }

  /**
   * Station upsert
   */
  export type StationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Station
     */
    select?: StationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StationInclude<ExtArgs> | null
    /**
     * The filter to search for the Station to update in case it exists.
     */
    where: StationWhereUniqueInput
    /**
     * In case the Station found by the `where` argument doesn't exist, create a new Station with this data.
     */
    create: XOR<StationCreateInput, StationUncheckedCreateInput>
    /**
     * In case the Station was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StationUpdateInput, StationUncheckedUpdateInput>
  }

  /**
   * Station delete
   */
  export type StationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Station
     */
    select?: StationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StationInclude<ExtArgs> | null
    /**
     * Filter which Station to delete.
     */
    where: StationWhereUniqueInput
  }

  /**
   * Station deleteMany
   */
  export type StationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Stations to delete
     */
    where?: StationWhereInput
  }

  /**
   * Station.routes
   */
  export type Station$routesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteStop
     */
    select?: RouteStopSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteStopInclude<ExtArgs> | null
    where?: RouteStopWhereInput
    orderBy?: RouteStopOrderByWithRelationInput | RouteStopOrderByWithRelationInput[]
    cursor?: RouteStopWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RouteStopScalarFieldEnum | RouteStopScalarFieldEnum[]
  }

  /**
   * Station.departureSchedules
   */
  export type Station$departureSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    where?: ScheduleWhereInput
    orderBy?: ScheduleOrderByWithRelationInput | ScheduleOrderByWithRelationInput[]
    cursor?: ScheduleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ScheduleScalarFieldEnum | ScheduleScalarFieldEnum[]
  }

  /**
   * Station.arrivalSchedules
   */
  export type Station$arrivalSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    where?: ScheduleWhereInput
    orderBy?: ScheduleOrderByWithRelationInput | ScheduleOrderByWithRelationInput[]
    cursor?: ScheduleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ScheduleScalarFieldEnum | ScheduleScalarFieldEnum[]
  }

  /**
   * Station.favoriteOriginRoutes
   */
  export type Station$favoriteOriginRoutesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FavoriteRoute
     */
    select?: FavoriteRouteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteRouteInclude<ExtArgs> | null
    where?: FavoriteRouteWhereInput
    orderBy?: FavoriteRouteOrderByWithRelationInput | FavoriteRouteOrderByWithRelationInput[]
    cursor?: FavoriteRouteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FavoriteRouteScalarFieldEnum | FavoriteRouteScalarFieldEnum[]
  }

  /**
   * Station.favoriteDestinationRoutes
   */
  export type Station$favoriteDestinationRoutesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FavoriteRoute
     */
    select?: FavoriteRouteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteRouteInclude<ExtArgs> | null
    where?: FavoriteRouteWhereInput
    orderBy?: FavoriteRouteOrderByWithRelationInput | FavoriteRouteOrderByWithRelationInput[]
    cursor?: FavoriteRouteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FavoriteRouteScalarFieldEnum | FavoriteRouteScalarFieldEnum[]
  }

  /**
   * Station.historyOriginRoutes
   */
  export type Station$historyOriginRoutesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchHistory
     */
    select?: SearchHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchHistoryInclude<ExtArgs> | null
    where?: SearchHistoryWhereInput
    orderBy?: SearchHistoryOrderByWithRelationInput | SearchHistoryOrderByWithRelationInput[]
    cursor?: SearchHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SearchHistoryScalarFieldEnum | SearchHistoryScalarFieldEnum[]
  }

  /**
   * Station.historyDestinationRoutes
   */
  export type Station$historyDestinationRoutesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchHistory
     */
    select?: SearchHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchHistoryInclude<ExtArgs> | null
    where?: SearchHistoryWhereInput
    orderBy?: SearchHistoryOrderByWithRelationInput | SearchHistoryOrderByWithRelationInput[]
    cursor?: SearchHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SearchHistoryScalarFieldEnum | SearchHistoryScalarFieldEnum[]
  }

  /**
   * Station without action
   */
  export type StationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Station
     */
    select?: StationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StationInclude<ExtArgs> | null
  }


  /**
   * Model Train
   */

  export type AggregateTrain = {
    _count: TrainCountAggregateOutputType | null
    _avg: TrainAvgAggregateOutputType | null
    _sum: TrainSumAggregateOutputType | null
    _min: TrainMinAggregateOutputType | null
    _max: TrainMaxAggregateOutputType | null
  }

  export type TrainAvgAggregateOutputType = {
    id: number | null
  }

  export type TrainSumAggregateOutputType = {
    id: number | null
  }

  export type TrainMinAggregateOutputType = {
    id: number | null
    name: string | null
    trainType: string | null
  }

  export type TrainMaxAggregateOutputType = {
    id: number | null
    name: string | null
    trainType: string | null
  }

  export type TrainCountAggregateOutputType = {
    id: number
    name: number
    trainType: number
    _all: number
  }


  export type TrainAvgAggregateInputType = {
    id?: true
  }

  export type TrainSumAggregateInputType = {
    id?: true
  }

  export type TrainMinAggregateInputType = {
    id?: true
    name?: true
    trainType?: true
  }

  export type TrainMaxAggregateInputType = {
    id?: true
    name?: true
    trainType?: true
  }

  export type TrainCountAggregateInputType = {
    id?: true
    name?: true
    trainType?: true
    _all?: true
  }

  export type TrainAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Train to aggregate.
     */
    where?: TrainWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trains to fetch.
     */
    orderBy?: TrainOrderByWithRelationInput | TrainOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TrainWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trains from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trains.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Trains
    **/
    _count?: true | TrainCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TrainAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TrainSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TrainMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TrainMaxAggregateInputType
  }

  export type GetTrainAggregateType<T extends TrainAggregateArgs> = {
        [P in keyof T & keyof AggregateTrain]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrain[P]>
      : GetScalarType<T[P], AggregateTrain[P]>
  }




  export type TrainGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainWhereInput
    orderBy?: TrainOrderByWithAggregationInput | TrainOrderByWithAggregationInput[]
    by: TrainScalarFieldEnum[] | TrainScalarFieldEnum
    having?: TrainScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TrainCountAggregateInputType | true
    _avg?: TrainAvgAggregateInputType
    _sum?: TrainSumAggregateInputType
    _min?: TrainMinAggregateInputType
    _max?: TrainMaxAggregateInputType
  }

  export type TrainGroupByOutputType = {
    id: number
    name: string
    trainType: string
    _count: TrainCountAggregateOutputType | null
    _avg: TrainAvgAggregateOutputType | null
    _sum: TrainSumAggregateOutputType | null
    _min: TrainMinAggregateOutputType | null
    _max: TrainMaxAggregateOutputType | null
  }

  type GetTrainGroupByPayload<T extends TrainGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TrainGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TrainGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TrainGroupByOutputType[P]>
            : GetScalarType<T[P], TrainGroupByOutputType[P]>
        }
      >
    >


  export type TrainSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    trainType?: boolean
    classes?: boolean | Train$classesArgs<ExtArgs>
    routeStops?: boolean | Train$routeStopsArgs<ExtArgs>
    schedules?: boolean | Train$schedulesArgs<ExtArgs>
    _count?: boolean | TrainCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["train"]>

  export type TrainSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    trainType?: boolean
  }, ExtArgs["result"]["train"]>

  export type TrainSelectScalar = {
    id?: boolean
    name?: boolean
    trainType?: boolean
  }

  export type TrainInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    classes?: boolean | Train$classesArgs<ExtArgs>
    routeStops?: boolean | Train$routeStopsArgs<ExtArgs>
    schedules?: boolean | Train$schedulesArgs<ExtArgs>
    _count?: boolean | TrainCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TrainIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TrainPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Train"
    objects: {
      classes: Prisma.$TrainClassPayload<ExtArgs>[]
      routeStops: Prisma.$RouteStopPayload<ExtArgs>[]
      schedules: Prisma.$SchedulePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      trainType: string
    }, ExtArgs["result"]["train"]>
    composites: {}
  }

  type TrainGetPayload<S extends boolean | null | undefined | TrainDefaultArgs> = $Result.GetResult<Prisma.$TrainPayload, S>

  type TrainCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TrainFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TrainCountAggregateInputType | true
    }

  export interface TrainDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Train'], meta: { name: 'Train' } }
    /**
     * Find zero or one Train that matches the filter.
     * @param {TrainFindUniqueArgs} args - Arguments to find a Train
     * @example
     * // Get one Train
     * const train = await prisma.train.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TrainFindUniqueArgs>(args: SelectSubset<T, TrainFindUniqueArgs<ExtArgs>>): Prisma__TrainClient<$Result.GetResult<Prisma.$TrainPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Train that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TrainFindUniqueOrThrowArgs} args - Arguments to find a Train
     * @example
     * // Get one Train
     * const train = await prisma.train.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TrainFindUniqueOrThrowArgs>(args: SelectSubset<T, TrainFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TrainClient<$Result.GetResult<Prisma.$TrainPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Train that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainFindFirstArgs} args - Arguments to find a Train
     * @example
     * // Get one Train
     * const train = await prisma.train.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TrainFindFirstArgs>(args?: SelectSubset<T, TrainFindFirstArgs<ExtArgs>>): Prisma__TrainClient<$Result.GetResult<Prisma.$TrainPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Train that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainFindFirstOrThrowArgs} args - Arguments to find a Train
     * @example
     * // Get one Train
     * const train = await prisma.train.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TrainFindFirstOrThrowArgs>(args?: SelectSubset<T, TrainFindFirstOrThrowArgs<ExtArgs>>): Prisma__TrainClient<$Result.GetResult<Prisma.$TrainPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Trains that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Trains
     * const trains = await prisma.train.findMany()
     * 
     * // Get first 10 Trains
     * const trains = await prisma.train.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const trainWithIdOnly = await prisma.train.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TrainFindManyArgs>(args?: SelectSubset<T, TrainFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Train.
     * @param {TrainCreateArgs} args - Arguments to create a Train.
     * @example
     * // Create one Train
     * const Train = await prisma.train.create({
     *   data: {
     *     // ... data to create a Train
     *   }
     * })
     * 
     */
    create<T extends TrainCreateArgs>(args: SelectSubset<T, TrainCreateArgs<ExtArgs>>): Prisma__TrainClient<$Result.GetResult<Prisma.$TrainPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Trains.
     * @param {TrainCreateManyArgs} args - Arguments to create many Trains.
     * @example
     * // Create many Trains
     * const train = await prisma.train.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TrainCreateManyArgs>(args?: SelectSubset<T, TrainCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Trains and returns the data saved in the database.
     * @param {TrainCreateManyAndReturnArgs} args - Arguments to create many Trains.
     * @example
     * // Create many Trains
     * const train = await prisma.train.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Trains and only return the `id`
     * const trainWithIdOnly = await prisma.train.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TrainCreateManyAndReturnArgs>(args?: SelectSubset<T, TrainCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Train.
     * @param {TrainDeleteArgs} args - Arguments to delete one Train.
     * @example
     * // Delete one Train
     * const Train = await prisma.train.delete({
     *   where: {
     *     // ... filter to delete one Train
     *   }
     * })
     * 
     */
    delete<T extends TrainDeleteArgs>(args: SelectSubset<T, TrainDeleteArgs<ExtArgs>>): Prisma__TrainClient<$Result.GetResult<Prisma.$TrainPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Train.
     * @param {TrainUpdateArgs} args - Arguments to update one Train.
     * @example
     * // Update one Train
     * const train = await prisma.train.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TrainUpdateArgs>(args: SelectSubset<T, TrainUpdateArgs<ExtArgs>>): Prisma__TrainClient<$Result.GetResult<Prisma.$TrainPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Trains.
     * @param {TrainDeleteManyArgs} args - Arguments to filter Trains to delete.
     * @example
     * // Delete a few Trains
     * const { count } = await prisma.train.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TrainDeleteManyArgs>(args?: SelectSubset<T, TrainDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Trains.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Trains
     * const train = await prisma.train.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TrainUpdateManyArgs>(args: SelectSubset<T, TrainUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Train.
     * @param {TrainUpsertArgs} args - Arguments to update or create a Train.
     * @example
     * // Update or create a Train
     * const train = await prisma.train.upsert({
     *   create: {
     *     // ... data to create a Train
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Train we want to update
     *   }
     * })
     */
    upsert<T extends TrainUpsertArgs>(args: SelectSubset<T, TrainUpsertArgs<ExtArgs>>): Prisma__TrainClient<$Result.GetResult<Prisma.$TrainPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Trains.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainCountArgs} args - Arguments to filter Trains to count.
     * @example
     * // Count the number of Trains
     * const count = await prisma.train.count({
     *   where: {
     *     // ... the filter for the Trains we want to count
     *   }
     * })
    **/
    count<T extends TrainCountArgs>(
      args?: Subset<T, TrainCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TrainCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Train.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TrainAggregateArgs>(args: Subset<T, TrainAggregateArgs>): Prisma.PrismaPromise<GetTrainAggregateType<T>>

    /**
     * Group by Train.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TrainGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TrainGroupByArgs['orderBy'] }
        : { orderBy?: TrainGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TrainGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTrainGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Train model
   */
  readonly fields: TrainFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Train.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TrainClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    classes<T extends Train$classesArgs<ExtArgs> = {}>(args?: Subset<T, Train$classesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainClassPayload<ExtArgs>, T, "findMany"> | Null>
    routeStops<T extends Train$routeStopsArgs<ExtArgs> = {}>(args?: Subset<T, Train$routeStopsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RouteStopPayload<ExtArgs>, T, "findMany"> | Null>
    schedules<T extends Train$schedulesArgs<ExtArgs> = {}>(args?: Subset<T, Train$schedulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Train model
   */ 
  interface TrainFieldRefs {
    readonly id: FieldRef<"Train", 'Int'>
    readonly name: FieldRef<"Train", 'String'>
    readonly trainType: FieldRef<"Train", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Train findUnique
   */
  export type TrainFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Train
     */
    select?: TrainSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainInclude<ExtArgs> | null
    /**
     * Filter, which Train to fetch.
     */
    where: TrainWhereUniqueInput
  }

  /**
   * Train findUniqueOrThrow
   */
  export type TrainFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Train
     */
    select?: TrainSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainInclude<ExtArgs> | null
    /**
     * Filter, which Train to fetch.
     */
    where: TrainWhereUniqueInput
  }

  /**
   * Train findFirst
   */
  export type TrainFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Train
     */
    select?: TrainSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainInclude<ExtArgs> | null
    /**
     * Filter, which Train to fetch.
     */
    where?: TrainWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trains to fetch.
     */
    orderBy?: TrainOrderByWithRelationInput | TrainOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Trains.
     */
    cursor?: TrainWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trains from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trains.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Trains.
     */
    distinct?: TrainScalarFieldEnum | TrainScalarFieldEnum[]
  }

  /**
   * Train findFirstOrThrow
   */
  export type TrainFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Train
     */
    select?: TrainSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainInclude<ExtArgs> | null
    /**
     * Filter, which Train to fetch.
     */
    where?: TrainWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trains to fetch.
     */
    orderBy?: TrainOrderByWithRelationInput | TrainOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Trains.
     */
    cursor?: TrainWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trains from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trains.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Trains.
     */
    distinct?: TrainScalarFieldEnum | TrainScalarFieldEnum[]
  }

  /**
   * Train findMany
   */
  export type TrainFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Train
     */
    select?: TrainSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainInclude<ExtArgs> | null
    /**
     * Filter, which Trains to fetch.
     */
    where?: TrainWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Trains to fetch.
     */
    orderBy?: TrainOrderByWithRelationInput | TrainOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Trains.
     */
    cursor?: TrainWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Trains from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Trains.
     */
    skip?: number
    distinct?: TrainScalarFieldEnum | TrainScalarFieldEnum[]
  }

  /**
   * Train create
   */
  export type TrainCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Train
     */
    select?: TrainSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainInclude<ExtArgs> | null
    /**
     * The data needed to create a Train.
     */
    data: XOR<TrainCreateInput, TrainUncheckedCreateInput>
  }

  /**
   * Train createMany
   */
  export type TrainCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Trains.
     */
    data: TrainCreateManyInput | TrainCreateManyInput[]
  }

  /**
   * Train createManyAndReturn
   */
  export type TrainCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Train
     */
    select?: TrainSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Trains.
     */
    data: TrainCreateManyInput | TrainCreateManyInput[]
  }

  /**
   * Train update
   */
  export type TrainUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Train
     */
    select?: TrainSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainInclude<ExtArgs> | null
    /**
     * The data needed to update a Train.
     */
    data: XOR<TrainUpdateInput, TrainUncheckedUpdateInput>
    /**
     * Choose, which Train to update.
     */
    where: TrainWhereUniqueInput
  }

  /**
   * Train updateMany
   */
  export type TrainUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Trains.
     */
    data: XOR<TrainUpdateManyMutationInput, TrainUncheckedUpdateManyInput>
    /**
     * Filter which Trains to update
     */
    where?: TrainWhereInput
  }

  /**
   * Train upsert
   */
  export type TrainUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Train
     */
    select?: TrainSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainInclude<ExtArgs> | null
    /**
     * The filter to search for the Train to update in case it exists.
     */
    where: TrainWhereUniqueInput
    /**
     * In case the Train found by the `where` argument doesn't exist, create a new Train with this data.
     */
    create: XOR<TrainCreateInput, TrainUncheckedCreateInput>
    /**
     * In case the Train was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TrainUpdateInput, TrainUncheckedUpdateInput>
  }

  /**
   * Train delete
   */
  export type TrainDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Train
     */
    select?: TrainSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainInclude<ExtArgs> | null
    /**
     * Filter which Train to delete.
     */
    where: TrainWhereUniqueInput
  }

  /**
   * Train deleteMany
   */
  export type TrainDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Trains to delete
     */
    where?: TrainWhereInput
  }

  /**
   * Train.classes
   */
  export type Train$classesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainClass
     */
    select?: TrainClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainClassInclude<ExtArgs> | null
    where?: TrainClassWhereInput
    orderBy?: TrainClassOrderByWithRelationInput | TrainClassOrderByWithRelationInput[]
    cursor?: TrainClassWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TrainClassScalarFieldEnum | TrainClassScalarFieldEnum[]
  }

  /**
   * Train.routeStops
   */
  export type Train$routeStopsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteStop
     */
    select?: RouteStopSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteStopInclude<ExtArgs> | null
    where?: RouteStopWhereInput
    orderBy?: RouteStopOrderByWithRelationInput | RouteStopOrderByWithRelationInput[]
    cursor?: RouteStopWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RouteStopScalarFieldEnum | RouteStopScalarFieldEnum[]
  }

  /**
   * Train.schedules
   */
  export type Train$schedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    where?: ScheduleWhereInput
    orderBy?: ScheduleOrderByWithRelationInput | ScheduleOrderByWithRelationInput[]
    cursor?: ScheduleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ScheduleScalarFieldEnum | ScheduleScalarFieldEnum[]
  }

  /**
   * Train without action
   */
  export type TrainDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Train
     */
    select?: TrainSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainInclude<ExtArgs> | null
  }


  /**
   * Model TrainClass
   */

  export type AggregateTrainClass = {
    _count: TrainClassCountAggregateOutputType | null
    _avg: TrainClassAvgAggregateOutputType | null
    _sum: TrainClassSumAggregateOutputType | null
    _min: TrainClassMinAggregateOutputType | null
    _max: TrainClassMaxAggregateOutputType | null
  }

  export type TrainClassAvgAggregateOutputType = {
    id: number | null
    price: number | null
    trainId: number | null
  }

  export type TrainClassSumAggregateOutputType = {
    id: number | null
    price: number | null
    trainId: number | null
  }

  export type TrainClassMinAggregateOutputType = {
    id: number | null
    className: string | null
    price: number | null
    trainId: number | null
  }

  export type TrainClassMaxAggregateOutputType = {
    id: number | null
    className: string | null
    price: number | null
    trainId: number | null
  }

  export type TrainClassCountAggregateOutputType = {
    id: number
    className: number
    price: number
    trainId: number
    _all: number
  }


  export type TrainClassAvgAggregateInputType = {
    id?: true
    price?: true
    trainId?: true
  }

  export type TrainClassSumAggregateInputType = {
    id?: true
    price?: true
    trainId?: true
  }

  export type TrainClassMinAggregateInputType = {
    id?: true
    className?: true
    price?: true
    trainId?: true
  }

  export type TrainClassMaxAggregateInputType = {
    id?: true
    className?: true
    price?: true
    trainId?: true
  }

  export type TrainClassCountAggregateInputType = {
    id?: true
    className?: true
    price?: true
    trainId?: true
    _all?: true
  }

  export type TrainClassAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrainClass to aggregate.
     */
    where?: TrainClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainClasses to fetch.
     */
    orderBy?: TrainClassOrderByWithRelationInput | TrainClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TrainClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainClasses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainClasses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TrainClasses
    **/
    _count?: true | TrainClassCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TrainClassAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TrainClassSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TrainClassMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TrainClassMaxAggregateInputType
  }

  export type GetTrainClassAggregateType<T extends TrainClassAggregateArgs> = {
        [P in keyof T & keyof AggregateTrainClass]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrainClass[P]>
      : GetScalarType<T[P], AggregateTrainClass[P]>
  }




  export type TrainClassGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainClassWhereInput
    orderBy?: TrainClassOrderByWithAggregationInput | TrainClassOrderByWithAggregationInput[]
    by: TrainClassScalarFieldEnum[] | TrainClassScalarFieldEnum
    having?: TrainClassScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TrainClassCountAggregateInputType | true
    _avg?: TrainClassAvgAggregateInputType
    _sum?: TrainClassSumAggregateInputType
    _min?: TrainClassMinAggregateInputType
    _max?: TrainClassMaxAggregateInputType
  }

  export type TrainClassGroupByOutputType = {
    id: number
    className: string
    price: number
    trainId: number
    _count: TrainClassCountAggregateOutputType | null
    _avg: TrainClassAvgAggregateOutputType | null
    _sum: TrainClassSumAggregateOutputType | null
    _min: TrainClassMinAggregateOutputType | null
    _max: TrainClassMaxAggregateOutputType | null
  }

  type GetTrainClassGroupByPayload<T extends TrainClassGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TrainClassGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TrainClassGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TrainClassGroupByOutputType[P]>
            : GetScalarType<T[P], TrainClassGroupByOutputType[P]>
        }
      >
    >


  export type TrainClassSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    className?: boolean
    price?: boolean
    trainId?: boolean
    train?: boolean | TrainDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trainClass"]>

  export type TrainClassSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    className?: boolean
    price?: boolean
    trainId?: boolean
    train?: boolean | TrainDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trainClass"]>

  export type TrainClassSelectScalar = {
    id?: boolean
    className?: boolean
    price?: boolean
    trainId?: boolean
  }

  export type TrainClassInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    train?: boolean | TrainDefaultArgs<ExtArgs>
  }
  export type TrainClassIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    train?: boolean | TrainDefaultArgs<ExtArgs>
  }

  export type $TrainClassPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TrainClass"
    objects: {
      train: Prisma.$TrainPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      className: string
      price: number
      trainId: number
    }, ExtArgs["result"]["trainClass"]>
    composites: {}
  }

  type TrainClassGetPayload<S extends boolean | null | undefined | TrainClassDefaultArgs> = $Result.GetResult<Prisma.$TrainClassPayload, S>

  type TrainClassCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TrainClassFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TrainClassCountAggregateInputType | true
    }

  export interface TrainClassDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TrainClass'], meta: { name: 'TrainClass' } }
    /**
     * Find zero or one TrainClass that matches the filter.
     * @param {TrainClassFindUniqueArgs} args - Arguments to find a TrainClass
     * @example
     * // Get one TrainClass
     * const trainClass = await prisma.trainClass.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TrainClassFindUniqueArgs>(args: SelectSubset<T, TrainClassFindUniqueArgs<ExtArgs>>): Prisma__TrainClassClient<$Result.GetResult<Prisma.$TrainClassPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TrainClass that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TrainClassFindUniqueOrThrowArgs} args - Arguments to find a TrainClass
     * @example
     * // Get one TrainClass
     * const trainClass = await prisma.trainClass.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TrainClassFindUniqueOrThrowArgs>(args: SelectSubset<T, TrainClassFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TrainClassClient<$Result.GetResult<Prisma.$TrainClassPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TrainClass that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainClassFindFirstArgs} args - Arguments to find a TrainClass
     * @example
     * // Get one TrainClass
     * const trainClass = await prisma.trainClass.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TrainClassFindFirstArgs>(args?: SelectSubset<T, TrainClassFindFirstArgs<ExtArgs>>): Prisma__TrainClassClient<$Result.GetResult<Prisma.$TrainClassPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TrainClass that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainClassFindFirstOrThrowArgs} args - Arguments to find a TrainClass
     * @example
     * // Get one TrainClass
     * const trainClass = await prisma.trainClass.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TrainClassFindFirstOrThrowArgs>(args?: SelectSubset<T, TrainClassFindFirstOrThrowArgs<ExtArgs>>): Prisma__TrainClassClient<$Result.GetResult<Prisma.$TrainClassPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TrainClasses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainClassFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TrainClasses
     * const trainClasses = await prisma.trainClass.findMany()
     * 
     * // Get first 10 TrainClasses
     * const trainClasses = await prisma.trainClass.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const trainClassWithIdOnly = await prisma.trainClass.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TrainClassFindManyArgs>(args?: SelectSubset<T, TrainClassFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainClassPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TrainClass.
     * @param {TrainClassCreateArgs} args - Arguments to create a TrainClass.
     * @example
     * // Create one TrainClass
     * const TrainClass = await prisma.trainClass.create({
     *   data: {
     *     // ... data to create a TrainClass
     *   }
     * })
     * 
     */
    create<T extends TrainClassCreateArgs>(args: SelectSubset<T, TrainClassCreateArgs<ExtArgs>>): Prisma__TrainClassClient<$Result.GetResult<Prisma.$TrainClassPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TrainClasses.
     * @param {TrainClassCreateManyArgs} args - Arguments to create many TrainClasses.
     * @example
     * // Create many TrainClasses
     * const trainClass = await prisma.trainClass.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TrainClassCreateManyArgs>(args?: SelectSubset<T, TrainClassCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TrainClasses and returns the data saved in the database.
     * @param {TrainClassCreateManyAndReturnArgs} args - Arguments to create many TrainClasses.
     * @example
     * // Create many TrainClasses
     * const trainClass = await prisma.trainClass.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TrainClasses and only return the `id`
     * const trainClassWithIdOnly = await prisma.trainClass.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TrainClassCreateManyAndReturnArgs>(args?: SelectSubset<T, TrainClassCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainClassPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TrainClass.
     * @param {TrainClassDeleteArgs} args - Arguments to delete one TrainClass.
     * @example
     * // Delete one TrainClass
     * const TrainClass = await prisma.trainClass.delete({
     *   where: {
     *     // ... filter to delete one TrainClass
     *   }
     * })
     * 
     */
    delete<T extends TrainClassDeleteArgs>(args: SelectSubset<T, TrainClassDeleteArgs<ExtArgs>>): Prisma__TrainClassClient<$Result.GetResult<Prisma.$TrainClassPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TrainClass.
     * @param {TrainClassUpdateArgs} args - Arguments to update one TrainClass.
     * @example
     * // Update one TrainClass
     * const trainClass = await prisma.trainClass.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TrainClassUpdateArgs>(args: SelectSubset<T, TrainClassUpdateArgs<ExtArgs>>): Prisma__TrainClassClient<$Result.GetResult<Prisma.$TrainClassPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TrainClasses.
     * @param {TrainClassDeleteManyArgs} args - Arguments to filter TrainClasses to delete.
     * @example
     * // Delete a few TrainClasses
     * const { count } = await prisma.trainClass.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TrainClassDeleteManyArgs>(args?: SelectSubset<T, TrainClassDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TrainClasses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainClassUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TrainClasses
     * const trainClass = await prisma.trainClass.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TrainClassUpdateManyArgs>(args: SelectSubset<T, TrainClassUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TrainClass.
     * @param {TrainClassUpsertArgs} args - Arguments to update or create a TrainClass.
     * @example
     * // Update or create a TrainClass
     * const trainClass = await prisma.trainClass.upsert({
     *   create: {
     *     // ... data to create a TrainClass
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TrainClass we want to update
     *   }
     * })
     */
    upsert<T extends TrainClassUpsertArgs>(args: SelectSubset<T, TrainClassUpsertArgs<ExtArgs>>): Prisma__TrainClassClient<$Result.GetResult<Prisma.$TrainClassPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TrainClasses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainClassCountArgs} args - Arguments to filter TrainClasses to count.
     * @example
     * // Count the number of TrainClasses
     * const count = await prisma.trainClass.count({
     *   where: {
     *     // ... the filter for the TrainClasses we want to count
     *   }
     * })
    **/
    count<T extends TrainClassCountArgs>(
      args?: Subset<T, TrainClassCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TrainClassCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TrainClass.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainClassAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TrainClassAggregateArgs>(args: Subset<T, TrainClassAggregateArgs>): Prisma.PrismaPromise<GetTrainClassAggregateType<T>>

    /**
     * Group by TrainClass.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainClassGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TrainClassGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TrainClassGroupByArgs['orderBy'] }
        : { orderBy?: TrainClassGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TrainClassGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTrainClassGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TrainClass model
   */
  readonly fields: TrainClassFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TrainClass.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TrainClassClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    train<T extends TrainDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TrainDefaultArgs<ExtArgs>>): Prisma__TrainClient<$Result.GetResult<Prisma.$TrainPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TrainClass model
   */ 
  interface TrainClassFieldRefs {
    readonly id: FieldRef<"TrainClass", 'Int'>
    readonly className: FieldRef<"TrainClass", 'String'>
    readonly price: FieldRef<"TrainClass", 'Int'>
    readonly trainId: FieldRef<"TrainClass", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * TrainClass findUnique
   */
  export type TrainClassFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainClass
     */
    select?: TrainClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainClassInclude<ExtArgs> | null
    /**
     * Filter, which TrainClass to fetch.
     */
    where: TrainClassWhereUniqueInput
  }

  /**
   * TrainClass findUniqueOrThrow
   */
  export type TrainClassFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainClass
     */
    select?: TrainClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainClassInclude<ExtArgs> | null
    /**
     * Filter, which TrainClass to fetch.
     */
    where: TrainClassWhereUniqueInput
  }

  /**
   * TrainClass findFirst
   */
  export type TrainClassFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainClass
     */
    select?: TrainClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainClassInclude<ExtArgs> | null
    /**
     * Filter, which TrainClass to fetch.
     */
    where?: TrainClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainClasses to fetch.
     */
    orderBy?: TrainClassOrderByWithRelationInput | TrainClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrainClasses.
     */
    cursor?: TrainClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainClasses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainClasses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrainClasses.
     */
    distinct?: TrainClassScalarFieldEnum | TrainClassScalarFieldEnum[]
  }

  /**
   * TrainClass findFirstOrThrow
   */
  export type TrainClassFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainClass
     */
    select?: TrainClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainClassInclude<ExtArgs> | null
    /**
     * Filter, which TrainClass to fetch.
     */
    where?: TrainClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainClasses to fetch.
     */
    orderBy?: TrainClassOrderByWithRelationInput | TrainClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrainClasses.
     */
    cursor?: TrainClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainClasses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainClasses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrainClasses.
     */
    distinct?: TrainClassScalarFieldEnum | TrainClassScalarFieldEnum[]
  }

  /**
   * TrainClass findMany
   */
  export type TrainClassFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainClass
     */
    select?: TrainClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainClassInclude<ExtArgs> | null
    /**
     * Filter, which TrainClasses to fetch.
     */
    where?: TrainClassWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainClasses to fetch.
     */
    orderBy?: TrainClassOrderByWithRelationInput | TrainClassOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TrainClasses.
     */
    cursor?: TrainClassWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainClasses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainClasses.
     */
    skip?: number
    distinct?: TrainClassScalarFieldEnum | TrainClassScalarFieldEnum[]
  }

  /**
   * TrainClass create
   */
  export type TrainClassCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainClass
     */
    select?: TrainClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainClassInclude<ExtArgs> | null
    /**
     * The data needed to create a TrainClass.
     */
    data: XOR<TrainClassCreateInput, TrainClassUncheckedCreateInput>
  }

  /**
   * TrainClass createMany
   */
  export type TrainClassCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TrainClasses.
     */
    data: TrainClassCreateManyInput | TrainClassCreateManyInput[]
  }

  /**
   * TrainClass createManyAndReturn
   */
  export type TrainClassCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainClass
     */
    select?: TrainClassSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TrainClasses.
     */
    data: TrainClassCreateManyInput | TrainClassCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainClassIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TrainClass update
   */
  export type TrainClassUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainClass
     */
    select?: TrainClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainClassInclude<ExtArgs> | null
    /**
     * The data needed to update a TrainClass.
     */
    data: XOR<TrainClassUpdateInput, TrainClassUncheckedUpdateInput>
    /**
     * Choose, which TrainClass to update.
     */
    where: TrainClassWhereUniqueInput
  }

  /**
   * TrainClass updateMany
   */
  export type TrainClassUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TrainClasses.
     */
    data: XOR<TrainClassUpdateManyMutationInput, TrainClassUncheckedUpdateManyInput>
    /**
     * Filter which TrainClasses to update
     */
    where?: TrainClassWhereInput
  }

  /**
   * TrainClass upsert
   */
  export type TrainClassUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainClass
     */
    select?: TrainClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainClassInclude<ExtArgs> | null
    /**
     * The filter to search for the TrainClass to update in case it exists.
     */
    where: TrainClassWhereUniqueInput
    /**
     * In case the TrainClass found by the `where` argument doesn't exist, create a new TrainClass with this data.
     */
    create: XOR<TrainClassCreateInput, TrainClassUncheckedCreateInput>
    /**
     * In case the TrainClass was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TrainClassUpdateInput, TrainClassUncheckedUpdateInput>
  }

  /**
   * TrainClass delete
   */
  export type TrainClassDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainClass
     */
    select?: TrainClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainClassInclude<ExtArgs> | null
    /**
     * Filter which TrainClass to delete.
     */
    where: TrainClassWhereUniqueInput
  }

  /**
   * TrainClass deleteMany
   */
  export type TrainClassDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrainClasses to delete
     */
    where?: TrainClassWhereInput
  }

  /**
   * TrainClass without action
   */
  export type TrainClassDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainClass
     */
    select?: TrainClassSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainClassInclude<ExtArgs> | null
  }


  /**
   * Model RouteStop
   */

  export type AggregateRouteStop = {
    _count: RouteStopCountAggregateOutputType | null
    _avg: RouteStopAvgAggregateOutputType | null
    _sum: RouteStopSumAggregateOutputType | null
    _min: RouteStopMinAggregateOutputType | null
    _max: RouteStopMaxAggregateOutputType | null
  }

  export type RouteStopAvgAggregateOutputType = {
    id: number | null
    stopOrder: number | null
    trainId: number | null
    stationId: number | null
  }

  export type RouteStopSumAggregateOutputType = {
    id: number | null
    stopOrder: number | null
    trainId: number | null
    stationId: number | null
  }

  export type RouteStopMinAggregateOutputType = {
    id: number | null
    stopOrder: number | null
    trainId: number | null
    stationId: number | null
    arrivalTime: Date | null
    departureTime: Date | null
  }

  export type RouteStopMaxAggregateOutputType = {
    id: number | null
    stopOrder: number | null
    trainId: number | null
    stationId: number | null
    arrivalTime: Date | null
    departureTime: Date | null
  }

  export type RouteStopCountAggregateOutputType = {
    id: number
    stopOrder: number
    trainId: number
    stationId: number
    arrivalTime: number
    departureTime: number
    _all: number
  }


  export type RouteStopAvgAggregateInputType = {
    id?: true
    stopOrder?: true
    trainId?: true
    stationId?: true
  }

  export type RouteStopSumAggregateInputType = {
    id?: true
    stopOrder?: true
    trainId?: true
    stationId?: true
  }

  export type RouteStopMinAggregateInputType = {
    id?: true
    stopOrder?: true
    trainId?: true
    stationId?: true
    arrivalTime?: true
    departureTime?: true
  }

  export type RouteStopMaxAggregateInputType = {
    id?: true
    stopOrder?: true
    trainId?: true
    stationId?: true
    arrivalTime?: true
    departureTime?: true
  }

  export type RouteStopCountAggregateInputType = {
    id?: true
    stopOrder?: true
    trainId?: true
    stationId?: true
    arrivalTime?: true
    departureTime?: true
    _all?: true
  }

  export type RouteStopAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RouteStop to aggregate.
     */
    where?: RouteStopWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RouteStops to fetch.
     */
    orderBy?: RouteStopOrderByWithRelationInput | RouteStopOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RouteStopWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RouteStops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RouteStops.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RouteStops
    **/
    _count?: true | RouteStopCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RouteStopAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RouteStopSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RouteStopMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RouteStopMaxAggregateInputType
  }

  export type GetRouteStopAggregateType<T extends RouteStopAggregateArgs> = {
        [P in keyof T & keyof AggregateRouteStop]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRouteStop[P]>
      : GetScalarType<T[P], AggregateRouteStop[P]>
  }




  export type RouteStopGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RouteStopWhereInput
    orderBy?: RouteStopOrderByWithAggregationInput | RouteStopOrderByWithAggregationInput[]
    by: RouteStopScalarFieldEnum[] | RouteStopScalarFieldEnum
    having?: RouteStopScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RouteStopCountAggregateInputType | true
    _avg?: RouteStopAvgAggregateInputType
    _sum?: RouteStopSumAggregateInputType
    _min?: RouteStopMinAggregateInputType
    _max?: RouteStopMaxAggregateInputType
  }

  export type RouteStopGroupByOutputType = {
    id: number
    stopOrder: number
    trainId: number
    stationId: number
    arrivalTime: Date | null
    departureTime: Date | null
    _count: RouteStopCountAggregateOutputType | null
    _avg: RouteStopAvgAggregateOutputType | null
    _sum: RouteStopSumAggregateOutputType | null
    _min: RouteStopMinAggregateOutputType | null
    _max: RouteStopMaxAggregateOutputType | null
  }

  type GetRouteStopGroupByPayload<T extends RouteStopGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RouteStopGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RouteStopGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RouteStopGroupByOutputType[P]>
            : GetScalarType<T[P], RouteStopGroupByOutputType[P]>
        }
      >
    >


  export type RouteStopSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    stopOrder?: boolean
    trainId?: boolean
    stationId?: boolean
    arrivalTime?: boolean
    departureTime?: boolean
    train?: boolean | TrainDefaultArgs<ExtArgs>
    station?: boolean | StationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["routeStop"]>

  export type RouteStopSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    stopOrder?: boolean
    trainId?: boolean
    stationId?: boolean
    arrivalTime?: boolean
    departureTime?: boolean
    train?: boolean | TrainDefaultArgs<ExtArgs>
    station?: boolean | StationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["routeStop"]>

  export type RouteStopSelectScalar = {
    id?: boolean
    stopOrder?: boolean
    trainId?: boolean
    stationId?: boolean
    arrivalTime?: boolean
    departureTime?: boolean
  }

  export type RouteStopInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    train?: boolean | TrainDefaultArgs<ExtArgs>
    station?: boolean | StationDefaultArgs<ExtArgs>
  }
  export type RouteStopIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    train?: boolean | TrainDefaultArgs<ExtArgs>
    station?: boolean | StationDefaultArgs<ExtArgs>
  }

  export type $RouteStopPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RouteStop"
    objects: {
      train: Prisma.$TrainPayload<ExtArgs>
      station: Prisma.$StationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      stopOrder: number
      trainId: number
      stationId: number
      arrivalTime: Date | null
      departureTime: Date | null
    }, ExtArgs["result"]["routeStop"]>
    composites: {}
  }

  type RouteStopGetPayload<S extends boolean | null | undefined | RouteStopDefaultArgs> = $Result.GetResult<Prisma.$RouteStopPayload, S>

  type RouteStopCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RouteStopFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RouteStopCountAggregateInputType | true
    }

  export interface RouteStopDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RouteStop'], meta: { name: 'RouteStop' } }
    /**
     * Find zero or one RouteStop that matches the filter.
     * @param {RouteStopFindUniqueArgs} args - Arguments to find a RouteStop
     * @example
     * // Get one RouteStop
     * const routeStop = await prisma.routeStop.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RouteStopFindUniqueArgs>(args: SelectSubset<T, RouteStopFindUniqueArgs<ExtArgs>>): Prisma__RouteStopClient<$Result.GetResult<Prisma.$RouteStopPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RouteStop that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RouteStopFindUniqueOrThrowArgs} args - Arguments to find a RouteStop
     * @example
     * // Get one RouteStop
     * const routeStop = await prisma.routeStop.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RouteStopFindUniqueOrThrowArgs>(args: SelectSubset<T, RouteStopFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RouteStopClient<$Result.GetResult<Prisma.$RouteStopPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RouteStop that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteStopFindFirstArgs} args - Arguments to find a RouteStop
     * @example
     * // Get one RouteStop
     * const routeStop = await prisma.routeStop.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RouteStopFindFirstArgs>(args?: SelectSubset<T, RouteStopFindFirstArgs<ExtArgs>>): Prisma__RouteStopClient<$Result.GetResult<Prisma.$RouteStopPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RouteStop that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteStopFindFirstOrThrowArgs} args - Arguments to find a RouteStop
     * @example
     * // Get one RouteStop
     * const routeStop = await prisma.routeStop.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RouteStopFindFirstOrThrowArgs>(args?: SelectSubset<T, RouteStopFindFirstOrThrowArgs<ExtArgs>>): Prisma__RouteStopClient<$Result.GetResult<Prisma.$RouteStopPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RouteStops that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteStopFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RouteStops
     * const routeStops = await prisma.routeStop.findMany()
     * 
     * // Get first 10 RouteStops
     * const routeStops = await prisma.routeStop.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const routeStopWithIdOnly = await prisma.routeStop.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RouteStopFindManyArgs>(args?: SelectSubset<T, RouteStopFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RouteStopPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RouteStop.
     * @param {RouteStopCreateArgs} args - Arguments to create a RouteStop.
     * @example
     * // Create one RouteStop
     * const RouteStop = await prisma.routeStop.create({
     *   data: {
     *     // ... data to create a RouteStop
     *   }
     * })
     * 
     */
    create<T extends RouteStopCreateArgs>(args: SelectSubset<T, RouteStopCreateArgs<ExtArgs>>): Prisma__RouteStopClient<$Result.GetResult<Prisma.$RouteStopPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RouteStops.
     * @param {RouteStopCreateManyArgs} args - Arguments to create many RouteStops.
     * @example
     * // Create many RouteStops
     * const routeStop = await prisma.routeStop.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RouteStopCreateManyArgs>(args?: SelectSubset<T, RouteStopCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RouteStops and returns the data saved in the database.
     * @param {RouteStopCreateManyAndReturnArgs} args - Arguments to create many RouteStops.
     * @example
     * // Create many RouteStops
     * const routeStop = await prisma.routeStop.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RouteStops and only return the `id`
     * const routeStopWithIdOnly = await prisma.routeStop.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RouteStopCreateManyAndReturnArgs>(args?: SelectSubset<T, RouteStopCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RouteStopPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RouteStop.
     * @param {RouteStopDeleteArgs} args - Arguments to delete one RouteStop.
     * @example
     * // Delete one RouteStop
     * const RouteStop = await prisma.routeStop.delete({
     *   where: {
     *     // ... filter to delete one RouteStop
     *   }
     * })
     * 
     */
    delete<T extends RouteStopDeleteArgs>(args: SelectSubset<T, RouteStopDeleteArgs<ExtArgs>>): Prisma__RouteStopClient<$Result.GetResult<Prisma.$RouteStopPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RouteStop.
     * @param {RouteStopUpdateArgs} args - Arguments to update one RouteStop.
     * @example
     * // Update one RouteStop
     * const routeStop = await prisma.routeStop.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RouteStopUpdateArgs>(args: SelectSubset<T, RouteStopUpdateArgs<ExtArgs>>): Prisma__RouteStopClient<$Result.GetResult<Prisma.$RouteStopPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RouteStops.
     * @param {RouteStopDeleteManyArgs} args - Arguments to filter RouteStops to delete.
     * @example
     * // Delete a few RouteStops
     * const { count } = await prisma.routeStop.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RouteStopDeleteManyArgs>(args?: SelectSubset<T, RouteStopDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RouteStops.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteStopUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RouteStops
     * const routeStop = await prisma.routeStop.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RouteStopUpdateManyArgs>(args: SelectSubset<T, RouteStopUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RouteStop.
     * @param {RouteStopUpsertArgs} args - Arguments to update or create a RouteStop.
     * @example
     * // Update or create a RouteStop
     * const routeStop = await prisma.routeStop.upsert({
     *   create: {
     *     // ... data to create a RouteStop
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RouteStop we want to update
     *   }
     * })
     */
    upsert<T extends RouteStopUpsertArgs>(args: SelectSubset<T, RouteStopUpsertArgs<ExtArgs>>): Prisma__RouteStopClient<$Result.GetResult<Prisma.$RouteStopPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RouteStops.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteStopCountArgs} args - Arguments to filter RouteStops to count.
     * @example
     * // Count the number of RouteStops
     * const count = await prisma.routeStop.count({
     *   where: {
     *     // ... the filter for the RouteStops we want to count
     *   }
     * })
    **/
    count<T extends RouteStopCountArgs>(
      args?: Subset<T, RouteStopCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RouteStopCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RouteStop.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteStopAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RouteStopAggregateArgs>(args: Subset<T, RouteStopAggregateArgs>): Prisma.PrismaPromise<GetRouteStopAggregateType<T>>

    /**
     * Group by RouteStop.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RouteStopGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RouteStopGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RouteStopGroupByArgs['orderBy'] }
        : { orderBy?: RouteStopGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RouteStopGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRouteStopGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RouteStop model
   */
  readonly fields: RouteStopFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RouteStop.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RouteStopClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    train<T extends TrainDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TrainDefaultArgs<ExtArgs>>): Prisma__TrainClient<$Result.GetResult<Prisma.$TrainPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    station<T extends StationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StationDefaultArgs<ExtArgs>>): Prisma__StationClient<$Result.GetResult<Prisma.$StationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RouteStop model
   */ 
  interface RouteStopFieldRefs {
    readonly id: FieldRef<"RouteStop", 'Int'>
    readonly stopOrder: FieldRef<"RouteStop", 'Int'>
    readonly trainId: FieldRef<"RouteStop", 'Int'>
    readonly stationId: FieldRef<"RouteStop", 'Int'>
    readonly arrivalTime: FieldRef<"RouteStop", 'DateTime'>
    readonly departureTime: FieldRef<"RouteStop", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RouteStop findUnique
   */
  export type RouteStopFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteStop
     */
    select?: RouteStopSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteStopInclude<ExtArgs> | null
    /**
     * Filter, which RouteStop to fetch.
     */
    where: RouteStopWhereUniqueInput
  }

  /**
   * RouteStop findUniqueOrThrow
   */
  export type RouteStopFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteStop
     */
    select?: RouteStopSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteStopInclude<ExtArgs> | null
    /**
     * Filter, which RouteStop to fetch.
     */
    where: RouteStopWhereUniqueInput
  }

  /**
   * RouteStop findFirst
   */
  export type RouteStopFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteStop
     */
    select?: RouteStopSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteStopInclude<ExtArgs> | null
    /**
     * Filter, which RouteStop to fetch.
     */
    where?: RouteStopWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RouteStops to fetch.
     */
    orderBy?: RouteStopOrderByWithRelationInput | RouteStopOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RouteStops.
     */
    cursor?: RouteStopWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RouteStops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RouteStops.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RouteStops.
     */
    distinct?: RouteStopScalarFieldEnum | RouteStopScalarFieldEnum[]
  }

  /**
   * RouteStop findFirstOrThrow
   */
  export type RouteStopFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteStop
     */
    select?: RouteStopSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteStopInclude<ExtArgs> | null
    /**
     * Filter, which RouteStop to fetch.
     */
    where?: RouteStopWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RouteStops to fetch.
     */
    orderBy?: RouteStopOrderByWithRelationInput | RouteStopOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RouteStops.
     */
    cursor?: RouteStopWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RouteStops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RouteStops.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RouteStops.
     */
    distinct?: RouteStopScalarFieldEnum | RouteStopScalarFieldEnum[]
  }

  /**
   * RouteStop findMany
   */
  export type RouteStopFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteStop
     */
    select?: RouteStopSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteStopInclude<ExtArgs> | null
    /**
     * Filter, which RouteStops to fetch.
     */
    where?: RouteStopWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RouteStops to fetch.
     */
    orderBy?: RouteStopOrderByWithRelationInput | RouteStopOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RouteStops.
     */
    cursor?: RouteStopWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RouteStops from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RouteStops.
     */
    skip?: number
    distinct?: RouteStopScalarFieldEnum | RouteStopScalarFieldEnum[]
  }

  /**
   * RouteStop create
   */
  export type RouteStopCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteStop
     */
    select?: RouteStopSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteStopInclude<ExtArgs> | null
    /**
     * The data needed to create a RouteStop.
     */
    data: XOR<RouteStopCreateInput, RouteStopUncheckedCreateInput>
  }

  /**
   * RouteStop createMany
   */
  export type RouteStopCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RouteStops.
     */
    data: RouteStopCreateManyInput | RouteStopCreateManyInput[]
  }

  /**
   * RouteStop createManyAndReturn
   */
  export type RouteStopCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteStop
     */
    select?: RouteStopSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RouteStops.
     */
    data: RouteStopCreateManyInput | RouteStopCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteStopIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RouteStop update
   */
  export type RouteStopUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteStop
     */
    select?: RouteStopSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteStopInclude<ExtArgs> | null
    /**
     * The data needed to update a RouteStop.
     */
    data: XOR<RouteStopUpdateInput, RouteStopUncheckedUpdateInput>
    /**
     * Choose, which RouteStop to update.
     */
    where: RouteStopWhereUniqueInput
  }

  /**
   * RouteStop updateMany
   */
  export type RouteStopUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RouteStops.
     */
    data: XOR<RouteStopUpdateManyMutationInput, RouteStopUncheckedUpdateManyInput>
    /**
     * Filter which RouteStops to update
     */
    where?: RouteStopWhereInput
  }

  /**
   * RouteStop upsert
   */
  export type RouteStopUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteStop
     */
    select?: RouteStopSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteStopInclude<ExtArgs> | null
    /**
     * The filter to search for the RouteStop to update in case it exists.
     */
    where: RouteStopWhereUniqueInput
    /**
     * In case the RouteStop found by the `where` argument doesn't exist, create a new RouteStop with this data.
     */
    create: XOR<RouteStopCreateInput, RouteStopUncheckedCreateInput>
    /**
     * In case the RouteStop was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RouteStopUpdateInput, RouteStopUncheckedUpdateInput>
  }

  /**
   * RouteStop delete
   */
  export type RouteStopDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteStop
     */
    select?: RouteStopSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteStopInclude<ExtArgs> | null
    /**
     * Filter which RouteStop to delete.
     */
    where: RouteStopWhereUniqueInput
  }

  /**
   * RouteStop deleteMany
   */
  export type RouteStopDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RouteStops to delete
     */
    where?: RouteStopWhereInput
  }

  /**
   * RouteStop without action
   */
  export type RouteStopDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RouteStop
     */
    select?: RouteStopSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RouteStopInclude<ExtArgs> | null
  }


  /**
   * Model Schedule
   */

  export type AggregateSchedule = {
    _count: ScheduleCountAggregateOutputType | null
    _avg: ScheduleAvgAggregateOutputType | null
    _sum: ScheduleSumAggregateOutputType | null
    _min: ScheduleMinAggregateOutputType | null
    _max: ScheduleMaxAggregateOutputType | null
  }

  export type ScheduleAvgAggregateOutputType = {
    id: number | null
    trainId: number | null
    departureStationId: number | null
    arrivalStationId: number | null
  }

  export type ScheduleSumAggregateOutputType = {
    id: number | null
    trainId: number | null
    departureStationId: number | null
    arrivalStationId: number | null
  }

  export type ScheduleMinAggregateOutputType = {
    id: number | null
    departureTime: Date | null
    arrivalTime: Date | null
    trainId: number | null
    departureStationId: number | null
    arrivalStationId: number | null
  }

  export type ScheduleMaxAggregateOutputType = {
    id: number | null
    departureTime: Date | null
    arrivalTime: Date | null
    trainId: number | null
    departureStationId: number | null
    arrivalStationId: number | null
  }

  export type ScheduleCountAggregateOutputType = {
    id: number
    departureTime: number
    arrivalTime: number
    trainId: number
    departureStationId: number
    arrivalStationId: number
    _all: number
  }


  export type ScheduleAvgAggregateInputType = {
    id?: true
    trainId?: true
    departureStationId?: true
    arrivalStationId?: true
  }

  export type ScheduleSumAggregateInputType = {
    id?: true
    trainId?: true
    departureStationId?: true
    arrivalStationId?: true
  }

  export type ScheduleMinAggregateInputType = {
    id?: true
    departureTime?: true
    arrivalTime?: true
    trainId?: true
    departureStationId?: true
    arrivalStationId?: true
  }

  export type ScheduleMaxAggregateInputType = {
    id?: true
    departureTime?: true
    arrivalTime?: true
    trainId?: true
    departureStationId?: true
    arrivalStationId?: true
  }

  export type ScheduleCountAggregateInputType = {
    id?: true
    departureTime?: true
    arrivalTime?: true
    trainId?: true
    departureStationId?: true
    arrivalStationId?: true
    _all?: true
  }

  export type ScheduleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Schedule to aggregate.
     */
    where?: ScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schedules to fetch.
     */
    orderBy?: ScheduleOrderByWithRelationInput | ScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Schedules
    **/
    _count?: true | ScheduleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ScheduleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ScheduleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ScheduleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ScheduleMaxAggregateInputType
  }

  export type GetScheduleAggregateType<T extends ScheduleAggregateArgs> = {
        [P in keyof T & keyof AggregateSchedule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSchedule[P]>
      : GetScalarType<T[P], AggregateSchedule[P]>
  }




  export type ScheduleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScheduleWhereInput
    orderBy?: ScheduleOrderByWithAggregationInput | ScheduleOrderByWithAggregationInput[]
    by: ScheduleScalarFieldEnum[] | ScheduleScalarFieldEnum
    having?: ScheduleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ScheduleCountAggregateInputType | true
    _avg?: ScheduleAvgAggregateInputType
    _sum?: ScheduleSumAggregateInputType
    _min?: ScheduleMinAggregateInputType
    _max?: ScheduleMaxAggregateInputType
  }

  export type ScheduleGroupByOutputType = {
    id: number
    departureTime: Date
    arrivalTime: Date
    trainId: number
    departureStationId: number
    arrivalStationId: number
    _count: ScheduleCountAggregateOutputType | null
    _avg: ScheduleAvgAggregateOutputType | null
    _sum: ScheduleSumAggregateOutputType | null
    _min: ScheduleMinAggregateOutputType | null
    _max: ScheduleMaxAggregateOutputType | null
  }

  type GetScheduleGroupByPayload<T extends ScheduleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ScheduleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ScheduleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ScheduleGroupByOutputType[P]>
            : GetScalarType<T[P], ScheduleGroupByOutputType[P]>
        }
      >
    >


  export type ScheduleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    departureTime?: boolean
    arrivalTime?: boolean
    trainId?: boolean
    departureStationId?: boolean
    arrivalStationId?: boolean
    train?: boolean | TrainDefaultArgs<ExtArgs>
    departureStation?: boolean | StationDefaultArgs<ExtArgs>
    arrivalStation?: boolean | StationDefaultArgs<ExtArgs>
    bookings?: boolean | Schedule$bookingsArgs<ExtArgs>
    _count?: boolean | ScheduleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["schedule"]>

  export type ScheduleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    departureTime?: boolean
    arrivalTime?: boolean
    trainId?: boolean
    departureStationId?: boolean
    arrivalStationId?: boolean
    train?: boolean | TrainDefaultArgs<ExtArgs>
    departureStation?: boolean | StationDefaultArgs<ExtArgs>
    arrivalStation?: boolean | StationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["schedule"]>

  export type ScheduleSelectScalar = {
    id?: boolean
    departureTime?: boolean
    arrivalTime?: boolean
    trainId?: boolean
    departureStationId?: boolean
    arrivalStationId?: boolean
  }

  export type ScheduleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    train?: boolean | TrainDefaultArgs<ExtArgs>
    departureStation?: boolean | StationDefaultArgs<ExtArgs>
    arrivalStation?: boolean | StationDefaultArgs<ExtArgs>
    bookings?: boolean | Schedule$bookingsArgs<ExtArgs>
    _count?: boolean | ScheduleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ScheduleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    train?: boolean | TrainDefaultArgs<ExtArgs>
    departureStation?: boolean | StationDefaultArgs<ExtArgs>
    arrivalStation?: boolean | StationDefaultArgs<ExtArgs>
  }

  export type $SchedulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Schedule"
    objects: {
      train: Prisma.$TrainPayload<ExtArgs>
      departureStation: Prisma.$StationPayload<ExtArgs>
      arrivalStation: Prisma.$StationPayload<ExtArgs>
      bookings: Prisma.$BookingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      departureTime: Date
      arrivalTime: Date
      trainId: number
      departureStationId: number
      arrivalStationId: number
    }, ExtArgs["result"]["schedule"]>
    composites: {}
  }

  type ScheduleGetPayload<S extends boolean | null | undefined | ScheduleDefaultArgs> = $Result.GetResult<Prisma.$SchedulePayload, S>

  type ScheduleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ScheduleFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ScheduleCountAggregateInputType | true
    }

  export interface ScheduleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Schedule'], meta: { name: 'Schedule' } }
    /**
     * Find zero or one Schedule that matches the filter.
     * @param {ScheduleFindUniqueArgs} args - Arguments to find a Schedule
     * @example
     * // Get one Schedule
     * const schedule = await prisma.schedule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ScheduleFindUniqueArgs>(args: SelectSubset<T, ScheduleFindUniqueArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Schedule that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ScheduleFindUniqueOrThrowArgs} args - Arguments to find a Schedule
     * @example
     * // Get one Schedule
     * const schedule = await prisma.schedule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ScheduleFindUniqueOrThrowArgs>(args: SelectSubset<T, ScheduleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Schedule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleFindFirstArgs} args - Arguments to find a Schedule
     * @example
     * // Get one Schedule
     * const schedule = await prisma.schedule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ScheduleFindFirstArgs>(args?: SelectSubset<T, ScheduleFindFirstArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Schedule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleFindFirstOrThrowArgs} args - Arguments to find a Schedule
     * @example
     * // Get one Schedule
     * const schedule = await prisma.schedule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ScheduleFindFirstOrThrowArgs>(args?: SelectSubset<T, ScheduleFindFirstOrThrowArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Schedules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Schedules
     * const schedules = await prisma.schedule.findMany()
     * 
     * // Get first 10 Schedules
     * const schedules = await prisma.schedule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const scheduleWithIdOnly = await prisma.schedule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ScheduleFindManyArgs>(args?: SelectSubset<T, ScheduleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Schedule.
     * @param {ScheduleCreateArgs} args - Arguments to create a Schedule.
     * @example
     * // Create one Schedule
     * const Schedule = await prisma.schedule.create({
     *   data: {
     *     // ... data to create a Schedule
     *   }
     * })
     * 
     */
    create<T extends ScheduleCreateArgs>(args: SelectSubset<T, ScheduleCreateArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Schedules.
     * @param {ScheduleCreateManyArgs} args - Arguments to create many Schedules.
     * @example
     * // Create many Schedules
     * const schedule = await prisma.schedule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ScheduleCreateManyArgs>(args?: SelectSubset<T, ScheduleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Schedules and returns the data saved in the database.
     * @param {ScheduleCreateManyAndReturnArgs} args - Arguments to create many Schedules.
     * @example
     * // Create many Schedules
     * const schedule = await prisma.schedule.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Schedules and only return the `id`
     * const scheduleWithIdOnly = await prisma.schedule.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ScheduleCreateManyAndReturnArgs>(args?: SelectSubset<T, ScheduleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Schedule.
     * @param {ScheduleDeleteArgs} args - Arguments to delete one Schedule.
     * @example
     * // Delete one Schedule
     * const Schedule = await prisma.schedule.delete({
     *   where: {
     *     // ... filter to delete one Schedule
     *   }
     * })
     * 
     */
    delete<T extends ScheduleDeleteArgs>(args: SelectSubset<T, ScheduleDeleteArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Schedule.
     * @param {ScheduleUpdateArgs} args - Arguments to update one Schedule.
     * @example
     * // Update one Schedule
     * const schedule = await prisma.schedule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ScheduleUpdateArgs>(args: SelectSubset<T, ScheduleUpdateArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Schedules.
     * @param {ScheduleDeleteManyArgs} args - Arguments to filter Schedules to delete.
     * @example
     * // Delete a few Schedules
     * const { count } = await prisma.schedule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ScheduleDeleteManyArgs>(args?: SelectSubset<T, ScheduleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Schedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Schedules
     * const schedule = await prisma.schedule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ScheduleUpdateManyArgs>(args: SelectSubset<T, ScheduleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Schedule.
     * @param {ScheduleUpsertArgs} args - Arguments to update or create a Schedule.
     * @example
     * // Update or create a Schedule
     * const schedule = await prisma.schedule.upsert({
     *   create: {
     *     // ... data to create a Schedule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Schedule we want to update
     *   }
     * })
     */
    upsert<T extends ScheduleUpsertArgs>(args: SelectSubset<T, ScheduleUpsertArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Schedules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleCountArgs} args - Arguments to filter Schedules to count.
     * @example
     * // Count the number of Schedules
     * const count = await prisma.schedule.count({
     *   where: {
     *     // ... the filter for the Schedules we want to count
     *   }
     * })
    **/
    count<T extends ScheduleCountArgs>(
      args?: Subset<T, ScheduleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ScheduleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Schedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ScheduleAggregateArgs>(args: Subset<T, ScheduleAggregateArgs>): Prisma.PrismaPromise<GetScheduleAggregateType<T>>

    /**
     * Group by Schedule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ScheduleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ScheduleGroupByArgs['orderBy'] }
        : { orderBy?: ScheduleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ScheduleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetScheduleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Schedule model
   */
  readonly fields: ScheduleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Schedule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ScheduleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    train<T extends TrainDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TrainDefaultArgs<ExtArgs>>): Prisma__TrainClient<$Result.GetResult<Prisma.$TrainPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    departureStation<T extends StationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StationDefaultArgs<ExtArgs>>): Prisma__StationClient<$Result.GetResult<Prisma.$StationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    arrivalStation<T extends StationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StationDefaultArgs<ExtArgs>>): Prisma__StationClient<$Result.GetResult<Prisma.$StationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    bookings<T extends Schedule$bookingsArgs<ExtArgs> = {}>(args?: Subset<T, Schedule$bookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Schedule model
   */ 
  interface ScheduleFieldRefs {
    readonly id: FieldRef<"Schedule", 'Int'>
    readonly departureTime: FieldRef<"Schedule", 'DateTime'>
    readonly arrivalTime: FieldRef<"Schedule", 'DateTime'>
    readonly trainId: FieldRef<"Schedule", 'Int'>
    readonly departureStationId: FieldRef<"Schedule", 'Int'>
    readonly arrivalStationId: FieldRef<"Schedule", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Schedule findUnique
   */
  export type ScheduleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * Filter, which Schedule to fetch.
     */
    where: ScheduleWhereUniqueInput
  }

  /**
   * Schedule findUniqueOrThrow
   */
  export type ScheduleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * Filter, which Schedule to fetch.
     */
    where: ScheduleWhereUniqueInput
  }

  /**
   * Schedule findFirst
   */
  export type ScheduleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * Filter, which Schedule to fetch.
     */
    where?: ScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schedules to fetch.
     */
    orderBy?: ScheduleOrderByWithRelationInput | ScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Schedules.
     */
    cursor?: ScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Schedules.
     */
    distinct?: ScheduleScalarFieldEnum | ScheduleScalarFieldEnum[]
  }

  /**
   * Schedule findFirstOrThrow
   */
  export type ScheduleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * Filter, which Schedule to fetch.
     */
    where?: ScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schedules to fetch.
     */
    orderBy?: ScheduleOrderByWithRelationInput | ScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Schedules.
     */
    cursor?: ScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schedules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Schedules.
     */
    distinct?: ScheduleScalarFieldEnum | ScheduleScalarFieldEnum[]
  }

  /**
   * Schedule findMany
   */
  export type ScheduleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * Filter, which Schedules to fetch.
     */
    where?: ScheduleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Schedules to fetch.
     */
    orderBy?: ScheduleOrderByWithRelationInput | ScheduleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Schedules.
     */
    cursor?: ScheduleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Schedules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Schedules.
     */
    skip?: number
    distinct?: ScheduleScalarFieldEnum | ScheduleScalarFieldEnum[]
  }

  /**
   * Schedule create
   */
  export type ScheduleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * The data needed to create a Schedule.
     */
    data: XOR<ScheduleCreateInput, ScheduleUncheckedCreateInput>
  }

  /**
   * Schedule createMany
   */
  export type ScheduleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Schedules.
     */
    data: ScheduleCreateManyInput | ScheduleCreateManyInput[]
  }

  /**
   * Schedule createManyAndReturn
   */
  export type ScheduleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Schedules.
     */
    data: ScheduleCreateManyInput | ScheduleCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Schedule update
   */
  export type ScheduleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * The data needed to update a Schedule.
     */
    data: XOR<ScheduleUpdateInput, ScheduleUncheckedUpdateInput>
    /**
     * Choose, which Schedule to update.
     */
    where: ScheduleWhereUniqueInput
  }

  /**
   * Schedule updateMany
   */
  export type ScheduleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Schedules.
     */
    data: XOR<ScheduleUpdateManyMutationInput, ScheduleUncheckedUpdateManyInput>
    /**
     * Filter which Schedules to update
     */
    where?: ScheduleWhereInput
  }

  /**
   * Schedule upsert
   */
  export type ScheduleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * The filter to search for the Schedule to update in case it exists.
     */
    where: ScheduleWhereUniqueInput
    /**
     * In case the Schedule found by the `where` argument doesn't exist, create a new Schedule with this data.
     */
    create: XOR<ScheduleCreateInput, ScheduleUncheckedCreateInput>
    /**
     * In case the Schedule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ScheduleUpdateInput, ScheduleUncheckedUpdateInput>
  }

  /**
   * Schedule delete
   */
  export type ScheduleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
    /**
     * Filter which Schedule to delete.
     */
    where: ScheduleWhereUniqueInput
  }

  /**
   * Schedule deleteMany
   */
  export type ScheduleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Schedules to delete
     */
    where?: ScheduleWhereInput
  }

  /**
   * Schedule.bookings
   */
  export type Schedule$bookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    cursor?: BookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Schedule without action
   */
  export type ScheduleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Schedule
     */
    select?: ScheduleSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleInclude<ExtArgs> | null
  }


  /**
   * Model FavoriteRoute
   */

  export type AggregateFavoriteRoute = {
    _count: FavoriteRouteCountAggregateOutputType | null
    _avg: FavoriteRouteAvgAggregateOutputType | null
    _sum: FavoriteRouteSumAggregateOutputType | null
    _min: FavoriteRouteMinAggregateOutputType | null
    _max: FavoriteRouteMaxAggregateOutputType | null
  }

  export type FavoriteRouteAvgAggregateOutputType = {
    id: number | null
    originStationId: number | null
    destinationStationId: number | null
  }

  export type FavoriteRouteSumAggregateOutputType = {
    id: number | null
    originStationId: number | null
    destinationStationId: number | null
  }

  export type FavoriteRouteMinAggregateOutputType = {
    id: number | null
    userId: string | null
    originStationId: number | null
    destinationStationId: number | null
  }

  export type FavoriteRouteMaxAggregateOutputType = {
    id: number | null
    userId: string | null
    originStationId: number | null
    destinationStationId: number | null
  }

  export type FavoriteRouteCountAggregateOutputType = {
    id: number
    userId: number
    originStationId: number
    destinationStationId: number
    _all: number
  }


  export type FavoriteRouteAvgAggregateInputType = {
    id?: true
    originStationId?: true
    destinationStationId?: true
  }

  export type FavoriteRouteSumAggregateInputType = {
    id?: true
    originStationId?: true
    destinationStationId?: true
  }

  export type FavoriteRouteMinAggregateInputType = {
    id?: true
    userId?: true
    originStationId?: true
    destinationStationId?: true
  }

  export type FavoriteRouteMaxAggregateInputType = {
    id?: true
    userId?: true
    originStationId?: true
    destinationStationId?: true
  }

  export type FavoriteRouteCountAggregateInputType = {
    id?: true
    userId?: true
    originStationId?: true
    destinationStationId?: true
    _all?: true
  }

  export type FavoriteRouteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FavoriteRoute to aggregate.
     */
    where?: FavoriteRouteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FavoriteRoutes to fetch.
     */
    orderBy?: FavoriteRouteOrderByWithRelationInput | FavoriteRouteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FavoriteRouteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FavoriteRoutes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FavoriteRoutes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FavoriteRoutes
    **/
    _count?: true | FavoriteRouteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FavoriteRouteAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FavoriteRouteSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FavoriteRouteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FavoriteRouteMaxAggregateInputType
  }

  export type GetFavoriteRouteAggregateType<T extends FavoriteRouteAggregateArgs> = {
        [P in keyof T & keyof AggregateFavoriteRoute]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFavoriteRoute[P]>
      : GetScalarType<T[P], AggregateFavoriteRoute[P]>
  }




  export type FavoriteRouteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FavoriteRouteWhereInput
    orderBy?: FavoriteRouteOrderByWithAggregationInput | FavoriteRouteOrderByWithAggregationInput[]
    by: FavoriteRouteScalarFieldEnum[] | FavoriteRouteScalarFieldEnum
    having?: FavoriteRouteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FavoriteRouteCountAggregateInputType | true
    _avg?: FavoriteRouteAvgAggregateInputType
    _sum?: FavoriteRouteSumAggregateInputType
    _min?: FavoriteRouteMinAggregateInputType
    _max?: FavoriteRouteMaxAggregateInputType
  }

  export type FavoriteRouteGroupByOutputType = {
    id: number
    userId: string
    originStationId: number
    destinationStationId: number
    _count: FavoriteRouteCountAggregateOutputType | null
    _avg: FavoriteRouteAvgAggregateOutputType | null
    _sum: FavoriteRouteSumAggregateOutputType | null
    _min: FavoriteRouteMinAggregateOutputType | null
    _max: FavoriteRouteMaxAggregateOutputType | null
  }

  type GetFavoriteRouteGroupByPayload<T extends FavoriteRouteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FavoriteRouteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FavoriteRouteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FavoriteRouteGroupByOutputType[P]>
            : GetScalarType<T[P], FavoriteRouteGroupByOutputType[P]>
        }
      >
    >


  export type FavoriteRouteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    originStationId?: boolean
    destinationStationId?: boolean
    origin?: boolean | StationDefaultArgs<ExtArgs>
    destination?: boolean | StationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["favoriteRoute"]>

  export type FavoriteRouteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    originStationId?: boolean
    destinationStationId?: boolean
    origin?: boolean | StationDefaultArgs<ExtArgs>
    destination?: boolean | StationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["favoriteRoute"]>

  export type FavoriteRouteSelectScalar = {
    id?: boolean
    userId?: boolean
    originStationId?: boolean
    destinationStationId?: boolean
  }

  export type FavoriteRouteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    origin?: boolean | StationDefaultArgs<ExtArgs>
    destination?: boolean | StationDefaultArgs<ExtArgs>
  }
  export type FavoriteRouteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    origin?: boolean | StationDefaultArgs<ExtArgs>
    destination?: boolean | StationDefaultArgs<ExtArgs>
  }

  export type $FavoriteRoutePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FavoriteRoute"
    objects: {
      origin: Prisma.$StationPayload<ExtArgs>
      destination: Prisma.$StationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: string
      originStationId: number
      destinationStationId: number
    }, ExtArgs["result"]["favoriteRoute"]>
    composites: {}
  }

  type FavoriteRouteGetPayload<S extends boolean | null | undefined | FavoriteRouteDefaultArgs> = $Result.GetResult<Prisma.$FavoriteRoutePayload, S>

  type FavoriteRouteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FavoriteRouteFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FavoriteRouteCountAggregateInputType | true
    }

  export interface FavoriteRouteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FavoriteRoute'], meta: { name: 'FavoriteRoute' } }
    /**
     * Find zero or one FavoriteRoute that matches the filter.
     * @param {FavoriteRouteFindUniqueArgs} args - Arguments to find a FavoriteRoute
     * @example
     * // Get one FavoriteRoute
     * const favoriteRoute = await prisma.favoriteRoute.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FavoriteRouteFindUniqueArgs>(args: SelectSubset<T, FavoriteRouteFindUniqueArgs<ExtArgs>>): Prisma__FavoriteRouteClient<$Result.GetResult<Prisma.$FavoriteRoutePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one FavoriteRoute that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FavoriteRouteFindUniqueOrThrowArgs} args - Arguments to find a FavoriteRoute
     * @example
     * // Get one FavoriteRoute
     * const favoriteRoute = await prisma.favoriteRoute.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FavoriteRouteFindUniqueOrThrowArgs>(args: SelectSubset<T, FavoriteRouteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FavoriteRouteClient<$Result.GetResult<Prisma.$FavoriteRoutePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first FavoriteRoute that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteRouteFindFirstArgs} args - Arguments to find a FavoriteRoute
     * @example
     * // Get one FavoriteRoute
     * const favoriteRoute = await prisma.favoriteRoute.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FavoriteRouteFindFirstArgs>(args?: SelectSubset<T, FavoriteRouteFindFirstArgs<ExtArgs>>): Prisma__FavoriteRouteClient<$Result.GetResult<Prisma.$FavoriteRoutePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first FavoriteRoute that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteRouteFindFirstOrThrowArgs} args - Arguments to find a FavoriteRoute
     * @example
     * // Get one FavoriteRoute
     * const favoriteRoute = await prisma.favoriteRoute.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FavoriteRouteFindFirstOrThrowArgs>(args?: SelectSubset<T, FavoriteRouteFindFirstOrThrowArgs<ExtArgs>>): Prisma__FavoriteRouteClient<$Result.GetResult<Prisma.$FavoriteRoutePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more FavoriteRoutes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteRouteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FavoriteRoutes
     * const favoriteRoutes = await prisma.favoriteRoute.findMany()
     * 
     * // Get first 10 FavoriteRoutes
     * const favoriteRoutes = await prisma.favoriteRoute.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const favoriteRouteWithIdOnly = await prisma.favoriteRoute.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FavoriteRouteFindManyArgs>(args?: SelectSubset<T, FavoriteRouteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FavoriteRoutePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a FavoriteRoute.
     * @param {FavoriteRouteCreateArgs} args - Arguments to create a FavoriteRoute.
     * @example
     * // Create one FavoriteRoute
     * const FavoriteRoute = await prisma.favoriteRoute.create({
     *   data: {
     *     // ... data to create a FavoriteRoute
     *   }
     * })
     * 
     */
    create<T extends FavoriteRouteCreateArgs>(args: SelectSubset<T, FavoriteRouteCreateArgs<ExtArgs>>): Prisma__FavoriteRouteClient<$Result.GetResult<Prisma.$FavoriteRoutePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many FavoriteRoutes.
     * @param {FavoriteRouteCreateManyArgs} args - Arguments to create many FavoriteRoutes.
     * @example
     * // Create many FavoriteRoutes
     * const favoriteRoute = await prisma.favoriteRoute.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FavoriteRouteCreateManyArgs>(args?: SelectSubset<T, FavoriteRouteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FavoriteRoutes and returns the data saved in the database.
     * @param {FavoriteRouteCreateManyAndReturnArgs} args - Arguments to create many FavoriteRoutes.
     * @example
     * // Create many FavoriteRoutes
     * const favoriteRoute = await prisma.favoriteRoute.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FavoriteRoutes and only return the `id`
     * const favoriteRouteWithIdOnly = await prisma.favoriteRoute.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FavoriteRouteCreateManyAndReturnArgs>(args?: SelectSubset<T, FavoriteRouteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FavoriteRoutePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a FavoriteRoute.
     * @param {FavoriteRouteDeleteArgs} args - Arguments to delete one FavoriteRoute.
     * @example
     * // Delete one FavoriteRoute
     * const FavoriteRoute = await prisma.favoriteRoute.delete({
     *   where: {
     *     // ... filter to delete one FavoriteRoute
     *   }
     * })
     * 
     */
    delete<T extends FavoriteRouteDeleteArgs>(args: SelectSubset<T, FavoriteRouteDeleteArgs<ExtArgs>>): Prisma__FavoriteRouteClient<$Result.GetResult<Prisma.$FavoriteRoutePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one FavoriteRoute.
     * @param {FavoriteRouteUpdateArgs} args - Arguments to update one FavoriteRoute.
     * @example
     * // Update one FavoriteRoute
     * const favoriteRoute = await prisma.favoriteRoute.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FavoriteRouteUpdateArgs>(args: SelectSubset<T, FavoriteRouteUpdateArgs<ExtArgs>>): Prisma__FavoriteRouteClient<$Result.GetResult<Prisma.$FavoriteRoutePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more FavoriteRoutes.
     * @param {FavoriteRouteDeleteManyArgs} args - Arguments to filter FavoriteRoutes to delete.
     * @example
     * // Delete a few FavoriteRoutes
     * const { count } = await prisma.favoriteRoute.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FavoriteRouteDeleteManyArgs>(args?: SelectSubset<T, FavoriteRouteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FavoriteRoutes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteRouteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FavoriteRoutes
     * const favoriteRoute = await prisma.favoriteRoute.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FavoriteRouteUpdateManyArgs>(args: SelectSubset<T, FavoriteRouteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one FavoriteRoute.
     * @param {FavoriteRouteUpsertArgs} args - Arguments to update or create a FavoriteRoute.
     * @example
     * // Update or create a FavoriteRoute
     * const favoriteRoute = await prisma.favoriteRoute.upsert({
     *   create: {
     *     // ... data to create a FavoriteRoute
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FavoriteRoute we want to update
     *   }
     * })
     */
    upsert<T extends FavoriteRouteUpsertArgs>(args: SelectSubset<T, FavoriteRouteUpsertArgs<ExtArgs>>): Prisma__FavoriteRouteClient<$Result.GetResult<Prisma.$FavoriteRoutePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of FavoriteRoutes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteRouteCountArgs} args - Arguments to filter FavoriteRoutes to count.
     * @example
     * // Count the number of FavoriteRoutes
     * const count = await prisma.favoriteRoute.count({
     *   where: {
     *     // ... the filter for the FavoriteRoutes we want to count
     *   }
     * })
    **/
    count<T extends FavoriteRouteCountArgs>(
      args?: Subset<T, FavoriteRouteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FavoriteRouteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FavoriteRoute.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteRouteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FavoriteRouteAggregateArgs>(args: Subset<T, FavoriteRouteAggregateArgs>): Prisma.PrismaPromise<GetFavoriteRouteAggregateType<T>>

    /**
     * Group by FavoriteRoute.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FavoriteRouteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FavoriteRouteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FavoriteRouteGroupByArgs['orderBy'] }
        : { orderBy?: FavoriteRouteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FavoriteRouteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFavoriteRouteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FavoriteRoute model
   */
  readonly fields: FavoriteRouteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FavoriteRoute.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FavoriteRouteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    origin<T extends StationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StationDefaultArgs<ExtArgs>>): Prisma__StationClient<$Result.GetResult<Prisma.$StationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    destination<T extends StationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StationDefaultArgs<ExtArgs>>): Prisma__StationClient<$Result.GetResult<Prisma.$StationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FavoriteRoute model
   */ 
  interface FavoriteRouteFieldRefs {
    readonly id: FieldRef<"FavoriteRoute", 'Int'>
    readonly userId: FieldRef<"FavoriteRoute", 'String'>
    readonly originStationId: FieldRef<"FavoriteRoute", 'Int'>
    readonly destinationStationId: FieldRef<"FavoriteRoute", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * FavoriteRoute findUnique
   */
  export type FavoriteRouteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FavoriteRoute
     */
    select?: FavoriteRouteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteRouteInclude<ExtArgs> | null
    /**
     * Filter, which FavoriteRoute to fetch.
     */
    where: FavoriteRouteWhereUniqueInput
  }

  /**
   * FavoriteRoute findUniqueOrThrow
   */
  export type FavoriteRouteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FavoriteRoute
     */
    select?: FavoriteRouteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteRouteInclude<ExtArgs> | null
    /**
     * Filter, which FavoriteRoute to fetch.
     */
    where: FavoriteRouteWhereUniqueInput
  }

  /**
   * FavoriteRoute findFirst
   */
  export type FavoriteRouteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FavoriteRoute
     */
    select?: FavoriteRouteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteRouteInclude<ExtArgs> | null
    /**
     * Filter, which FavoriteRoute to fetch.
     */
    where?: FavoriteRouteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FavoriteRoutes to fetch.
     */
    orderBy?: FavoriteRouteOrderByWithRelationInput | FavoriteRouteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FavoriteRoutes.
     */
    cursor?: FavoriteRouteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FavoriteRoutes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FavoriteRoutes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FavoriteRoutes.
     */
    distinct?: FavoriteRouteScalarFieldEnum | FavoriteRouteScalarFieldEnum[]
  }

  /**
   * FavoriteRoute findFirstOrThrow
   */
  export type FavoriteRouteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FavoriteRoute
     */
    select?: FavoriteRouteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteRouteInclude<ExtArgs> | null
    /**
     * Filter, which FavoriteRoute to fetch.
     */
    where?: FavoriteRouteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FavoriteRoutes to fetch.
     */
    orderBy?: FavoriteRouteOrderByWithRelationInput | FavoriteRouteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FavoriteRoutes.
     */
    cursor?: FavoriteRouteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FavoriteRoutes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FavoriteRoutes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FavoriteRoutes.
     */
    distinct?: FavoriteRouteScalarFieldEnum | FavoriteRouteScalarFieldEnum[]
  }

  /**
   * FavoriteRoute findMany
   */
  export type FavoriteRouteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FavoriteRoute
     */
    select?: FavoriteRouteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteRouteInclude<ExtArgs> | null
    /**
     * Filter, which FavoriteRoutes to fetch.
     */
    where?: FavoriteRouteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FavoriteRoutes to fetch.
     */
    orderBy?: FavoriteRouteOrderByWithRelationInput | FavoriteRouteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FavoriteRoutes.
     */
    cursor?: FavoriteRouteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FavoriteRoutes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FavoriteRoutes.
     */
    skip?: number
    distinct?: FavoriteRouteScalarFieldEnum | FavoriteRouteScalarFieldEnum[]
  }

  /**
   * FavoriteRoute create
   */
  export type FavoriteRouteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FavoriteRoute
     */
    select?: FavoriteRouteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteRouteInclude<ExtArgs> | null
    /**
     * The data needed to create a FavoriteRoute.
     */
    data: XOR<FavoriteRouteCreateInput, FavoriteRouteUncheckedCreateInput>
  }

  /**
   * FavoriteRoute createMany
   */
  export type FavoriteRouteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FavoriteRoutes.
     */
    data: FavoriteRouteCreateManyInput | FavoriteRouteCreateManyInput[]
  }

  /**
   * FavoriteRoute createManyAndReturn
   */
  export type FavoriteRouteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FavoriteRoute
     */
    select?: FavoriteRouteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many FavoriteRoutes.
     */
    data: FavoriteRouteCreateManyInput | FavoriteRouteCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteRouteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FavoriteRoute update
   */
  export type FavoriteRouteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FavoriteRoute
     */
    select?: FavoriteRouteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteRouteInclude<ExtArgs> | null
    /**
     * The data needed to update a FavoriteRoute.
     */
    data: XOR<FavoriteRouteUpdateInput, FavoriteRouteUncheckedUpdateInput>
    /**
     * Choose, which FavoriteRoute to update.
     */
    where: FavoriteRouteWhereUniqueInput
  }

  /**
   * FavoriteRoute updateMany
   */
  export type FavoriteRouteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FavoriteRoutes.
     */
    data: XOR<FavoriteRouteUpdateManyMutationInput, FavoriteRouteUncheckedUpdateManyInput>
    /**
     * Filter which FavoriteRoutes to update
     */
    where?: FavoriteRouteWhereInput
  }

  /**
   * FavoriteRoute upsert
   */
  export type FavoriteRouteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FavoriteRoute
     */
    select?: FavoriteRouteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteRouteInclude<ExtArgs> | null
    /**
     * The filter to search for the FavoriteRoute to update in case it exists.
     */
    where: FavoriteRouteWhereUniqueInput
    /**
     * In case the FavoriteRoute found by the `where` argument doesn't exist, create a new FavoriteRoute with this data.
     */
    create: XOR<FavoriteRouteCreateInput, FavoriteRouteUncheckedCreateInput>
    /**
     * In case the FavoriteRoute was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FavoriteRouteUpdateInput, FavoriteRouteUncheckedUpdateInput>
  }

  /**
   * FavoriteRoute delete
   */
  export type FavoriteRouteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FavoriteRoute
     */
    select?: FavoriteRouteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteRouteInclude<ExtArgs> | null
    /**
     * Filter which FavoriteRoute to delete.
     */
    where: FavoriteRouteWhereUniqueInput
  }

  /**
   * FavoriteRoute deleteMany
   */
  export type FavoriteRouteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FavoriteRoutes to delete
     */
    where?: FavoriteRouteWhereInput
  }

  /**
   * FavoriteRoute without action
   */
  export type FavoriteRouteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FavoriteRoute
     */
    select?: FavoriteRouteSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FavoriteRouteInclude<ExtArgs> | null
  }


  /**
   * Model SearchHistory
   */

  export type AggregateSearchHistory = {
    _count: SearchHistoryCountAggregateOutputType | null
    _avg: SearchHistoryAvgAggregateOutputType | null
    _sum: SearchHistorySumAggregateOutputType | null
    _min: SearchHistoryMinAggregateOutputType | null
    _max: SearchHistoryMaxAggregateOutputType | null
  }

  export type SearchHistoryAvgAggregateOutputType = {
    id: number | null
    originStationId: number | null
    destinationStationId: number | null
  }

  export type SearchHistorySumAggregateOutputType = {
    id: number | null
    originStationId: number | null
    destinationStationId: number | null
  }

  export type SearchHistoryMinAggregateOutputType = {
    id: number | null
    userId: string | null
    searchDate: Date | null
    originStationId: number | null
    destinationStationId: number | null
  }

  export type SearchHistoryMaxAggregateOutputType = {
    id: number | null
    userId: string | null
    searchDate: Date | null
    originStationId: number | null
    destinationStationId: number | null
  }

  export type SearchHistoryCountAggregateOutputType = {
    id: number
    userId: number
    searchDate: number
    originStationId: number
    destinationStationId: number
    _all: number
  }


  export type SearchHistoryAvgAggregateInputType = {
    id?: true
    originStationId?: true
    destinationStationId?: true
  }

  export type SearchHistorySumAggregateInputType = {
    id?: true
    originStationId?: true
    destinationStationId?: true
  }

  export type SearchHistoryMinAggregateInputType = {
    id?: true
    userId?: true
    searchDate?: true
    originStationId?: true
    destinationStationId?: true
  }

  export type SearchHistoryMaxAggregateInputType = {
    id?: true
    userId?: true
    searchDate?: true
    originStationId?: true
    destinationStationId?: true
  }

  export type SearchHistoryCountAggregateInputType = {
    id?: true
    userId?: true
    searchDate?: true
    originStationId?: true
    destinationStationId?: true
    _all?: true
  }

  export type SearchHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SearchHistory to aggregate.
     */
    where?: SearchHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SearchHistories to fetch.
     */
    orderBy?: SearchHistoryOrderByWithRelationInput | SearchHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SearchHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SearchHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SearchHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SearchHistories
    **/
    _count?: true | SearchHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SearchHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SearchHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SearchHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SearchHistoryMaxAggregateInputType
  }

  export type GetSearchHistoryAggregateType<T extends SearchHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateSearchHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSearchHistory[P]>
      : GetScalarType<T[P], AggregateSearchHistory[P]>
  }




  export type SearchHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SearchHistoryWhereInput
    orderBy?: SearchHistoryOrderByWithAggregationInput | SearchHistoryOrderByWithAggregationInput[]
    by: SearchHistoryScalarFieldEnum[] | SearchHistoryScalarFieldEnum
    having?: SearchHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SearchHistoryCountAggregateInputType | true
    _avg?: SearchHistoryAvgAggregateInputType
    _sum?: SearchHistorySumAggregateInputType
    _min?: SearchHistoryMinAggregateInputType
    _max?: SearchHistoryMaxAggregateInputType
  }

  export type SearchHistoryGroupByOutputType = {
    id: number
    userId: string
    searchDate: Date
    originStationId: number
    destinationStationId: number
    _count: SearchHistoryCountAggregateOutputType | null
    _avg: SearchHistoryAvgAggregateOutputType | null
    _sum: SearchHistorySumAggregateOutputType | null
    _min: SearchHistoryMinAggregateOutputType | null
    _max: SearchHistoryMaxAggregateOutputType | null
  }

  type GetSearchHistoryGroupByPayload<T extends SearchHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SearchHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SearchHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SearchHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], SearchHistoryGroupByOutputType[P]>
        }
      >
    >


  export type SearchHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    searchDate?: boolean
    originStationId?: boolean
    destinationStationId?: boolean
    origin?: boolean | StationDefaultArgs<ExtArgs>
    destination?: boolean | StationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["searchHistory"]>

  export type SearchHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    searchDate?: boolean
    originStationId?: boolean
    destinationStationId?: boolean
    origin?: boolean | StationDefaultArgs<ExtArgs>
    destination?: boolean | StationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["searchHistory"]>

  export type SearchHistorySelectScalar = {
    id?: boolean
    userId?: boolean
    searchDate?: boolean
    originStationId?: boolean
    destinationStationId?: boolean
  }

  export type SearchHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    origin?: boolean | StationDefaultArgs<ExtArgs>
    destination?: boolean | StationDefaultArgs<ExtArgs>
  }
  export type SearchHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    origin?: boolean | StationDefaultArgs<ExtArgs>
    destination?: boolean | StationDefaultArgs<ExtArgs>
  }

  export type $SearchHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SearchHistory"
    objects: {
      origin: Prisma.$StationPayload<ExtArgs>
      destination: Prisma.$StationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: string
      searchDate: Date
      originStationId: number
      destinationStationId: number
    }, ExtArgs["result"]["searchHistory"]>
    composites: {}
  }

  type SearchHistoryGetPayload<S extends boolean | null | undefined | SearchHistoryDefaultArgs> = $Result.GetResult<Prisma.$SearchHistoryPayload, S>

  type SearchHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SearchHistoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SearchHistoryCountAggregateInputType | true
    }

  export interface SearchHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SearchHistory'], meta: { name: 'SearchHistory' } }
    /**
     * Find zero or one SearchHistory that matches the filter.
     * @param {SearchHistoryFindUniqueArgs} args - Arguments to find a SearchHistory
     * @example
     * // Get one SearchHistory
     * const searchHistory = await prisma.searchHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SearchHistoryFindUniqueArgs>(args: SelectSubset<T, SearchHistoryFindUniqueArgs<ExtArgs>>): Prisma__SearchHistoryClient<$Result.GetResult<Prisma.$SearchHistoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SearchHistory that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SearchHistoryFindUniqueOrThrowArgs} args - Arguments to find a SearchHistory
     * @example
     * // Get one SearchHistory
     * const searchHistory = await prisma.searchHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SearchHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, SearchHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SearchHistoryClient<$Result.GetResult<Prisma.$SearchHistoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SearchHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchHistoryFindFirstArgs} args - Arguments to find a SearchHistory
     * @example
     * // Get one SearchHistory
     * const searchHistory = await prisma.searchHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SearchHistoryFindFirstArgs>(args?: SelectSubset<T, SearchHistoryFindFirstArgs<ExtArgs>>): Prisma__SearchHistoryClient<$Result.GetResult<Prisma.$SearchHistoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SearchHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchHistoryFindFirstOrThrowArgs} args - Arguments to find a SearchHistory
     * @example
     * // Get one SearchHistory
     * const searchHistory = await prisma.searchHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SearchHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, SearchHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__SearchHistoryClient<$Result.GetResult<Prisma.$SearchHistoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SearchHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SearchHistories
     * const searchHistories = await prisma.searchHistory.findMany()
     * 
     * // Get first 10 SearchHistories
     * const searchHistories = await prisma.searchHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const searchHistoryWithIdOnly = await prisma.searchHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SearchHistoryFindManyArgs>(args?: SelectSubset<T, SearchHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SearchHistoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SearchHistory.
     * @param {SearchHistoryCreateArgs} args - Arguments to create a SearchHistory.
     * @example
     * // Create one SearchHistory
     * const SearchHistory = await prisma.searchHistory.create({
     *   data: {
     *     // ... data to create a SearchHistory
     *   }
     * })
     * 
     */
    create<T extends SearchHistoryCreateArgs>(args: SelectSubset<T, SearchHistoryCreateArgs<ExtArgs>>): Prisma__SearchHistoryClient<$Result.GetResult<Prisma.$SearchHistoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SearchHistories.
     * @param {SearchHistoryCreateManyArgs} args - Arguments to create many SearchHistories.
     * @example
     * // Create many SearchHistories
     * const searchHistory = await prisma.searchHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SearchHistoryCreateManyArgs>(args?: SelectSubset<T, SearchHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SearchHistories and returns the data saved in the database.
     * @param {SearchHistoryCreateManyAndReturnArgs} args - Arguments to create many SearchHistories.
     * @example
     * // Create many SearchHistories
     * const searchHistory = await prisma.searchHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SearchHistories and only return the `id`
     * const searchHistoryWithIdOnly = await prisma.searchHistory.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SearchHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, SearchHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SearchHistoryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SearchHistory.
     * @param {SearchHistoryDeleteArgs} args - Arguments to delete one SearchHistory.
     * @example
     * // Delete one SearchHistory
     * const SearchHistory = await prisma.searchHistory.delete({
     *   where: {
     *     // ... filter to delete one SearchHistory
     *   }
     * })
     * 
     */
    delete<T extends SearchHistoryDeleteArgs>(args: SelectSubset<T, SearchHistoryDeleteArgs<ExtArgs>>): Prisma__SearchHistoryClient<$Result.GetResult<Prisma.$SearchHistoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SearchHistory.
     * @param {SearchHistoryUpdateArgs} args - Arguments to update one SearchHistory.
     * @example
     * // Update one SearchHistory
     * const searchHistory = await prisma.searchHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SearchHistoryUpdateArgs>(args: SelectSubset<T, SearchHistoryUpdateArgs<ExtArgs>>): Prisma__SearchHistoryClient<$Result.GetResult<Prisma.$SearchHistoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SearchHistories.
     * @param {SearchHistoryDeleteManyArgs} args - Arguments to filter SearchHistories to delete.
     * @example
     * // Delete a few SearchHistories
     * const { count } = await prisma.searchHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SearchHistoryDeleteManyArgs>(args?: SelectSubset<T, SearchHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SearchHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SearchHistories
     * const searchHistory = await prisma.searchHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SearchHistoryUpdateManyArgs>(args: SelectSubset<T, SearchHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SearchHistory.
     * @param {SearchHistoryUpsertArgs} args - Arguments to update or create a SearchHistory.
     * @example
     * // Update or create a SearchHistory
     * const searchHistory = await prisma.searchHistory.upsert({
     *   create: {
     *     // ... data to create a SearchHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SearchHistory we want to update
     *   }
     * })
     */
    upsert<T extends SearchHistoryUpsertArgs>(args: SelectSubset<T, SearchHistoryUpsertArgs<ExtArgs>>): Prisma__SearchHistoryClient<$Result.GetResult<Prisma.$SearchHistoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SearchHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchHistoryCountArgs} args - Arguments to filter SearchHistories to count.
     * @example
     * // Count the number of SearchHistories
     * const count = await prisma.searchHistory.count({
     *   where: {
     *     // ... the filter for the SearchHistories we want to count
     *   }
     * })
    **/
    count<T extends SearchHistoryCountArgs>(
      args?: Subset<T, SearchHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SearchHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SearchHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SearchHistoryAggregateArgs>(args: Subset<T, SearchHistoryAggregateArgs>): Prisma.PrismaPromise<GetSearchHistoryAggregateType<T>>

    /**
     * Group by SearchHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SearchHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SearchHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SearchHistoryGroupByArgs['orderBy'] }
        : { orderBy?: SearchHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SearchHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSearchHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SearchHistory model
   */
  readonly fields: SearchHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SearchHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SearchHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    origin<T extends StationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StationDefaultArgs<ExtArgs>>): Prisma__StationClient<$Result.GetResult<Prisma.$StationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    destination<T extends StationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StationDefaultArgs<ExtArgs>>): Prisma__StationClient<$Result.GetResult<Prisma.$StationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SearchHistory model
   */ 
  interface SearchHistoryFieldRefs {
    readonly id: FieldRef<"SearchHistory", 'Int'>
    readonly userId: FieldRef<"SearchHistory", 'String'>
    readonly searchDate: FieldRef<"SearchHistory", 'DateTime'>
    readonly originStationId: FieldRef<"SearchHistory", 'Int'>
    readonly destinationStationId: FieldRef<"SearchHistory", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * SearchHistory findUnique
   */
  export type SearchHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchHistory
     */
    select?: SearchHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchHistoryInclude<ExtArgs> | null
    /**
     * Filter, which SearchHistory to fetch.
     */
    where: SearchHistoryWhereUniqueInput
  }

  /**
   * SearchHistory findUniqueOrThrow
   */
  export type SearchHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchHistory
     */
    select?: SearchHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchHistoryInclude<ExtArgs> | null
    /**
     * Filter, which SearchHistory to fetch.
     */
    where: SearchHistoryWhereUniqueInput
  }

  /**
   * SearchHistory findFirst
   */
  export type SearchHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchHistory
     */
    select?: SearchHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchHistoryInclude<ExtArgs> | null
    /**
     * Filter, which SearchHistory to fetch.
     */
    where?: SearchHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SearchHistories to fetch.
     */
    orderBy?: SearchHistoryOrderByWithRelationInput | SearchHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SearchHistories.
     */
    cursor?: SearchHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SearchHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SearchHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SearchHistories.
     */
    distinct?: SearchHistoryScalarFieldEnum | SearchHistoryScalarFieldEnum[]
  }

  /**
   * SearchHistory findFirstOrThrow
   */
  export type SearchHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchHistory
     */
    select?: SearchHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchHistoryInclude<ExtArgs> | null
    /**
     * Filter, which SearchHistory to fetch.
     */
    where?: SearchHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SearchHistories to fetch.
     */
    orderBy?: SearchHistoryOrderByWithRelationInput | SearchHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SearchHistories.
     */
    cursor?: SearchHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SearchHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SearchHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SearchHistories.
     */
    distinct?: SearchHistoryScalarFieldEnum | SearchHistoryScalarFieldEnum[]
  }

  /**
   * SearchHistory findMany
   */
  export type SearchHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchHistory
     */
    select?: SearchHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchHistoryInclude<ExtArgs> | null
    /**
     * Filter, which SearchHistories to fetch.
     */
    where?: SearchHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SearchHistories to fetch.
     */
    orderBy?: SearchHistoryOrderByWithRelationInput | SearchHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SearchHistories.
     */
    cursor?: SearchHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SearchHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SearchHistories.
     */
    skip?: number
    distinct?: SearchHistoryScalarFieldEnum | SearchHistoryScalarFieldEnum[]
  }

  /**
   * SearchHistory create
   */
  export type SearchHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchHistory
     */
    select?: SearchHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a SearchHistory.
     */
    data: XOR<SearchHistoryCreateInput, SearchHistoryUncheckedCreateInput>
  }

  /**
   * SearchHistory createMany
   */
  export type SearchHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SearchHistories.
     */
    data: SearchHistoryCreateManyInput | SearchHistoryCreateManyInput[]
  }

  /**
   * SearchHistory createManyAndReturn
   */
  export type SearchHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchHistory
     */
    select?: SearchHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SearchHistories.
     */
    data: SearchHistoryCreateManyInput | SearchHistoryCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchHistoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SearchHistory update
   */
  export type SearchHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchHistory
     */
    select?: SearchHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a SearchHistory.
     */
    data: XOR<SearchHistoryUpdateInput, SearchHistoryUncheckedUpdateInput>
    /**
     * Choose, which SearchHistory to update.
     */
    where: SearchHistoryWhereUniqueInput
  }

  /**
   * SearchHistory updateMany
   */
  export type SearchHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SearchHistories.
     */
    data: XOR<SearchHistoryUpdateManyMutationInput, SearchHistoryUncheckedUpdateManyInput>
    /**
     * Filter which SearchHistories to update
     */
    where?: SearchHistoryWhereInput
  }

  /**
   * SearchHistory upsert
   */
  export type SearchHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchHistory
     */
    select?: SearchHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the SearchHistory to update in case it exists.
     */
    where: SearchHistoryWhereUniqueInput
    /**
     * In case the SearchHistory found by the `where` argument doesn't exist, create a new SearchHistory with this data.
     */
    create: XOR<SearchHistoryCreateInput, SearchHistoryUncheckedCreateInput>
    /**
     * In case the SearchHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SearchHistoryUpdateInput, SearchHistoryUncheckedUpdateInput>
  }

  /**
   * SearchHistory delete
   */
  export type SearchHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchHistory
     */
    select?: SearchHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchHistoryInclude<ExtArgs> | null
    /**
     * Filter which SearchHistory to delete.
     */
    where: SearchHistoryWhereUniqueInput
  }

  /**
   * SearchHistory deleteMany
   */
  export type SearchHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SearchHistories to delete
     */
    where?: SearchHistoryWhereInput
  }

  /**
   * SearchHistory without action
   */
  export type SearchHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SearchHistory
     */
    select?: SearchHistorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SearchHistoryInclude<ExtArgs> | null
  }


  /**
   * Model Booking
   */

  export type AggregateBooking = {
    _count: BookingCountAggregateOutputType | null
    _avg: BookingAvgAggregateOutputType | null
    _sum: BookingSumAggregateOutputType | null
    _min: BookingMinAggregateOutputType | null
    _max: BookingMaxAggregateOutputType | null
  }

  export type BookingAvgAggregateOutputType = {
    id: number | null
    scheduleId: number | null
    totalPrice: number | null
  }

  export type BookingSumAggregateOutputType = {
    id: number | null
    scheduleId: number | null
    totalPrice: number | null
  }

  export type BookingMinAggregateOutputType = {
    id: number | null
    userId: string | null
    scheduleId: number | null
    className: string | null
    totalPrice: number | null
    status: string | null
    createdAt: Date | null
  }

  export type BookingMaxAggregateOutputType = {
    id: number | null
    userId: string | null
    scheduleId: number | null
    className: string | null
    totalPrice: number | null
    status: string | null
    createdAt: Date | null
  }

  export type BookingCountAggregateOutputType = {
    id: number
    userId: number
    scheduleId: number
    className: number
    totalPrice: number
    status: number
    createdAt: number
    _all: number
  }


  export type BookingAvgAggregateInputType = {
    id?: true
    scheduleId?: true
    totalPrice?: true
  }

  export type BookingSumAggregateInputType = {
    id?: true
    scheduleId?: true
    totalPrice?: true
  }

  export type BookingMinAggregateInputType = {
    id?: true
    userId?: true
    scheduleId?: true
    className?: true
    totalPrice?: true
    status?: true
    createdAt?: true
  }

  export type BookingMaxAggregateInputType = {
    id?: true
    userId?: true
    scheduleId?: true
    className?: true
    totalPrice?: true
    status?: true
    createdAt?: true
  }

  export type BookingCountAggregateInputType = {
    id?: true
    userId?: true
    scheduleId?: true
    className?: true
    totalPrice?: true
    status?: true
    createdAt?: true
    _all?: true
  }

  export type BookingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Booking to aggregate.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Bookings
    **/
    _count?: true | BookingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BookingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BookingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BookingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BookingMaxAggregateInputType
  }

  export type GetBookingAggregateType<T extends BookingAggregateArgs> = {
        [P in keyof T & keyof AggregateBooking]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBooking[P]>
      : GetScalarType<T[P], AggregateBooking[P]>
  }




  export type BookingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithAggregationInput | BookingOrderByWithAggregationInput[]
    by: BookingScalarFieldEnum[] | BookingScalarFieldEnum
    having?: BookingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BookingCountAggregateInputType | true
    _avg?: BookingAvgAggregateInputType
    _sum?: BookingSumAggregateInputType
    _min?: BookingMinAggregateInputType
    _max?: BookingMaxAggregateInputType
  }

  export type BookingGroupByOutputType = {
    id: number
    userId: string
    scheduleId: number
    className: string
    totalPrice: number
    status: string
    createdAt: Date
    _count: BookingCountAggregateOutputType | null
    _avg: BookingAvgAggregateOutputType | null
    _sum: BookingSumAggregateOutputType | null
    _min: BookingMinAggregateOutputType | null
    _max: BookingMaxAggregateOutputType | null
  }

  type GetBookingGroupByPayload<T extends BookingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BookingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BookingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BookingGroupByOutputType[P]>
            : GetScalarType<T[P], BookingGroupByOutputType[P]>
        }
      >
    >


  export type BookingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    scheduleId?: boolean
    className?: boolean
    totalPrice?: boolean
    status?: boolean
    createdAt?: boolean
    schedule?: boolean | ScheduleDefaultArgs<ExtArgs>
    payment?: boolean | Booking$paymentArgs<ExtArgs>
  }, ExtArgs["result"]["booking"]>

  export type BookingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    scheduleId?: boolean
    className?: boolean
    totalPrice?: boolean
    status?: boolean
    createdAt?: boolean
    schedule?: boolean | ScheduleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["booking"]>

  export type BookingSelectScalar = {
    id?: boolean
    userId?: boolean
    scheduleId?: boolean
    className?: boolean
    totalPrice?: boolean
    status?: boolean
    createdAt?: boolean
  }

  export type BookingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    schedule?: boolean | ScheduleDefaultArgs<ExtArgs>
    payment?: boolean | Booking$paymentArgs<ExtArgs>
  }
  export type BookingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    schedule?: boolean | ScheduleDefaultArgs<ExtArgs>
  }

  export type $BookingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Booking"
    objects: {
      schedule: Prisma.$SchedulePayload<ExtArgs>
      payment: Prisma.$PaymentPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: string
      scheduleId: number
      className: string
      totalPrice: number
      status: string
      createdAt: Date
    }, ExtArgs["result"]["booking"]>
    composites: {}
  }

  type BookingGetPayload<S extends boolean | null | undefined | BookingDefaultArgs> = $Result.GetResult<Prisma.$BookingPayload, S>

  type BookingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BookingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BookingCountAggregateInputType | true
    }

  export interface BookingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Booking'], meta: { name: 'Booking' } }
    /**
     * Find zero or one Booking that matches the filter.
     * @param {BookingFindUniqueArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BookingFindUniqueArgs>(args: SelectSubset<T, BookingFindUniqueArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Booking that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BookingFindUniqueOrThrowArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BookingFindUniqueOrThrowArgs>(args: SelectSubset<T, BookingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Booking that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingFindFirstArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BookingFindFirstArgs>(args?: SelectSubset<T, BookingFindFirstArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Booking that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingFindFirstOrThrowArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BookingFindFirstOrThrowArgs>(args?: SelectSubset<T, BookingFindFirstOrThrowArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Bookings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bookings
     * const bookings = await prisma.booking.findMany()
     * 
     * // Get first 10 Bookings
     * const bookings = await prisma.booking.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bookingWithIdOnly = await prisma.booking.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BookingFindManyArgs>(args?: SelectSubset<T, BookingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Booking.
     * @param {BookingCreateArgs} args - Arguments to create a Booking.
     * @example
     * // Create one Booking
     * const Booking = await prisma.booking.create({
     *   data: {
     *     // ... data to create a Booking
     *   }
     * })
     * 
     */
    create<T extends BookingCreateArgs>(args: SelectSubset<T, BookingCreateArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Bookings.
     * @param {BookingCreateManyArgs} args - Arguments to create many Bookings.
     * @example
     * // Create many Bookings
     * const booking = await prisma.booking.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BookingCreateManyArgs>(args?: SelectSubset<T, BookingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Bookings and returns the data saved in the database.
     * @param {BookingCreateManyAndReturnArgs} args - Arguments to create many Bookings.
     * @example
     * // Create many Bookings
     * const booking = await prisma.booking.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Bookings and only return the `id`
     * const bookingWithIdOnly = await prisma.booking.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BookingCreateManyAndReturnArgs>(args?: SelectSubset<T, BookingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Booking.
     * @param {BookingDeleteArgs} args - Arguments to delete one Booking.
     * @example
     * // Delete one Booking
     * const Booking = await prisma.booking.delete({
     *   where: {
     *     // ... filter to delete one Booking
     *   }
     * })
     * 
     */
    delete<T extends BookingDeleteArgs>(args: SelectSubset<T, BookingDeleteArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Booking.
     * @param {BookingUpdateArgs} args - Arguments to update one Booking.
     * @example
     * // Update one Booking
     * const booking = await prisma.booking.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BookingUpdateArgs>(args: SelectSubset<T, BookingUpdateArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Bookings.
     * @param {BookingDeleteManyArgs} args - Arguments to filter Bookings to delete.
     * @example
     * // Delete a few Bookings
     * const { count } = await prisma.booking.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BookingDeleteManyArgs>(args?: SelectSubset<T, BookingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bookings
     * const booking = await prisma.booking.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BookingUpdateManyArgs>(args: SelectSubset<T, BookingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Booking.
     * @param {BookingUpsertArgs} args - Arguments to update or create a Booking.
     * @example
     * // Update or create a Booking
     * const booking = await prisma.booking.upsert({
     *   create: {
     *     // ... data to create a Booking
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Booking we want to update
     *   }
     * })
     */
    upsert<T extends BookingUpsertArgs>(args: SelectSubset<T, BookingUpsertArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Bookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingCountArgs} args - Arguments to filter Bookings to count.
     * @example
     * // Count the number of Bookings
     * const count = await prisma.booking.count({
     *   where: {
     *     // ... the filter for the Bookings we want to count
     *   }
     * })
    **/
    count<T extends BookingCountArgs>(
      args?: Subset<T, BookingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BookingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Booking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BookingAggregateArgs>(args: Subset<T, BookingAggregateArgs>): Prisma.PrismaPromise<GetBookingAggregateType<T>>

    /**
     * Group by Booking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BookingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BookingGroupByArgs['orderBy'] }
        : { orderBy?: BookingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BookingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBookingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Booking model
   */
  readonly fields: BookingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Booking.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BookingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    schedule<T extends ScheduleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ScheduleDefaultArgs<ExtArgs>>): Prisma__ScheduleClient<$Result.GetResult<Prisma.$SchedulePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    payment<T extends Booking$paymentArgs<ExtArgs> = {}>(args?: Subset<T, Booking$paymentArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Booking model
   */ 
  interface BookingFieldRefs {
    readonly id: FieldRef<"Booking", 'Int'>
    readonly userId: FieldRef<"Booking", 'String'>
    readonly scheduleId: FieldRef<"Booking", 'Int'>
    readonly className: FieldRef<"Booking", 'String'>
    readonly totalPrice: FieldRef<"Booking", 'Int'>
    readonly status: FieldRef<"Booking", 'String'>
    readonly createdAt: FieldRef<"Booking", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Booking findUnique
   */
  export type BookingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking findUniqueOrThrow
   */
  export type BookingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking findFirst
   */
  export type BookingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bookings.
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bookings.
     */
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Booking findFirstOrThrow
   */
  export type BookingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bookings.
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bookings.
     */
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Booking findMany
   */
  export type BookingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Bookings to fetch.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Bookings.
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Booking create
   */
  export type BookingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * The data needed to create a Booking.
     */
    data: XOR<BookingCreateInput, BookingUncheckedCreateInput>
  }

  /**
   * Booking createMany
   */
  export type BookingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Bookings.
     */
    data: BookingCreateManyInput | BookingCreateManyInput[]
  }

  /**
   * Booking createManyAndReturn
   */
  export type BookingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Bookings.
     */
    data: BookingCreateManyInput | BookingCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Booking update
   */
  export type BookingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * The data needed to update a Booking.
     */
    data: XOR<BookingUpdateInput, BookingUncheckedUpdateInput>
    /**
     * Choose, which Booking to update.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking updateMany
   */
  export type BookingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Bookings.
     */
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyInput>
    /**
     * Filter which Bookings to update
     */
    where?: BookingWhereInput
  }

  /**
   * Booking upsert
   */
  export type BookingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * The filter to search for the Booking to update in case it exists.
     */
    where: BookingWhereUniqueInput
    /**
     * In case the Booking found by the `where` argument doesn't exist, create a new Booking with this data.
     */
    create: XOR<BookingCreateInput, BookingUncheckedCreateInput>
    /**
     * In case the Booking was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BookingUpdateInput, BookingUncheckedUpdateInput>
  }

  /**
   * Booking delete
   */
  export type BookingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter which Booking to delete.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking deleteMany
   */
  export type BookingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bookings to delete
     */
    where?: BookingWhereInput
  }

  /**
   * Booking.payment
   */
  export type Booking$paymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
  }

  /**
   * Booking without action
   */
  export type BookingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
  }


  /**
   * Model Payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    id: number | null
    bookingId: number | null
    paidAmount: number | null
  }

  export type PaymentSumAggregateOutputType = {
    id: number | null
    bookingId: number | null
    paidAmount: number | null
  }

  export type PaymentMinAggregateOutputType = {
    id: number | null
    bookingId: number | null
    method: string | null
    paidAmount: number | null
    paidAt: Date | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: number | null
    bookingId: number | null
    method: string | null
    paidAmount: number | null
    paidAt: Date | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    bookingId: number
    method: number
    paidAmount: number
    paidAt: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    id?: true
    bookingId?: true
    paidAmount?: true
  }

  export type PaymentSumAggregateInputType = {
    id?: true
    bookingId?: true
    paidAmount?: true
  }

  export type PaymentMinAggregateInputType = {
    id?: true
    bookingId?: true
    method?: true
    paidAmount?: true
    paidAt?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    bookingId?: true
    method?: true
    paidAmount?: true
    paidAt?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    bookingId?: true
    method?: true
    paidAmount?: true
    paidAt?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payment to aggregate.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithAggregationInput | PaymentOrderByWithAggregationInput[]
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum
    having?: PaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }

  export type PaymentGroupByOutputType = {
    id: number
    bookingId: number
    method: string
    paidAmount: number
    paidAt: Date
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type PaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    method?: boolean
    paidAmount?: boolean
    paidAt?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    method?: boolean
    paidAmount?: boolean
    paidAt?: boolean
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectScalar = {
    id?: boolean
    bookingId?: boolean
    method?: boolean
    paidAmount?: boolean
    paidAt?: boolean
  }

  export type PaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }
  export type PaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    booking?: boolean | BookingDefaultArgs<ExtArgs>
  }

  export type $PaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payment"
    objects: {
      booking: Prisma.$BookingPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      bookingId: number
      method: string
      paidAmount: number
      paidAt: Date
    }, ExtArgs["result"]["payment"]>
    composites: {}
  }

  type PaymentGetPayload<S extends boolean | null | undefined | PaymentDefaultArgs> = $Result.GetResult<Prisma.$PaymentPayload, S>

  type PaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PaymentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface PaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payment'], meta: { name: 'Payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentFindUniqueArgs>(args: SelectSubset<T, PaymentFindUniqueArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Payment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentFindFirstArgs>(args?: SelectSubset<T, PaymentFindFirstArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentFindManyArgs>(args?: SelectSubset<T, PaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
     */
    create<T extends PaymentCreateArgs>(args: SelectSubset<T, PaymentCreateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Payments.
     * @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentCreateManyArgs>(args?: SelectSubset<T, PaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payments and returns the data saved in the database.
     * @param {PaymentCreateManyAndReturnArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
     */
    delete<T extends PaymentDeleteArgs>(args: SelectSubset<T, PaymentDeleteArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentUpdateArgs>(args: SelectSubset<T, PaymentUpdateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentDeleteManyArgs>(args?: SelectSubset<T, PaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentUpdateManyArgs>(args: SelectSubset<T, PaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
     */
    upsert<T extends PaymentUpsertArgs>(args: SelectSubset<T, PaymentUpsertArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payment model
   */
  readonly fields: PaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    booking<T extends BookingDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BookingDefaultArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payment model
   */ 
  interface PaymentFieldRefs {
    readonly id: FieldRef<"Payment", 'Int'>
    readonly bookingId: FieldRef<"Payment", 'Int'>
    readonly method: FieldRef<"Payment", 'String'>
    readonly paidAmount: FieldRef<"Payment", 'Int'>
    readonly paidAt: FieldRef<"Payment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Payment findUnique
   */
  export type PaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findFirst
   */
  export type PaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment create
   */
  export type PaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a Payment.
     */
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
  }

  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
  }

  /**
   * Payment createManyAndReturn
   */
  export type PaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment update
   */
  export type PaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a Payment.
     */
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
    /**
     * Choose, which Payment to update.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
  }

  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the Payment to update in case it exists.
     */
    where: PaymentWhereUniqueInput
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     */
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
  }

  /**
   * Payment delete
   */
  export type PaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter which Payment to delete.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentWhereInput
  }

  /**
   * Payment without action
   */
  export type PaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const StationScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    city: 'city',
    stationType: 'stationType'
  };

  export type StationScalarFieldEnum = (typeof StationScalarFieldEnum)[keyof typeof StationScalarFieldEnum]


  export const TrainScalarFieldEnum: {
    id: 'id',
    name: 'name',
    trainType: 'trainType'
  };

  export type TrainScalarFieldEnum = (typeof TrainScalarFieldEnum)[keyof typeof TrainScalarFieldEnum]


  export const TrainClassScalarFieldEnum: {
    id: 'id',
    className: 'className',
    price: 'price',
    trainId: 'trainId'
  };

  export type TrainClassScalarFieldEnum = (typeof TrainClassScalarFieldEnum)[keyof typeof TrainClassScalarFieldEnum]


  export const RouteStopScalarFieldEnum: {
    id: 'id',
    stopOrder: 'stopOrder',
    trainId: 'trainId',
    stationId: 'stationId',
    arrivalTime: 'arrivalTime',
    departureTime: 'departureTime'
  };

  export type RouteStopScalarFieldEnum = (typeof RouteStopScalarFieldEnum)[keyof typeof RouteStopScalarFieldEnum]


  export const ScheduleScalarFieldEnum: {
    id: 'id',
    departureTime: 'departureTime',
    arrivalTime: 'arrivalTime',
    trainId: 'trainId',
    departureStationId: 'departureStationId',
    arrivalStationId: 'arrivalStationId'
  };

  export type ScheduleScalarFieldEnum = (typeof ScheduleScalarFieldEnum)[keyof typeof ScheduleScalarFieldEnum]


  export const FavoriteRouteScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    originStationId: 'originStationId',
    destinationStationId: 'destinationStationId'
  };

  export type FavoriteRouteScalarFieldEnum = (typeof FavoriteRouteScalarFieldEnum)[keyof typeof FavoriteRouteScalarFieldEnum]


  export const SearchHistoryScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    searchDate: 'searchDate',
    originStationId: 'originStationId',
    destinationStationId: 'destinationStationId'
  };

  export type SearchHistoryScalarFieldEnum = (typeof SearchHistoryScalarFieldEnum)[keyof typeof SearchHistoryScalarFieldEnum]


  export const BookingScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    scheduleId: 'scheduleId',
    className: 'className',
    totalPrice: 'totalPrice',
    status: 'status',
    createdAt: 'createdAt'
  };

  export type BookingScalarFieldEnum = (typeof BookingScalarFieldEnum)[keyof typeof BookingScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    bookingId: 'bookingId',
    method: 'method',
    paidAmount: 'paidAmount',
    paidAt: 'paidAt'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type StationWhereInput = {
    AND?: StationWhereInput | StationWhereInput[]
    OR?: StationWhereInput[]
    NOT?: StationWhereInput | StationWhereInput[]
    id?: IntFilter<"Station"> | number
    code?: StringFilter<"Station"> | string
    name?: StringFilter<"Station"> | string
    city?: StringFilter<"Station"> | string
    stationType?: StringFilter<"Station"> | string
    routes?: RouteStopListRelationFilter
    departureSchedules?: ScheduleListRelationFilter
    arrivalSchedules?: ScheduleListRelationFilter
    favoriteOriginRoutes?: FavoriteRouteListRelationFilter
    favoriteDestinationRoutes?: FavoriteRouteListRelationFilter
    historyOriginRoutes?: SearchHistoryListRelationFilter
    historyDestinationRoutes?: SearchHistoryListRelationFilter
  }

  export type StationOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    city?: SortOrder
    stationType?: SortOrder
    routes?: RouteStopOrderByRelationAggregateInput
    departureSchedules?: ScheduleOrderByRelationAggregateInput
    arrivalSchedules?: ScheduleOrderByRelationAggregateInput
    favoriteOriginRoutes?: FavoriteRouteOrderByRelationAggregateInput
    favoriteDestinationRoutes?: FavoriteRouteOrderByRelationAggregateInput
    historyOriginRoutes?: SearchHistoryOrderByRelationAggregateInput
    historyDestinationRoutes?: SearchHistoryOrderByRelationAggregateInput
  }

  export type StationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    code?: string
    AND?: StationWhereInput | StationWhereInput[]
    OR?: StationWhereInput[]
    NOT?: StationWhereInput | StationWhereInput[]
    name?: StringFilter<"Station"> | string
    city?: StringFilter<"Station"> | string
    stationType?: StringFilter<"Station"> | string
    routes?: RouteStopListRelationFilter
    departureSchedules?: ScheduleListRelationFilter
    arrivalSchedules?: ScheduleListRelationFilter
    favoriteOriginRoutes?: FavoriteRouteListRelationFilter
    favoriteDestinationRoutes?: FavoriteRouteListRelationFilter
    historyOriginRoutes?: SearchHistoryListRelationFilter
    historyDestinationRoutes?: SearchHistoryListRelationFilter
  }, "id" | "code">

  export type StationOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    city?: SortOrder
    stationType?: SortOrder
    _count?: StationCountOrderByAggregateInput
    _avg?: StationAvgOrderByAggregateInput
    _max?: StationMaxOrderByAggregateInput
    _min?: StationMinOrderByAggregateInput
    _sum?: StationSumOrderByAggregateInput
  }

  export type StationScalarWhereWithAggregatesInput = {
    AND?: StationScalarWhereWithAggregatesInput | StationScalarWhereWithAggregatesInput[]
    OR?: StationScalarWhereWithAggregatesInput[]
    NOT?: StationScalarWhereWithAggregatesInput | StationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Station"> | number
    code?: StringWithAggregatesFilter<"Station"> | string
    name?: StringWithAggregatesFilter<"Station"> | string
    city?: StringWithAggregatesFilter<"Station"> | string
    stationType?: StringWithAggregatesFilter<"Station"> | string
  }

  export type TrainWhereInput = {
    AND?: TrainWhereInput | TrainWhereInput[]
    OR?: TrainWhereInput[]
    NOT?: TrainWhereInput | TrainWhereInput[]
    id?: IntFilter<"Train"> | number
    name?: StringFilter<"Train"> | string
    trainType?: StringFilter<"Train"> | string
    classes?: TrainClassListRelationFilter
    routeStops?: RouteStopListRelationFilter
    schedules?: ScheduleListRelationFilter
  }

  export type TrainOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    trainType?: SortOrder
    classes?: TrainClassOrderByRelationAggregateInput
    routeStops?: RouteStopOrderByRelationAggregateInput
    schedules?: ScheduleOrderByRelationAggregateInput
  }

  export type TrainWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TrainWhereInput | TrainWhereInput[]
    OR?: TrainWhereInput[]
    NOT?: TrainWhereInput | TrainWhereInput[]
    name?: StringFilter<"Train"> | string
    trainType?: StringFilter<"Train"> | string
    classes?: TrainClassListRelationFilter
    routeStops?: RouteStopListRelationFilter
    schedules?: ScheduleListRelationFilter
  }, "id">

  export type TrainOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    trainType?: SortOrder
    _count?: TrainCountOrderByAggregateInput
    _avg?: TrainAvgOrderByAggregateInput
    _max?: TrainMaxOrderByAggregateInput
    _min?: TrainMinOrderByAggregateInput
    _sum?: TrainSumOrderByAggregateInput
  }

  export type TrainScalarWhereWithAggregatesInput = {
    AND?: TrainScalarWhereWithAggregatesInput | TrainScalarWhereWithAggregatesInput[]
    OR?: TrainScalarWhereWithAggregatesInput[]
    NOT?: TrainScalarWhereWithAggregatesInput | TrainScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Train"> | number
    name?: StringWithAggregatesFilter<"Train"> | string
    trainType?: StringWithAggregatesFilter<"Train"> | string
  }

  export type TrainClassWhereInput = {
    AND?: TrainClassWhereInput | TrainClassWhereInput[]
    OR?: TrainClassWhereInput[]
    NOT?: TrainClassWhereInput | TrainClassWhereInput[]
    id?: IntFilter<"TrainClass"> | number
    className?: StringFilter<"TrainClass"> | string
    price?: IntFilter<"TrainClass"> | number
    trainId?: IntFilter<"TrainClass"> | number
    train?: XOR<TrainRelationFilter, TrainWhereInput>
  }

  export type TrainClassOrderByWithRelationInput = {
    id?: SortOrder
    className?: SortOrder
    price?: SortOrder
    trainId?: SortOrder
    train?: TrainOrderByWithRelationInput
  }

  export type TrainClassWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TrainClassWhereInput | TrainClassWhereInput[]
    OR?: TrainClassWhereInput[]
    NOT?: TrainClassWhereInput | TrainClassWhereInput[]
    className?: StringFilter<"TrainClass"> | string
    price?: IntFilter<"TrainClass"> | number
    trainId?: IntFilter<"TrainClass"> | number
    train?: XOR<TrainRelationFilter, TrainWhereInput>
  }, "id">

  export type TrainClassOrderByWithAggregationInput = {
    id?: SortOrder
    className?: SortOrder
    price?: SortOrder
    trainId?: SortOrder
    _count?: TrainClassCountOrderByAggregateInput
    _avg?: TrainClassAvgOrderByAggregateInput
    _max?: TrainClassMaxOrderByAggregateInput
    _min?: TrainClassMinOrderByAggregateInput
    _sum?: TrainClassSumOrderByAggregateInput
  }

  export type TrainClassScalarWhereWithAggregatesInput = {
    AND?: TrainClassScalarWhereWithAggregatesInput | TrainClassScalarWhereWithAggregatesInput[]
    OR?: TrainClassScalarWhereWithAggregatesInput[]
    NOT?: TrainClassScalarWhereWithAggregatesInput | TrainClassScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"TrainClass"> | number
    className?: StringWithAggregatesFilter<"TrainClass"> | string
    price?: IntWithAggregatesFilter<"TrainClass"> | number
    trainId?: IntWithAggregatesFilter<"TrainClass"> | number
  }

  export type RouteStopWhereInput = {
    AND?: RouteStopWhereInput | RouteStopWhereInput[]
    OR?: RouteStopWhereInput[]
    NOT?: RouteStopWhereInput | RouteStopWhereInput[]
    id?: IntFilter<"RouteStop"> | number
    stopOrder?: IntFilter<"RouteStop"> | number
    trainId?: IntFilter<"RouteStop"> | number
    stationId?: IntFilter<"RouteStop"> | number
    arrivalTime?: DateTimeNullableFilter<"RouteStop"> | Date | string | null
    departureTime?: DateTimeNullableFilter<"RouteStop"> | Date | string | null
    train?: XOR<TrainRelationFilter, TrainWhereInput>
    station?: XOR<StationRelationFilter, StationWhereInput>
  }

  export type RouteStopOrderByWithRelationInput = {
    id?: SortOrder
    stopOrder?: SortOrder
    trainId?: SortOrder
    stationId?: SortOrder
    arrivalTime?: SortOrderInput | SortOrder
    departureTime?: SortOrderInput | SortOrder
    train?: TrainOrderByWithRelationInput
    station?: StationOrderByWithRelationInput
  }

  export type RouteStopWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RouteStopWhereInput | RouteStopWhereInput[]
    OR?: RouteStopWhereInput[]
    NOT?: RouteStopWhereInput | RouteStopWhereInput[]
    stopOrder?: IntFilter<"RouteStop"> | number
    trainId?: IntFilter<"RouteStop"> | number
    stationId?: IntFilter<"RouteStop"> | number
    arrivalTime?: DateTimeNullableFilter<"RouteStop"> | Date | string | null
    departureTime?: DateTimeNullableFilter<"RouteStop"> | Date | string | null
    train?: XOR<TrainRelationFilter, TrainWhereInput>
    station?: XOR<StationRelationFilter, StationWhereInput>
  }, "id">

  export type RouteStopOrderByWithAggregationInput = {
    id?: SortOrder
    stopOrder?: SortOrder
    trainId?: SortOrder
    stationId?: SortOrder
    arrivalTime?: SortOrderInput | SortOrder
    departureTime?: SortOrderInput | SortOrder
    _count?: RouteStopCountOrderByAggregateInput
    _avg?: RouteStopAvgOrderByAggregateInput
    _max?: RouteStopMaxOrderByAggregateInput
    _min?: RouteStopMinOrderByAggregateInput
    _sum?: RouteStopSumOrderByAggregateInput
  }

  export type RouteStopScalarWhereWithAggregatesInput = {
    AND?: RouteStopScalarWhereWithAggregatesInput | RouteStopScalarWhereWithAggregatesInput[]
    OR?: RouteStopScalarWhereWithAggregatesInput[]
    NOT?: RouteStopScalarWhereWithAggregatesInput | RouteStopScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"RouteStop"> | number
    stopOrder?: IntWithAggregatesFilter<"RouteStop"> | number
    trainId?: IntWithAggregatesFilter<"RouteStop"> | number
    stationId?: IntWithAggregatesFilter<"RouteStop"> | number
    arrivalTime?: DateTimeNullableWithAggregatesFilter<"RouteStop"> | Date | string | null
    departureTime?: DateTimeNullableWithAggregatesFilter<"RouteStop"> | Date | string | null
  }

  export type ScheduleWhereInput = {
    AND?: ScheduleWhereInput | ScheduleWhereInput[]
    OR?: ScheduleWhereInput[]
    NOT?: ScheduleWhereInput | ScheduleWhereInput[]
    id?: IntFilter<"Schedule"> | number
    departureTime?: DateTimeFilter<"Schedule"> | Date | string
    arrivalTime?: DateTimeFilter<"Schedule"> | Date | string
    trainId?: IntFilter<"Schedule"> | number
    departureStationId?: IntFilter<"Schedule"> | number
    arrivalStationId?: IntFilter<"Schedule"> | number
    train?: XOR<TrainRelationFilter, TrainWhereInput>
    departureStation?: XOR<StationRelationFilter, StationWhereInput>
    arrivalStation?: XOR<StationRelationFilter, StationWhereInput>
    bookings?: BookingListRelationFilter
  }

  export type ScheduleOrderByWithRelationInput = {
    id?: SortOrder
    departureTime?: SortOrder
    arrivalTime?: SortOrder
    trainId?: SortOrder
    departureStationId?: SortOrder
    arrivalStationId?: SortOrder
    train?: TrainOrderByWithRelationInput
    departureStation?: StationOrderByWithRelationInput
    arrivalStation?: StationOrderByWithRelationInput
    bookings?: BookingOrderByRelationAggregateInput
  }

  export type ScheduleWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ScheduleWhereInput | ScheduleWhereInput[]
    OR?: ScheduleWhereInput[]
    NOT?: ScheduleWhereInput | ScheduleWhereInput[]
    departureTime?: DateTimeFilter<"Schedule"> | Date | string
    arrivalTime?: DateTimeFilter<"Schedule"> | Date | string
    trainId?: IntFilter<"Schedule"> | number
    departureStationId?: IntFilter<"Schedule"> | number
    arrivalStationId?: IntFilter<"Schedule"> | number
    train?: XOR<TrainRelationFilter, TrainWhereInput>
    departureStation?: XOR<StationRelationFilter, StationWhereInput>
    arrivalStation?: XOR<StationRelationFilter, StationWhereInput>
    bookings?: BookingListRelationFilter
  }, "id">

  export type ScheduleOrderByWithAggregationInput = {
    id?: SortOrder
    departureTime?: SortOrder
    arrivalTime?: SortOrder
    trainId?: SortOrder
    departureStationId?: SortOrder
    arrivalStationId?: SortOrder
    _count?: ScheduleCountOrderByAggregateInput
    _avg?: ScheduleAvgOrderByAggregateInput
    _max?: ScheduleMaxOrderByAggregateInput
    _min?: ScheduleMinOrderByAggregateInput
    _sum?: ScheduleSumOrderByAggregateInput
  }

  export type ScheduleScalarWhereWithAggregatesInput = {
    AND?: ScheduleScalarWhereWithAggregatesInput | ScheduleScalarWhereWithAggregatesInput[]
    OR?: ScheduleScalarWhereWithAggregatesInput[]
    NOT?: ScheduleScalarWhereWithAggregatesInput | ScheduleScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Schedule"> | number
    departureTime?: DateTimeWithAggregatesFilter<"Schedule"> | Date | string
    arrivalTime?: DateTimeWithAggregatesFilter<"Schedule"> | Date | string
    trainId?: IntWithAggregatesFilter<"Schedule"> | number
    departureStationId?: IntWithAggregatesFilter<"Schedule"> | number
    arrivalStationId?: IntWithAggregatesFilter<"Schedule"> | number
  }

  export type FavoriteRouteWhereInput = {
    AND?: FavoriteRouteWhereInput | FavoriteRouteWhereInput[]
    OR?: FavoriteRouteWhereInput[]
    NOT?: FavoriteRouteWhereInput | FavoriteRouteWhereInput[]
    id?: IntFilter<"FavoriteRoute"> | number
    userId?: StringFilter<"FavoriteRoute"> | string
    originStationId?: IntFilter<"FavoriteRoute"> | number
    destinationStationId?: IntFilter<"FavoriteRoute"> | number
    origin?: XOR<StationRelationFilter, StationWhereInput>
    destination?: XOR<StationRelationFilter, StationWhereInput>
  }

  export type FavoriteRouteOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    originStationId?: SortOrder
    destinationStationId?: SortOrder
    origin?: StationOrderByWithRelationInput
    destination?: StationOrderByWithRelationInput
  }

  export type FavoriteRouteWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: FavoriteRouteWhereInput | FavoriteRouteWhereInput[]
    OR?: FavoriteRouteWhereInput[]
    NOT?: FavoriteRouteWhereInput | FavoriteRouteWhereInput[]
    userId?: StringFilter<"FavoriteRoute"> | string
    originStationId?: IntFilter<"FavoriteRoute"> | number
    destinationStationId?: IntFilter<"FavoriteRoute"> | number
    origin?: XOR<StationRelationFilter, StationWhereInput>
    destination?: XOR<StationRelationFilter, StationWhereInput>
  }, "id">

  export type FavoriteRouteOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    originStationId?: SortOrder
    destinationStationId?: SortOrder
    _count?: FavoriteRouteCountOrderByAggregateInput
    _avg?: FavoriteRouteAvgOrderByAggregateInput
    _max?: FavoriteRouteMaxOrderByAggregateInput
    _min?: FavoriteRouteMinOrderByAggregateInput
    _sum?: FavoriteRouteSumOrderByAggregateInput
  }

  export type FavoriteRouteScalarWhereWithAggregatesInput = {
    AND?: FavoriteRouteScalarWhereWithAggregatesInput | FavoriteRouteScalarWhereWithAggregatesInput[]
    OR?: FavoriteRouteScalarWhereWithAggregatesInput[]
    NOT?: FavoriteRouteScalarWhereWithAggregatesInput | FavoriteRouteScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"FavoriteRoute"> | number
    userId?: StringWithAggregatesFilter<"FavoriteRoute"> | string
    originStationId?: IntWithAggregatesFilter<"FavoriteRoute"> | number
    destinationStationId?: IntWithAggregatesFilter<"FavoriteRoute"> | number
  }

  export type SearchHistoryWhereInput = {
    AND?: SearchHistoryWhereInput | SearchHistoryWhereInput[]
    OR?: SearchHistoryWhereInput[]
    NOT?: SearchHistoryWhereInput | SearchHistoryWhereInput[]
    id?: IntFilter<"SearchHistory"> | number
    userId?: StringFilter<"SearchHistory"> | string
    searchDate?: DateTimeFilter<"SearchHistory"> | Date | string
    originStationId?: IntFilter<"SearchHistory"> | number
    destinationStationId?: IntFilter<"SearchHistory"> | number
    origin?: XOR<StationRelationFilter, StationWhereInput>
    destination?: XOR<StationRelationFilter, StationWhereInput>
  }

  export type SearchHistoryOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    searchDate?: SortOrder
    originStationId?: SortOrder
    destinationStationId?: SortOrder
    origin?: StationOrderByWithRelationInput
    destination?: StationOrderByWithRelationInput
  }

  export type SearchHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: SearchHistoryWhereInput | SearchHistoryWhereInput[]
    OR?: SearchHistoryWhereInput[]
    NOT?: SearchHistoryWhereInput | SearchHistoryWhereInput[]
    userId?: StringFilter<"SearchHistory"> | string
    searchDate?: DateTimeFilter<"SearchHistory"> | Date | string
    originStationId?: IntFilter<"SearchHistory"> | number
    destinationStationId?: IntFilter<"SearchHistory"> | number
    origin?: XOR<StationRelationFilter, StationWhereInput>
    destination?: XOR<StationRelationFilter, StationWhereInput>
  }, "id">

  export type SearchHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    searchDate?: SortOrder
    originStationId?: SortOrder
    destinationStationId?: SortOrder
    _count?: SearchHistoryCountOrderByAggregateInput
    _avg?: SearchHistoryAvgOrderByAggregateInput
    _max?: SearchHistoryMaxOrderByAggregateInput
    _min?: SearchHistoryMinOrderByAggregateInput
    _sum?: SearchHistorySumOrderByAggregateInput
  }

  export type SearchHistoryScalarWhereWithAggregatesInput = {
    AND?: SearchHistoryScalarWhereWithAggregatesInput | SearchHistoryScalarWhereWithAggregatesInput[]
    OR?: SearchHistoryScalarWhereWithAggregatesInput[]
    NOT?: SearchHistoryScalarWhereWithAggregatesInput | SearchHistoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"SearchHistory"> | number
    userId?: StringWithAggregatesFilter<"SearchHistory"> | string
    searchDate?: DateTimeWithAggregatesFilter<"SearchHistory"> | Date | string
    originStationId?: IntWithAggregatesFilter<"SearchHistory"> | number
    destinationStationId?: IntWithAggregatesFilter<"SearchHistory"> | number
  }

  export type BookingWhereInput = {
    AND?: BookingWhereInput | BookingWhereInput[]
    OR?: BookingWhereInput[]
    NOT?: BookingWhereInput | BookingWhereInput[]
    id?: IntFilter<"Booking"> | number
    userId?: StringFilter<"Booking"> | string
    scheduleId?: IntFilter<"Booking"> | number
    className?: StringFilter<"Booking"> | string
    totalPrice?: IntFilter<"Booking"> | number
    status?: StringFilter<"Booking"> | string
    createdAt?: DateTimeFilter<"Booking"> | Date | string
    schedule?: XOR<ScheduleRelationFilter, ScheduleWhereInput>
    payment?: XOR<PaymentNullableRelationFilter, PaymentWhereInput> | null
  }

  export type BookingOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    scheduleId?: SortOrder
    className?: SortOrder
    totalPrice?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    schedule?: ScheduleOrderByWithRelationInput
    payment?: PaymentOrderByWithRelationInput
  }

  export type BookingWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: BookingWhereInput | BookingWhereInput[]
    OR?: BookingWhereInput[]
    NOT?: BookingWhereInput | BookingWhereInput[]
    userId?: StringFilter<"Booking"> | string
    scheduleId?: IntFilter<"Booking"> | number
    className?: StringFilter<"Booking"> | string
    totalPrice?: IntFilter<"Booking"> | number
    status?: StringFilter<"Booking"> | string
    createdAt?: DateTimeFilter<"Booking"> | Date | string
    schedule?: XOR<ScheduleRelationFilter, ScheduleWhereInput>
    payment?: XOR<PaymentNullableRelationFilter, PaymentWhereInput> | null
  }, "id">

  export type BookingOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    scheduleId?: SortOrder
    className?: SortOrder
    totalPrice?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    _count?: BookingCountOrderByAggregateInput
    _avg?: BookingAvgOrderByAggregateInput
    _max?: BookingMaxOrderByAggregateInput
    _min?: BookingMinOrderByAggregateInput
    _sum?: BookingSumOrderByAggregateInput
  }

  export type BookingScalarWhereWithAggregatesInput = {
    AND?: BookingScalarWhereWithAggregatesInput | BookingScalarWhereWithAggregatesInput[]
    OR?: BookingScalarWhereWithAggregatesInput[]
    NOT?: BookingScalarWhereWithAggregatesInput | BookingScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Booking"> | number
    userId?: StringWithAggregatesFilter<"Booking"> | string
    scheduleId?: IntWithAggregatesFilter<"Booking"> | number
    className?: StringWithAggregatesFilter<"Booking"> | string
    totalPrice?: IntWithAggregatesFilter<"Booking"> | number
    status?: StringWithAggregatesFilter<"Booking"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Booking"> | Date | string
  }

  export type PaymentWhereInput = {
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    id?: IntFilter<"Payment"> | number
    bookingId?: IntFilter<"Payment"> | number
    method?: StringFilter<"Payment"> | string
    paidAmount?: IntFilter<"Payment"> | number
    paidAt?: DateTimeFilter<"Payment"> | Date | string
    booking?: XOR<BookingRelationFilter, BookingWhereInput>
  }

  export type PaymentOrderByWithRelationInput = {
    id?: SortOrder
    bookingId?: SortOrder
    method?: SortOrder
    paidAmount?: SortOrder
    paidAt?: SortOrder
    booking?: BookingOrderByWithRelationInput
  }

  export type PaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    bookingId?: number
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    method?: StringFilter<"Payment"> | string
    paidAmount?: IntFilter<"Payment"> | number
    paidAt?: DateTimeFilter<"Payment"> | Date | string
    booking?: XOR<BookingRelationFilter, BookingWhereInput>
  }, "id" | "bookingId">

  export type PaymentOrderByWithAggregationInput = {
    id?: SortOrder
    bookingId?: SortOrder
    method?: SortOrder
    paidAmount?: SortOrder
    paidAt?: SortOrder
    _count?: PaymentCountOrderByAggregateInput
    _avg?: PaymentAvgOrderByAggregateInput
    _max?: PaymentMaxOrderByAggregateInput
    _min?: PaymentMinOrderByAggregateInput
    _sum?: PaymentSumOrderByAggregateInput
  }

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    OR?: PaymentScalarWhereWithAggregatesInput[]
    NOT?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Payment"> | number
    bookingId?: IntWithAggregatesFilter<"Payment"> | number
    method?: StringWithAggregatesFilter<"Payment"> | string
    paidAmount?: IntWithAggregatesFilter<"Payment"> | number
    paidAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
  }

  export type StationCreateInput = {
    code: string
    name: string
    city: string
    stationType: string
    routes?: RouteStopCreateNestedManyWithoutStationInput
    departureSchedules?: ScheduleCreateNestedManyWithoutDepartureStationInput
    arrivalSchedules?: ScheduleCreateNestedManyWithoutArrivalStationInput
    favoriteOriginRoutes?: FavoriteRouteCreateNestedManyWithoutOriginInput
    favoriteDestinationRoutes?: FavoriteRouteCreateNestedManyWithoutDestinationInput
    historyOriginRoutes?: SearchHistoryCreateNestedManyWithoutOriginInput
    historyDestinationRoutes?: SearchHistoryCreateNestedManyWithoutDestinationInput
  }

  export type StationUncheckedCreateInput = {
    id?: number
    code: string
    name: string
    city: string
    stationType: string
    routes?: RouteStopUncheckedCreateNestedManyWithoutStationInput
    departureSchedules?: ScheduleUncheckedCreateNestedManyWithoutDepartureStationInput
    arrivalSchedules?: ScheduleUncheckedCreateNestedManyWithoutArrivalStationInput
    favoriteOriginRoutes?: FavoriteRouteUncheckedCreateNestedManyWithoutOriginInput
    favoriteDestinationRoutes?: FavoriteRouteUncheckedCreateNestedManyWithoutDestinationInput
    historyOriginRoutes?: SearchHistoryUncheckedCreateNestedManyWithoutOriginInput
    historyDestinationRoutes?: SearchHistoryUncheckedCreateNestedManyWithoutDestinationInput
  }

  export type StationUpdateInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    stationType?: StringFieldUpdateOperationsInput | string
    routes?: RouteStopUpdateManyWithoutStationNestedInput
    departureSchedules?: ScheduleUpdateManyWithoutDepartureStationNestedInput
    arrivalSchedules?: ScheduleUpdateManyWithoutArrivalStationNestedInput
    favoriteOriginRoutes?: FavoriteRouteUpdateManyWithoutOriginNestedInput
    favoriteDestinationRoutes?: FavoriteRouteUpdateManyWithoutDestinationNestedInput
    historyOriginRoutes?: SearchHistoryUpdateManyWithoutOriginNestedInput
    historyDestinationRoutes?: SearchHistoryUpdateManyWithoutDestinationNestedInput
  }

  export type StationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    stationType?: StringFieldUpdateOperationsInput | string
    routes?: RouteStopUncheckedUpdateManyWithoutStationNestedInput
    departureSchedules?: ScheduleUncheckedUpdateManyWithoutDepartureStationNestedInput
    arrivalSchedules?: ScheduleUncheckedUpdateManyWithoutArrivalStationNestedInput
    favoriteOriginRoutes?: FavoriteRouteUncheckedUpdateManyWithoutOriginNestedInput
    favoriteDestinationRoutes?: FavoriteRouteUncheckedUpdateManyWithoutDestinationNestedInput
    historyOriginRoutes?: SearchHistoryUncheckedUpdateManyWithoutOriginNestedInput
    historyDestinationRoutes?: SearchHistoryUncheckedUpdateManyWithoutDestinationNestedInput
  }

  export type StationCreateManyInput = {
    id?: number
    code: string
    name: string
    city: string
    stationType: string
  }

  export type StationUpdateManyMutationInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    stationType?: StringFieldUpdateOperationsInput | string
  }

  export type StationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    stationType?: StringFieldUpdateOperationsInput | string
  }

  export type TrainCreateInput = {
    name: string
    trainType: string
    classes?: TrainClassCreateNestedManyWithoutTrainInput
    routeStops?: RouteStopCreateNestedManyWithoutTrainInput
    schedules?: ScheduleCreateNestedManyWithoutTrainInput
  }

  export type TrainUncheckedCreateInput = {
    id?: number
    name: string
    trainType: string
    classes?: TrainClassUncheckedCreateNestedManyWithoutTrainInput
    routeStops?: RouteStopUncheckedCreateNestedManyWithoutTrainInput
    schedules?: ScheduleUncheckedCreateNestedManyWithoutTrainInput
  }

  export type TrainUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    trainType?: StringFieldUpdateOperationsInput | string
    classes?: TrainClassUpdateManyWithoutTrainNestedInput
    routeStops?: RouteStopUpdateManyWithoutTrainNestedInput
    schedules?: ScheduleUpdateManyWithoutTrainNestedInput
  }

  export type TrainUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    trainType?: StringFieldUpdateOperationsInput | string
    classes?: TrainClassUncheckedUpdateManyWithoutTrainNestedInput
    routeStops?: RouteStopUncheckedUpdateManyWithoutTrainNestedInput
    schedules?: ScheduleUncheckedUpdateManyWithoutTrainNestedInput
  }

  export type TrainCreateManyInput = {
    id?: number
    name: string
    trainType: string
  }

  export type TrainUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    trainType?: StringFieldUpdateOperationsInput | string
  }

  export type TrainUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    trainType?: StringFieldUpdateOperationsInput | string
  }

  export type TrainClassCreateInput = {
    className: string
    price: number
    train: TrainCreateNestedOneWithoutClassesInput
  }

  export type TrainClassUncheckedCreateInput = {
    id?: number
    className: string
    price: number
    trainId: number
  }

  export type TrainClassUpdateInput = {
    className?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    train?: TrainUpdateOneRequiredWithoutClassesNestedInput
  }

  export type TrainClassUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    className?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    trainId?: IntFieldUpdateOperationsInput | number
  }

  export type TrainClassCreateManyInput = {
    id?: number
    className: string
    price: number
    trainId: number
  }

  export type TrainClassUpdateManyMutationInput = {
    className?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
  }

  export type TrainClassUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    className?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
    trainId?: IntFieldUpdateOperationsInput | number
  }

  export type RouteStopCreateInput = {
    stopOrder: number
    arrivalTime?: Date | string | null
    departureTime?: Date | string | null
    train: TrainCreateNestedOneWithoutRouteStopsInput
    station: StationCreateNestedOneWithoutRoutesInput
  }

  export type RouteStopUncheckedCreateInput = {
    id?: number
    stopOrder: number
    trainId: number
    stationId: number
    arrivalTime?: Date | string | null
    departureTime?: Date | string | null
  }

  export type RouteStopUpdateInput = {
    stopOrder?: IntFieldUpdateOperationsInput | number
    arrivalTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departureTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    train?: TrainUpdateOneRequiredWithoutRouteStopsNestedInput
    station?: StationUpdateOneRequiredWithoutRoutesNestedInput
  }

  export type RouteStopUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    stopOrder?: IntFieldUpdateOperationsInput | number
    trainId?: IntFieldUpdateOperationsInput | number
    stationId?: IntFieldUpdateOperationsInput | number
    arrivalTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departureTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RouteStopCreateManyInput = {
    id?: number
    stopOrder: number
    trainId: number
    stationId: number
    arrivalTime?: Date | string | null
    departureTime?: Date | string | null
  }

  export type RouteStopUpdateManyMutationInput = {
    stopOrder?: IntFieldUpdateOperationsInput | number
    arrivalTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departureTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RouteStopUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    stopOrder?: IntFieldUpdateOperationsInput | number
    trainId?: IntFieldUpdateOperationsInput | number
    stationId?: IntFieldUpdateOperationsInput | number
    arrivalTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departureTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ScheduleCreateInput = {
    departureTime: Date | string
    arrivalTime: Date | string
    train: TrainCreateNestedOneWithoutSchedulesInput
    departureStation: StationCreateNestedOneWithoutDepartureSchedulesInput
    arrivalStation: StationCreateNestedOneWithoutArrivalSchedulesInput
    bookings?: BookingCreateNestedManyWithoutScheduleInput
  }

  export type ScheduleUncheckedCreateInput = {
    id?: number
    departureTime: Date | string
    arrivalTime: Date | string
    trainId: number
    departureStationId: number
    arrivalStationId: number
    bookings?: BookingUncheckedCreateNestedManyWithoutScheduleInput
  }

  export type ScheduleUpdateInput = {
    departureTime?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalTime?: DateTimeFieldUpdateOperationsInput | Date | string
    train?: TrainUpdateOneRequiredWithoutSchedulesNestedInput
    departureStation?: StationUpdateOneRequiredWithoutDepartureSchedulesNestedInput
    arrivalStation?: StationUpdateOneRequiredWithoutArrivalSchedulesNestedInput
    bookings?: BookingUpdateManyWithoutScheduleNestedInput
  }

  export type ScheduleUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    departureTime?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalTime?: DateTimeFieldUpdateOperationsInput | Date | string
    trainId?: IntFieldUpdateOperationsInput | number
    departureStationId?: IntFieldUpdateOperationsInput | number
    arrivalStationId?: IntFieldUpdateOperationsInput | number
    bookings?: BookingUncheckedUpdateManyWithoutScheduleNestedInput
  }

  export type ScheduleCreateManyInput = {
    id?: number
    departureTime: Date | string
    arrivalTime: Date | string
    trainId: number
    departureStationId: number
    arrivalStationId: number
  }

  export type ScheduleUpdateManyMutationInput = {
    departureTime?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalTime?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduleUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    departureTime?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalTime?: DateTimeFieldUpdateOperationsInput | Date | string
    trainId?: IntFieldUpdateOperationsInput | number
    departureStationId?: IntFieldUpdateOperationsInput | number
    arrivalStationId?: IntFieldUpdateOperationsInput | number
  }

  export type FavoriteRouteCreateInput = {
    userId: string
    origin: StationCreateNestedOneWithoutFavoriteOriginRoutesInput
    destination: StationCreateNestedOneWithoutFavoriteDestinationRoutesInput
  }

  export type FavoriteRouteUncheckedCreateInput = {
    id?: number
    userId: string
    originStationId: number
    destinationStationId: number
  }

  export type FavoriteRouteUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    origin?: StationUpdateOneRequiredWithoutFavoriteOriginRoutesNestedInput
    destination?: StationUpdateOneRequiredWithoutFavoriteDestinationRoutesNestedInput
  }

  export type FavoriteRouteUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    originStationId?: IntFieldUpdateOperationsInput | number
    destinationStationId?: IntFieldUpdateOperationsInput | number
  }

  export type FavoriteRouteCreateManyInput = {
    id?: number
    userId: string
    originStationId: number
    destinationStationId: number
  }

  export type FavoriteRouteUpdateManyMutationInput = {
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type FavoriteRouteUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    originStationId?: IntFieldUpdateOperationsInput | number
    destinationStationId?: IntFieldUpdateOperationsInput | number
  }

  export type SearchHistoryCreateInput = {
    userId: string
    searchDate?: Date | string
    origin: StationCreateNestedOneWithoutHistoryOriginRoutesInput
    destination: StationCreateNestedOneWithoutHistoryDestinationRoutesInput
  }

  export type SearchHistoryUncheckedCreateInput = {
    id?: number
    userId: string
    searchDate?: Date | string
    originStationId: number
    destinationStationId: number
  }

  export type SearchHistoryUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    searchDate?: DateTimeFieldUpdateOperationsInput | Date | string
    origin?: StationUpdateOneRequiredWithoutHistoryOriginRoutesNestedInput
    destination?: StationUpdateOneRequiredWithoutHistoryDestinationRoutesNestedInput
  }

  export type SearchHistoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    searchDate?: DateTimeFieldUpdateOperationsInput | Date | string
    originStationId?: IntFieldUpdateOperationsInput | number
    destinationStationId?: IntFieldUpdateOperationsInput | number
  }

  export type SearchHistoryCreateManyInput = {
    id?: number
    userId: string
    searchDate?: Date | string
    originStationId: number
    destinationStationId: number
  }

  export type SearchHistoryUpdateManyMutationInput = {
    userId?: StringFieldUpdateOperationsInput | string
    searchDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SearchHistoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    searchDate?: DateTimeFieldUpdateOperationsInput | Date | string
    originStationId?: IntFieldUpdateOperationsInput | number
    destinationStationId?: IntFieldUpdateOperationsInput | number
  }

  export type BookingCreateInput = {
    userId: string
    className: string
    totalPrice: number
    status?: string
    createdAt?: Date | string
    schedule: ScheduleCreateNestedOneWithoutBookingsInput
    payment?: PaymentCreateNestedOneWithoutBookingInput
  }

  export type BookingUncheckedCreateInput = {
    id?: number
    userId: string
    scheduleId: number
    className: string
    totalPrice: number
    status?: string
    createdAt?: Date | string
    payment?: PaymentUncheckedCreateNestedOneWithoutBookingInput
  }

  export type BookingUpdateInput = {
    userId?: StringFieldUpdateOperationsInput | string
    className?: StringFieldUpdateOperationsInput | string
    totalPrice?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schedule?: ScheduleUpdateOneRequiredWithoutBookingsNestedInput
    payment?: PaymentUpdateOneWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    scheduleId?: IntFieldUpdateOperationsInput | number
    className?: StringFieldUpdateOperationsInput | string
    totalPrice?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payment?: PaymentUncheckedUpdateOneWithoutBookingNestedInput
  }

  export type BookingCreateManyInput = {
    id?: number
    userId: string
    scheduleId: number
    className: string
    totalPrice: number
    status?: string
    createdAt?: Date | string
  }

  export type BookingUpdateManyMutationInput = {
    userId?: StringFieldUpdateOperationsInput | string
    className?: StringFieldUpdateOperationsInput | string
    totalPrice?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    scheduleId?: IntFieldUpdateOperationsInput | number
    className?: StringFieldUpdateOperationsInput | string
    totalPrice?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateInput = {
    method: string
    paidAmount: number
    paidAt?: Date | string
    booking: BookingCreateNestedOneWithoutPaymentInput
  }

  export type PaymentUncheckedCreateInput = {
    id?: number
    bookingId: number
    method: string
    paidAmount: number
    paidAt?: Date | string
  }

  export type PaymentUpdateInput = {
    method?: StringFieldUpdateOperationsInput | string
    paidAmount?: IntFieldUpdateOperationsInput | number
    paidAt?: DateTimeFieldUpdateOperationsInput | Date | string
    booking?: BookingUpdateOneRequiredWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookingId?: IntFieldUpdateOperationsInput | number
    method?: StringFieldUpdateOperationsInput | string
    paidAmount?: IntFieldUpdateOperationsInput | number
    paidAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateManyInput = {
    id?: number
    bookingId: number
    method: string
    paidAmount: number
    paidAt?: Date | string
  }

  export type PaymentUpdateManyMutationInput = {
    method?: StringFieldUpdateOperationsInput | string
    paidAmount?: IntFieldUpdateOperationsInput | number
    paidAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    bookingId?: IntFieldUpdateOperationsInput | number
    method?: StringFieldUpdateOperationsInput | string
    paidAmount?: IntFieldUpdateOperationsInput | number
    paidAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type RouteStopListRelationFilter = {
    every?: RouteStopWhereInput
    some?: RouteStopWhereInput
    none?: RouteStopWhereInput
  }

  export type ScheduleListRelationFilter = {
    every?: ScheduleWhereInput
    some?: ScheduleWhereInput
    none?: ScheduleWhereInput
  }

  export type FavoriteRouteListRelationFilter = {
    every?: FavoriteRouteWhereInput
    some?: FavoriteRouteWhereInput
    none?: FavoriteRouteWhereInput
  }

  export type SearchHistoryListRelationFilter = {
    every?: SearchHistoryWhereInput
    some?: SearchHistoryWhereInput
    none?: SearchHistoryWhereInput
  }

  export type RouteStopOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ScheduleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FavoriteRouteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SearchHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StationCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    city?: SortOrder
    stationType?: SortOrder
  }

  export type StationAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type StationMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    city?: SortOrder
    stationType?: SortOrder
  }

  export type StationMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    city?: SortOrder
    stationType?: SortOrder
  }

  export type StationSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type TrainClassListRelationFilter = {
    every?: TrainClassWhereInput
    some?: TrainClassWhereInput
    none?: TrainClassWhereInput
  }

  export type TrainClassOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TrainCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    trainType?: SortOrder
  }

  export type TrainAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TrainMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    trainType?: SortOrder
  }

  export type TrainMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    trainType?: SortOrder
  }

  export type TrainSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TrainRelationFilter = {
    is?: TrainWhereInput
    isNot?: TrainWhereInput
  }

  export type TrainClassCountOrderByAggregateInput = {
    id?: SortOrder
    className?: SortOrder
    price?: SortOrder
    trainId?: SortOrder
  }

  export type TrainClassAvgOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    trainId?: SortOrder
  }

  export type TrainClassMaxOrderByAggregateInput = {
    id?: SortOrder
    className?: SortOrder
    price?: SortOrder
    trainId?: SortOrder
  }

  export type TrainClassMinOrderByAggregateInput = {
    id?: SortOrder
    className?: SortOrder
    price?: SortOrder
    trainId?: SortOrder
  }

  export type TrainClassSumOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    trainId?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type StationRelationFilter = {
    is?: StationWhereInput
    isNot?: StationWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type RouteStopCountOrderByAggregateInput = {
    id?: SortOrder
    stopOrder?: SortOrder
    trainId?: SortOrder
    stationId?: SortOrder
    arrivalTime?: SortOrder
    departureTime?: SortOrder
  }

  export type RouteStopAvgOrderByAggregateInput = {
    id?: SortOrder
    stopOrder?: SortOrder
    trainId?: SortOrder
    stationId?: SortOrder
  }

  export type RouteStopMaxOrderByAggregateInput = {
    id?: SortOrder
    stopOrder?: SortOrder
    trainId?: SortOrder
    stationId?: SortOrder
    arrivalTime?: SortOrder
    departureTime?: SortOrder
  }

  export type RouteStopMinOrderByAggregateInput = {
    id?: SortOrder
    stopOrder?: SortOrder
    trainId?: SortOrder
    stationId?: SortOrder
    arrivalTime?: SortOrder
    departureTime?: SortOrder
  }

  export type RouteStopSumOrderByAggregateInput = {
    id?: SortOrder
    stopOrder?: SortOrder
    trainId?: SortOrder
    stationId?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type BookingListRelationFilter = {
    every?: BookingWhereInput
    some?: BookingWhereInput
    none?: BookingWhereInput
  }

  export type BookingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ScheduleCountOrderByAggregateInput = {
    id?: SortOrder
    departureTime?: SortOrder
    arrivalTime?: SortOrder
    trainId?: SortOrder
    departureStationId?: SortOrder
    arrivalStationId?: SortOrder
  }

  export type ScheduleAvgOrderByAggregateInput = {
    id?: SortOrder
    trainId?: SortOrder
    departureStationId?: SortOrder
    arrivalStationId?: SortOrder
  }

  export type ScheduleMaxOrderByAggregateInput = {
    id?: SortOrder
    departureTime?: SortOrder
    arrivalTime?: SortOrder
    trainId?: SortOrder
    departureStationId?: SortOrder
    arrivalStationId?: SortOrder
  }

  export type ScheduleMinOrderByAggregateInput = {
    id?: SortOrder
    departureTime?: SortOrder
    arrivalTime?: SortOrder
    trainId?: SortOrder
    departureStationId?: SortOrder
    arrivalStationId?: SortOrder
  }

  export type ScheduleSumOrderByAggregateInput = {
    id?: SortOrder
    trainId?: SortOrder
    departureStationId?: SortOrder
    arrivalStationId?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type FavoriteRouteCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    originStationId?: SortOrder
    destinationStationId?: SortOrder
  }

  export type FavoriteRouteAvgOrderByAggregateInput = {
    id?: SortOrder
    originStationId?: SortOrder
    destinationStationId?: SortOrder
  }

  export type FavoriteRouteMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    originStationId?: SortOrder
    destinationStationId?: SortOrder
  }

  export type FavoriteRouteMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    originStationId?: SortOrder
    destinationStationId?: SortOrder
  }

  export type FavoriteRouteSumOrderByAggregateInput = {
    id?: SortOrder
    originStationId?: SortOrder
    destinationStationId?: SortOrder
  }

  export type SearchHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    searchDate?: SortOrder
    originStationId?: SortOrder
    destinationStationId?: SortOrder
  }

  export type SearchHistoryAvgOrderByAggregateInput = {
    id?: SortOrder
    originStationId?: SortOrder
    destinationStationId?: SortOrder
  }

  export type SearchHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    searchDate?: SortOrder
    originStationId?: SortOrder
    destinationStationId?: SortOrder
  }

  export type SearchHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    searchDate?: SortOrder
    originStationId?: SortOrder
    destinationStationId?: SortOrder
  }

  export type SearchHistorySumOrderByAggregateInput = {
    id?: SortOrder
    originStationId?: SortOrder
    destinationStationId?: SortOrder
  }

  export type ScheduleRelationFilter = {
    is?: ScheduleWhereInput
    isNot?: ScheduleWhereInput
  }

  export type PaymentNullableRelationFilter = {
    is?: PaymentWhereInput | null
    isNot?: PaymentWhereInput | null
  }

  export type BookingCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    scheduleId?: SortOrder
    className?: SortOrder
    totalPrice?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type BookingAvgOrderByAggregateInput = {
    id?: SortOrder
    scheduleId?: SortOrder
    totalPrice?: SortOrder
  }

  export type BookingMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    scheduleId?: SortOrder
    className?: SortOrder
    totalPrice?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type BookingMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    scheduleId?: SortOrder
    className?: SortOrder
    totalPrice?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type BookingSumOrderByAggregateInput = {
    id?: SortOrder
    scheduleId?: SortOrder
    totalPrice?: SortOrder
  }

  export type BookingRelationFilter = {
    is?: BookingWhereInput
    isNot?: BookingWhereInput
  }

  export type PaymentCountOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    method?: SortOrder
    paidAmount?: SortOrder
    paidAt?: SortOrder
  }

  export type PaymentAvgOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    paidAmount?: SortOrder
  }

  export type PaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    method?: SortOrder
    paidAmount?: SortOrder
    paidAt?: SortOrder
  }

  export type PaymentMinOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    method?: SortOrder
    paidAmount?: SortOrder
    paidAt?: SortOrder
  }

  export type PaymentSumOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    paidAmount?: SortOrder
  }

  export type RouteStopCreateNestedManyWithoutStationInput = {
    create?: XOR<RouteStopCreateWithoutStationInput, RouteStopUncheckedCreateWithoutStationInput> | RouteStopCreateWithoutStationInput[] | RouteStopUncheckedCreateWithoutStationInput[]
    connectOrCreate?: RouteStopCreateOrConnectWithoutStationInput | RouteStopCreateOrConnectWithoutStationInput[]
    createMany?: RouteStopCreateManyStationInputEnvelope
    connect?: RouteStopWhereUniqueInput | RouteStopWhereUniqueInput[]
  }

  export type ScheduleCreateNestedManyWithoutDepartureStationInput = {
    create?: XOR<ScheduleCreateWithoutDepartureStationInput, ScheduleUncheckedCreateWithoutDepartureStationInput> | ScheduleCreateWithoutDepartureStationInput[] | ScheduleUncheckedCreateWithoutDepartureStationInput[]
    connectOrCreate?: ScheduleCreateOrConnectWithoutDepartureStationInput | ScheduleCreateOrConnectWithoutDepartureStationInput[]
    createMany?: ScheduleCreateManyDepartureStationInputEnvelope
    connect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
  }

  export type ScheduleCreateNestedManyWithoutArrivalStationInput = {
    create?: XOR<ScheduleCreateWithoutArrivalStationInput, ScheduleUncheckedCreateWithoutArrivalStationInput> | ScheduleCreateWithoutArrivalStationInput[] | ScheduleUncheckedCreateWithoutArrivalStationInput[]
    connectOrCreate?: ScheduleCreateOrConnectWithoutArrivalStationInput | ScheduleCreateOrConnectWithoutArrivalStationInput[]
    createMany?: ScheduleCreateManyArrivalStationInputEnvelope
    connect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
  }

  export type FavoriteRouteCreateNestedManyWithoutOriginInput = {
    create?: XOR<FavoriteRouteCreateWithoutOriginInput, FavoriteRouteUncheckedCreateWithoutOriginInput> | FavoriteRouteCreateWithoutOriginInput[] | FavoriteRouteUncheckedCreateWithoutOriginInput[]
    connectOrCreate?: FavoriteRouteCreateOrConnectWithoutOriginInput | FavoriteRouteCreateOrConnectWithoutOriginInput[]
    createMany?: FavoriteRouteCreateManyOriginInputEnvelope
    connect?: FavoriteRouteWhereUniqueInput | FavoriteRouteWhereUniqueInput[]
  }

  export type FavoriteRouteCreateNestedManyWithoutDestinationInput = {
    create?: XOR<FavoriteRouteCreateWithoutDestinationInput, FavoriteRouteUncheckedCreateWithoutDestinationInput> | FavoriteRouteCreateWithoutDestinationInput[] | FavoriteRouteUncheckedCreateWithoutDestinationInput[]
    connectOrCreate?: FavoriteRouteCreateOrConnectWithoutDestinationInput | FavoriteRouteCreateOrConnectWithoutDestinationInput[]
    createMany?: FavoriteRouteCreateManyDestinationInputEnvelope
    connect?: FavoriteRouteWhereUniqueInput | FavoriteRouteWhereUniqueInput[]
  }

  export type SearchHistoryCreateNestedManyWithoutOriginInput = {
    create?: XOR<SearchHistoryCreateWithoutOriginInput, SearchHistoryUncheckedCreateWithoutOriginInput> | SearchHistoryCreateWithoutOriginInput[] | SearchHistoryUncheckedCreateWithoutOriginInput[]
    connectOrCreate?: SearchHistoryCreateOrConnectWithoutOriginInput | SearchHistoryCreateOrConnectWithoutOriginInput[]
    createMany?: SearchHistoryCreateManyOriginInputEnvelope
    connect?: SearchHistoryWhereUniqueInput | SearchHistoryWhereUniqueInput[]
  }

  export type SearchHistoryCreateNestedManyWithoutDestinationInput = {
    create?: XOR<SearchHistoryCreateWithoutDestinationInput, SearchHistoryUncheckedCreateWithoutDestinationInput> | SearchHistoryCreateWithoutDestinationInput[] | SearchHistoryUncheckedCreateWithoutDestinationInput[]
    connectOrCreate?: SearchHistoryCreateOrConnectWithoutDestinationInput | SearchHistoryCreateOrConnectWithoutDestinationInput[]
    createMany?: SearchHistoryCreateManyDestinationInputEnvelope
    connect?: SearchHistoryWhereUniqueInput | SearchHistoryWhereUniqueInput[]
  }

  export type RouteStopUncheckedCreateNestedManyWithoutStationInput = {
    create?: XOR<RouteStopCreateWithoutStationInput, RouteStopUncheckedCreateWithoutStationInput> | RouteStopCreateWithoutStationInput[] | RouteStopUncheckedCreateWithoutStationInput[]
    connectOrCreate?: RouteStopCreateOrConnectWithoutStationInput | RouteStopCreateOrConnectWithoutStationInput[]
    createMany?: RouteStopCreateManyStationInputEnvelope
    connect?: RouteStopWhereUniqueInput | RouteStopWhereUniqueInput[]
  }

  export type ScheduleUncheckedCreateNestedManyWithoutDepartureStationInput = {
    create?: XOR<ScheduleCreateWithoutDepartureStationInput, ScheduleUncheckedCreateWithoutDepartureStationInput> | ScheduleCreateWithoutDepartureStationInput[] | ScheduleUncheckedCreateWithoutDepartureStationInput[]
    connectOrCreate?: ScheduleCreateOrConnectWithoutDepartureStationInput | ScheduleCreateOrConnectWithoutDepartureStationInput[]
    createMany?: ScheduleCreateManyDepartureStationInputEnvelope
    connect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
  }

  export type ScheduleUncheckedCreateNestedManyWithoutArrivalStationInput = {
    create?: XOR<ScheduleCreateWithoutArrivalStationInput, ScheduleUncheckedCreateWithoutArrivalStationInput> | ScheduleCreateWithoutArrivalStationInput[] | ScheduleUncheckedCreateWithoutArrivalStationInput[]
    connectOrCreate?: ScheduleCreateOrConnectWithoutArrivalStationInput | ScheduleCreateOrConnectWithoutArrivalStationInput[]
    createMany?: ScheduleCreateManyArrivalStationInputEnvelope
    connect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
  }

  export type FavoriteRouteUncheckedCreateNestedManyWithoutOriginInput = {
    create?: XOR<FavoriteRouteCreateWithoutOriginInput, FavoriteRouteUncheckedCreateWithoutOriginInput> | FavoriteRouteCreateWithoutOriginInput[] | FavoriteRouteUncheckedCreateWithoutOriginInput[]
    connectOrCreate?: FavoriteRouteCreateOrConnectWithoutOriginInput | FavoriteRouteCreateOrConnectWithoutOriginInput[]
    createMany?: FavoriteRouteCreateManyOriginInputEnvelope
    connect?: FavoriteRouteWhereUniqueInput | FavoriteRouteWhereUniqueInput[]
  }

  export type FavoriteRouteUncheckedCreateNestedManyWithoutDestinationInput = {
    create?: XOR<FavoriteRouteCreateWithoutDestinationInput, FavoriteRouteUncheckedCreateWithoutDestinationInput> | FavoriteRouteCreateWithoutDestinationInput[] | FavoriteRouteUncheckedCreateWithoutDestinationInput[]
    connectOrCreate?: FavoriteRouteCreateOrConnectWithoutDestinationInput | FavoriteRouteCreateOrConnectWithoutDestinationInput[]
    createMany?: FavoriteRouteCreateManyDestinationInputEnvelope
    connect?: FavoriteRouteWhereUniqueInput | FavoriteRouteWhereUniqueInput[]
  }

  export type SearchHistoryUncheckedCreateNestedManyWithoutOriginInput = {
    create?: XOR<SearchHistoryCreateWithoutOriginInput, SearchHistoryUncheckedCreateWithoutOriginInput> | SearchHistoryCreateWithoutOriginInput[] | SearchHistoryUncheckedCreateWithoutOriginInput[]
    connectOrCreate?: SearchHistoryCreateOrConnectWithoutOriginInput | SearchHistoryCreateOrConnectWithoutOriginInput[]
    createMany?: SearchHistoryCreateManyOriginInputEnvelope
    connect?: SearchHistoryWhereUniqueInput | SearchHistoryWhereUniqueInput[]
  }

  export type SearchHistoryUncheckedCreateNestedManyWithoutDestinationInput = {
    create?: XOR<SearchHistoryCreateWithoutDestinationInput, SearchHistoryUncheckedCreateWithoutDestinationInput> | SearchHistoryCreateWithoutDestinationInput[] | SearchHistoryUncheckedCreateWithoutDestinationInput[]
    connectOrCreate?: SearchHistoryCreateOrConnectWithoutDestinationInput | SearchHistoryCreateOrConnectWithoutDestinationInput[]
    createMany?: SearchHistoryCreateManyDestinationInputEnvelope
    connect?: SearchHistoryWhereUniqueInput | SearchHistoryWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type RouteStopUpdateManyWithoutStationNestedInput = {
    create?: XOR<RouteStopCreateWithoutStationInput, RouteStopUncheckedCreateWithoutStationInput> | RouteStopCreateWithoutStationInput[] | RouteStopUncheckedCreateWithoutStationInput[]
    connectOrCreate?: RouteStopCreateOrConnectWithoutStationInput | RouteStopCreateOrConnectWithoutStationInput[]
    upsert?: RouteStopUpsertWithWhereUniqueWithoutStationInput | RouteStopUpsertWithWhereUniqueWithoutStationInput[]
    createMany?: RouteStopCreateManyStationInputEnvelope
    set?: RouteStopWhereUniqueInput | RouteStopWhereUniqueInput[]
    disconnect?: RouteStopWhereUniqueInput | RouteStopWhereUniqueInput[]
    delete?: RouteStopWhereUniqueInput | RouteStopWhereUniqueInput[]
    connect?: RouteStopWhereUniqueInput | RouteStopWhereUniqueInput[]
    update?: RouteStopUpdateWithWhereUniqueWithoutStationInput | RouteStopUpdateWithWhereUniqueWithoutStationInput[]
    updateMany?: RouteStopUpdateManyWithWhereWithoutStationInput | RouteStopUpdateManyWithWhereWithoutStationInput[]
    deleteMany?: RouteStopScalarWhereInput | RouteStopScalarWhereInput[]
  }

  export type ScheduleUpdateManyWithoutDepartureStationNestedInput = {
    create?: XOR<ScheduleCreateWithoutDepartureStationInput, ScheduleUncheckedCreateWithoutDepartureStationInput> | ScheduleCreateWithoutDepartureStationInput[] | ScheduleUncheckedCreateWithoutDepartureStationInput[]
    connectOrCreate?: ScheduleCreateOrConnectWithoutDepartureStationInput | ScheduleCreateOrConnectWithoutDepartureStationInput[]
    upsert?: ScheduleUpsertWithWhereUniqueWithoutDepartureStationInput | ScheduleUpsertWithWhereUniqueWithoutDepartureStationInput[]
    createMany?: ScheduleCreateManyDepartureStationInputEnvelope
    set?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    disconnect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    delete?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    connect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    update?: ScheduleUpdateWithWhereUniqueWithoutDepartureStationInput | ScheduleUpdateWithWhereUniqueWithoutDepartureStationInput[]
    updateMany?: ScheduleUpdateManyWithWhereWithoutDepartureStationInput | ScheduleUpdateManyWithWhereWithoutDepartureStationInput[]
    deleteMany?: ScheduleScalarWhereInput | ScheduleScalarWhereInput[]
  }

  export type ScheduleUpdateManyWithoutArrivalStationNestedInput = {
    create?: XOR<ScheduleCreateWithoutArrivalStationInput, ScheduleUncheckedCreateWithoutArrivalStationInput> | ScheduleCreateWithoutArrivalStationInput[] | ScheduleUncheckedCreateWithoutArrivalStationInput[]
    connectOrCreate?: ScheduleCreateOrConnectWithoutArrivalStationInput | ScheduleCreateOrConnectWithoutArrivalStationInput[]
    upsert?: ScheduleUpsertWithWhereUniqueWithoutArrivalStationInput | ScheduleUpsertWithWhereUniqueWithoutArrivalStationInput[]
    createMany?: ScheduleCreateManyArrivalStationInputEnvelope
    set?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    disconnect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    delete?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    connect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    update?: ScheduleUpdateWithWhereUniqueWithoutArrivalStationInput | ScheduleUpdateWithWhereUniqueWithoutArrivalStationInput[]
    updateMany?: ScheduleUpdateManyWithWhereWithoutArrivalStationInput | ScheduleUpdateManyWithWhereWithoutArrivalStationInput[]
    deleteMany?: ScheduleScalarWhereInput | ScheduleScalarWhereInput[]
  }

  export type FavoriteRouteUpdateManyWithoutOriginNestedInput = {
    create?: XOR<FavoriteRouteCreateWithoutOriginInput, FavoriteRouteUncheckedCreateWithoutOriginInput> | FavoriteRouteCreateWithoutOriginInput[] | FavoriteRouteUncheckedCreateWithoutOriginInput[]
    connectOrCreate?: FavoriteRouteCreateOrConnectWithoutOriginInput | FavoriteRouteCreateOrConnectWithoutOriginInput[]
    upsert?: FavoriteRouteUpsertWithWhereUniqueWithoutOriginInput | FavoriteRouteUpsertWithWhereUniqueWithoutOriginInput[]
    createMany?: FavoriteRouteCreateManyOriginInputEnvelope
    set?: FavoriteRouteWhereUniqueInput | FavoriteRouteWhereUniqueInput[]
    disconnect?: FavoriteRouteWhereUniqueInput | FavoriteRouteWhereUniqueInput[]
    delete?: FavoriteRouteWhereUniqueInput | FavoriteRouteWhereUniqueInput[]
    connect?: FavoriteRouteWhereUniqueInput | FavoriteRouteWhereUniqueInput[]
    update?: FavoriteRouteUpdateWithWhereUniqueWithoutOriginInput | FavoriteRouteUpdateWithWhereUniqueWithoutOriginInput[]
    updateMany?: FavoriteRouteUpdateManyWithWhereWithoutOriginInput | FavoriteRouteUpdateManyWithWhereWithoutOriginInput[]
    deleteMany?: FavoriteRouteScalarWhereInput | FavoriteRouteScalarWhereInput[]
  }

  export type FavoriteRouteUpdateManyWithoutDestinationNestedInput = {
    create?: XOR<FavoriteRouteCreateWithoutDestinationInput, FavoriteRouteUncheckedCreateWithoutDestinationInput> | FavoriteRouteCreateWithoutDestinationInput[] | FavoriteRouteUncheckedCreateWithoutDestinationInput[]
    connectOrCreate?: FavoriteRouteCreateOrConnectWithoutDestinationInput | FavoriteRouteCreateOrConnectWithoutDestinationInput[]
    upsert?: FavoriteRouteUpsertWithWhereUniqueWithoutDestinationInput | FavoriteRouteUpsertWithWhereUniqueWithoutDestinationInput[]
    createMany?: FavoriteRouteCreateManyDestinationInputEnvelope
    set?: FavoriteRouteWhereUniqueInput | FavoriteRouteWhereUniqueInput[]
    disconnect?: FavoriteRouteWhereUniqueInput | FavoriteRouteWhereUniqueInput[]
    delete?: FavoriteRouteWhereUniqueInput | FavoriteRouteWhereUniqueInput[]
    connect?: FavoriteRouteWhereUniqueInput | FavoriteRouteWhereUniqueInput[]
    update?: FavoriteRouteUpdateWithWhereUniqueWithoutDestinationInput | FavoriteRouteUpdateWithWhereUniqueWithoutDestinationInput[]
    updateMany?: FavoriteRouteUpdateManyWithWhereWithoutDestinationInput | FavoriteRouteUpdateManyWithWhereWithoutDestinationInput[]
    deleteMany?: FavoriteRouteScalarWhereInput | FavoriteRouteScalarWhereInput[]
  }

  export type SearchHistoryUpdateManyWithoutOriginNestedInput = {
    create?: XOR<SearchHistoryCreateWithoutOriginInput, SearchHistoryUncheckedCreateWithoutOriginInput> | SearchHistoryCreateWithoutOriginInput[] | SearchHistoryUncheckedCreateWithoutOriginInput[]
    connectOrCreate?: SearchHistoryCreateOrConnectWithoutOriginInput | SearchHistoryCreateOrConnectWithoutOriginInput[]
    upsert?: SearchHistoryUpsertWithWhereUniqueWithoutOriginInput | SearchHistoryUpsertWithWhereUniqueWithoutOriginInput[]
    createMany?: SearchHistoryCreateManyOriginInputEnvelope
    set?: SearchHistoryWhereUniqueInput | SearchHistoryWhereUniqueInput[]
    disconnect?: SearchHistoryWhereUniqueInput | SearchHistoryWhereUniqueInput[]
    delete?: SearchHistoryWhereUniqueInput | SearchHistoryWhereUniqueInput[]
    connect?: SearchHistoryWhereUniqueInput | SearchHistoryWhereUniqueInput[]
    update?: SearchHistoryUpdateWithWhereUniqueWithoutOriginInput | SearchHistoryUpdateWithWhereUniqueWithoutOriginInput[]
    updateMany?: SearchHistoryUpdateManyWithWhereWithoutOriginInput | SearchHistoryUpdateManyWithWhereWithoutOriginInput[]
    deleteMany?: SearchHistoryScalarWhereInput | SearchHistoryScalarWhereInput[]
  }

  export type SearchHistoryUpdateManyWithoutDestinationNestedInput = {
    create?: XOR<SearchHistoryCreateWithoutDestinationInput, SearchHistoryUncheckedCreateWithoutDestinationInput> | SearchHistoryCreateWithoutDestinationInput[] | SearchHistoryUncheckedCreateWithoutDestinationInput[]
    connectOrCreate?: SearchHistoryCreateOrConnectWithoutDestinationInput | SearchHistoryCreateOrConnectWithoutDestinationInput[]
    upsert?: SearchHistoryUpsertWithWhereUniqueWithoutDestinationInput | SearchHistoryUpsertWithWhereUniqueWithoutDestinationInput[]
    createMany?: SearchHistoryCreateManyDestinationInputEnvelope
    set?: SearchHistoryWhereUniqueInput | SearchHistoryWhereUniqueInput[]
    disconnect?: SearchHistoryWhereUniqueInput | SearchHistoryWhereUniqueInput[]
    delete?: SearchHistoryWhereUniqueInput | SearchHistoryWhereUniqueInput[]
    connect?: SearchHistoryWhereUniqueInput | SearchHistoryWhereUniqueInput[]
    update?: SearchHistoryUpdateWithWhereUniqueWithoutDestinationInput | SearchHistoryUpdateWithWhereUniqueWithoutDestinationInput[]
    updateMany?: SearchHistoryUpdateManyWithWhereWithoutDestinationInput | SearchHistoryUpdateManyWithWhereWithoutDestinationInput[]
    deleteMany?: SearchHistoryScalarWhereInput | SearchHistoryScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type RouteStopUncheckedUpdateManyWithoutStationNestedInput = {
    create?: XOR<RouteStopCreateWithoutStationInput, RouteStopUncheckedCreateWithoutStationInput> | RouteStopCreateWithoutStationInput[] | RouteStopUncheckedCreateWithoutStationInput[]
    connectOrCreate?: RouteStopCreateOrConnectWithoutStationInput | RouteStopCreateOrConnectWithoutStationInput[]
    upsert?: RouteStopUpsertWithWhereUniqueWithoutStationInput | RouteStopUpsertWithWhereUniqueWithoutStationInput[]
    createMany?: RouteStopCreateManyStationInputEnvelope
    set?: RouteStopWhereUniqueInput | RouteStopWhereUniqueInput[]
    disconnect?: RouteStopWhereUniqueInput | RouteStopWhereUniqueInput[]
    delete?: RouteStopWhereUniqueInput | RouteStopWhereUniqueInput[]
    connect?: RouteStopWhereUniqueInput | RouteStopWhereUniqueInput[]
    update?: RouteStopUpdateWithWhereUniqueWithoutStationInput | RouteStopUpdateWithWhereUniqueWithoutStationInput[]
    updateMany?: RouteStopUpdateManyWithWhereWithoutStationInput | RouteStopUpdateManyWithWhereWithoutStationInput[]
    deleteMany?: RouteStopScalarWhereInput | RouteStopScalarWhereInput[]
  }

  export type ScheduleUncheckedUpdateManyWithoutDepartureStationNestedInput = {
    create?: XOR<ScheduleCreateWithoutDepartureStationInput, ScheduleUncheckedCreateWithoutDepartureStationInput> | ScheduleCreateWithoutDepartureStationInput[] | ScheduleUncheckedCreateWithoutDepartureStationInput[]
    connectOrCreate?: ScheduleCreateOrConnectWithoutDepartureStationInput | ScheduleCreateOrConnectWithoutDepartureStationInput[]
    upsert?: ScheduleUpsertWithWhereUniqueWithoutDepartureStationInput | ScheduleUpsertWithWhereUniqueWithoutDepartureStationInput[]
    createMany?: ScheduleCreateManyDepartureStationInputEnvelope
    set?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    disconnect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    delete?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    connect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    update?: ScheduleUpdateWithWhereUniqueWithoutDepartureStationInput | ScheduleUpdateWithWhereUniqueWithoutDepartureStationInput[]
    updateMany?: ScheduleUpdateManyWithWhereWithoutDepartureStationInput | ScheduleUpdateManyWithWhereWithoutDepartureStationInput[]
    deleteMany?: ScheduleScalarWhereInput | ScheduleScalarWhereInput[]
  }

  export type ScheduleUncheckedUpdateManyWithoutArrivalStationNestedInput = {
    create?: XOR<ScheduleCreateWithoutArrivalStationInput, ScheduleUncheckedCreateWithoutArrivalStationInput> | ScheduleCreateWithoutArrivalStationInput[] | ScheduleUncheckedCreateWithoutArrivalStationInput[]
    connectOrCreate?: ScheduleCreateOrConnectWithoutArrivalStationInput | ScheduleCreateOrConnectWithoutArrivalStationInput[]
    upsert?: ScheduleUpsertWithWhereUniqueWithoutArrivalStationInput | ScheduleUpsertWithWhereUniqueWithoutArrivalStationInput[]
    createMany?: ScheduleCreateManyArrivalStationInputEnvelope
    set?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    disconnect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    delete?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    connect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    update?: ScheduleUpdateWithWhereUniqueWithoutArrivalStationInput | ScheduleUpdateWithWhereUniqueWithoutArrivalStationInput[]
    updateMany?: ScheduleUpdateManyWithWhereWithoutArrivalStationInput | ScheduleUpdateManyWithWhereWithoutArrivalStationInput[]
    deleteMany?: ScheduleScalarWhereInput | ScheduleScalarWhereInput[]
  }

  export type FavoriteRouteUncheckedUpdateManyWithoutOriginNestedInput = {
    create?: XOR<FavoriteRouteCreateWithoutOriginInput, FavoriteRouteUncheckedCreateWithoutOriginInput> | FavoriteRouteCreateWithoutOriginInput[] | FavoriteRouteUncheckedCreateWithoutOriginInput[]
    connectOrCreate?: FavoriteRouteCreateOrConnectWithoutOriginInput | FavoriteRouteCreateOrConnectWithoutOriginInput[]
    upsert?: FavoriteRouteUpsertWithWhereUniqueWithoutOriginInput | FavoriteRouteUpsertWithWhereUniqueWithoutOriginInput[]
    createMany?: FavoriteRouteCreateManyOriginInputEnvelope
    set?: FavoriteRouteWhereUniqueInput | FavoriteRouteWhereUniqueInput[]
    disconnect?: FavoriteRouteWhereUniqueInput | FavoriteRouteWhereUniqueInput[]
    delete?: FavoriteRouteWhereUniqueInput | FavoriteRouteWhereUniqueInput[]
    connect?: FavoriteRouteWhereUniqueInput | FavoriteRouteWhereUniqueInput[]
    update?: FavoriteRouteUpdateWithWhereUniqueWithoutOriginInput | FavoriteRouteUpdateWithWhereUniqueWithoutOriginInput[]
    updateMany?: FavoriteRouteUpdateManyWithWhereWithoutOriginInput | FavoriteRouteUpdateManyWithWhereWithoutOriginInput[]
    deleteMany?: FavoriteRouteScalarWhereInput | FavoriteRouteScalarWhereInput[]
  }

  export type FavoriteRouteUncheckedUpdateManyWithoutDestinationNestedInput = {
    create?: XOR<FavoriteRouteCreateWithoutDestinationInput, FavoriteRouteUncheckedCreateWithoutDestinationInput> | FavoriteRouteCreateWithoutDestinationInput[] | FavoriteRouteUncheckedCreateWithoutDestinationInput[]
    connectOrCreate?: FavoriteRouteCreateOrConnectWithoutDestinationInput | FavoriteRouteCreateOrConnectWithoutDestinationInput[]
    upsert?: FavoriteRouteUpsertWithWhereUniqueWithoutDestinationInput | FavoriteRouteUpsertWithWhereUniqueWithoutDestinationInput[]
    createMany?: FavoriteRouteCreateManyDestinationInputEnvelope
    set?: FavoriteRouteWhereUniqueInput | FavoriteRouteWhereUniqueInput[]
    disconnect?: FavoriteRouteWhereUniqueInput | FavoriteRouteWhereUniqueInput[]
    delete?: FavoriteRouteWhereUniqueInput | FavoriteRouteWhereUniqueInput[]
    connect?: FavoriteRouteWhereUniqueInput | FavoriteRouteWhereUniqueInput[]
    update?: FavoriteRouteUpdateWithWhereUniqueWithoutDestinationInput | FavoriteRouteUpdateWithWhereUniqueWithoutDestinationInput[]
    updateMany?: FavoriteRouteUpdateManyWithWhereWithoutDestinationInput | FavoriteRouteUpdateManyWithWhereWithoutDestinationInput[]
    deleteMany?: FavoriteRouteScalarWhereInput | FavoriteRouteScalarWhereInput[]
  }

  export type SearchHistoryUncheckedUpdateManyWithoutOriginNestedInput = {
    create?: XOR<SearchHistoryCreateWithoutOriginInput, SearchHistoryUncheckedCreateWithoutOriginInput> | SearchHistoryCreateWithoutOriginInput[] | SearchHistoryUncheckedCreateWithoutOriginInput[]
    connectOrCreate?: SearchHistoryCreateOrConnectWithoutOriginInput | SearchHistoryCreateOrConnectWithoutOriginInput[]
    upsert?: SearchHistoryUpsertWithWhereUniqueWithoutOriginInput | SearchHistoryUpsertWithWhereUniqueWithoutOriginInput[]
    createMany?: SearchHistoryCreateManyOriginInputEnvelope
    set?: SearchHistoryWhereUniqueInput | SearchHistoryWhereUniqueInput[]
    disconnect?: SearchHistoryWhereUniqueInput | SearchHistoryWhereUniqueInput[]
    delete?: SearchHistoryWhereUniqueInput | SearchHistoryWhereUniqueInput[]
    connect?: SearchHistoryWhereUniqueInput | SearchHistoryWhereUniqueInput[]
    update?: SearchHistoryUpdateWithWhereUniqueWithoutOriginInput | SearchHistoryUpdateWithWhereUniqueWithoutOriginInput[]
    updateMany?: SearchHistoryUpdateManyWithWhereWithoutOriginInput | SearchHistoryUpdateManyWithWhereWithoutOriginInput[]
    deleteMany?: SearchHistoryScalarWhereInput | SearchHistoryScalarWhereInput[]
  }

  export type SearchHistoryUncheckedUpdateManyWithoutDestinationNestedInput = {
    create?: XOR<SearchHistoryCreateWithoutDestinationInput, SearchHistoryUncheckedCreateWithoutDestinationInput> | SearchHistoryCreateWithoutDestinationInput[] | SearchHistoryUncheckedCreateWithoutDestinationInput[]
    connectOrCreate?: SearchHistoryCreateOrConnectWithoutDestinationInput | SearchHistoryCreateOrConnectWithoutDestinationInput[]
    upsert?: SearchHistoryUpsertWithWhereUniqueWithoutDestinationInput | SearchHistoryUpsertWithWhereUniqueWithoutDestinationInput[]
    createMany?: SearchHistoryCreateManyDestinationInputEnvelope
    set?: SearchHistoryWhereUniqueInput | SearchHistoryWhereUniqueInput[]
    disconnect?: SearchHistoryWhereUniqueInput | SearchHistoryWhereUniqueInput[]
    delete?: SearchHistoryWhereUniqueInput | SearchHistoryWhereUniqueInput[]
    connect?: SearchHistoryWhereUniqueInput | SearchHistoryWhereUniqueInput[]
    update?: SearchHistoryUpdateWithWhereUniqueWithoutDestinationInput | SearchHistoryUpdateWithWhereUniqueWithoutDestinationInput[]
    updateMany?: SearchHistoryUpdateManyWithWhereWithoutDestinationInput | SearchHistoryUpdateManyWithWhereWithoutDestinationInput[]
    deleteMany?: SearchHistoryScalarWhereInput | SearchHistoryScalarWhereInput[]
  }

  export type TrainClassCreateNestedManyWithoutTrainInput = {
    create?: XOR<TrainClassCreateWithoutTrainInput, TrainClassUncheckedCreateWithoutTrainInput> | TrainClassCreateWithoutTrainInput[] | TrainClassUncheckedCreateWithoutTrainInput[]
    connectOrCreate?: TrainClassCreateOrConnectWithoutTrainInput | TrainClassCreateOrConnectWithoutTrainInput[]
    createMany?: TrainClassCreateManyTrainInputEnvelope
    connect?: TrainClassWhereUniqueInput | TrainClassWhereUniqueInput[]
  }

  export type RouteStopCreateNestedManyWithoutTrainInput = {
    create?: XOR<RouteStopCreateWithoutTrainInput, RouteStopUncheckedCreateWithoutTrainInput> | RouteStopCreateWithoutTrainInput[] | RouteStopUncheckedCreateWithoutTrainInput[]
    connectOrCreate?: RouteStopCreateOrConnectWithoutTrainInput | RouteStopCreateOrConnectWithoutTrainInput[]
    createMany?: RouteStopCreateManyTrainInputEnvelope
    connect?: RouteStopWhereUniqueInput | RouteStopWhereUniqueInput[]
  }

  export type ScheduleCreateNestedManyWithoutTrainInput = {
    create?: XOR<ScheduleCreateWithoutTrainInput, ScheduleUncheckedCreateWithoutTrainInput> | ScheduleCreateWithoutTrainInput[] | ScheduleUncheckedCreateWithoutTrainInput[]
    connectOrCreate?: ScheduleCreateOrConnectWithoutTrainInput | ScheduleCreateOrConnectWithoutTrainInput[]
    createMany?: ScheduleCreateManyTrainInputEnvelope
    connect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
  }

  export type TrainClassUncheckedCreateNestedManyWithoutTrainInput = {
    create?: XOR<TrainClassCreateWithoutTrainInput, TrainClassUncheckedCreateWithoutTrainInput> | TrainClassCreateWithoutTrainInput[] | TrainClassUncheckedCreateWithoutTrainInput[]
    connectOrCreate?: TrainClassCreateOrConnectWithoutTrainInput | TrainClassCreateOrConnectWithoutTrainInput[]
    createMany?: TrainClassCreateManyTrainInputEnvelope
    connect?: TrainClassWhereUniqueInput | TrainClassWhereUniqueInput[]
  }

  export type RouteStopUncheckedCreateNestedManyWithoutTrainInput = {
    create?: XOR<RouteStopCreateWithoutTrainInput, RouteStopUncheckedCreateWithoutTrainInput> | RouteStopCreateWithoutTrainInput[] | RouteStopUncheckedCreateWithoutTrainInput[]
    connectOrCreate?: RouteStopCreateOrConnectWithoutTrainInput | RouteStopCreateOrConnectWithoutTrainInput[]
    createMany?: RouteStopCreateManyTrainInputEnvelope
    connect?: RouteStopWhereUniqueInput | RouteStopWhereUniqueInput[]
  }

  export type ScheduleUncheckedCreateNestedManyWithoutTrainInput = {
    create?: XOR<ScheduleCreateWithoutTrainInput, ScheduleUncheckedCreateWithoutTrainInput> | ScheduleCreateWithoutTrainInput[] | ScheduleUncheckedCreateWithoutTrainInput[]
    connectOrCreate?: ScheduleCreateOrConnectWithoutTrainInput | ScheduleCreateOrConnectWithoutTrainInput[]
    createMany?: ScheduleCreateManyTrainInputEnvelope
    connect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
  }

  export type TrainClassUpdateManyWithoutTrainNestedInput = {
    create?: XOR<TrainClassCreateWithoutTrainInput, TrainClassUncheckedCreateWithoutTrainInput> | TrainClassCreateWithoutTrainInput[] | TrainClassUncheckedCreateWithoutTrainInput[]
    connectOrCreate?: TrainClassCreateOrConnectWithoutTrainInput | TrainClassCreateOrConnectWithoutTrainInput[]
    upsert?: TrainClassUpsertWithWhereUniqueWithoutTrainInput | TrainClassUpsertWithWhereUniqueWithoutTrainInput[]
    createMany?: TrainClassCreateManyTrainInputEnvelope
    set?: TrainClassWhereUniqueInput | TrainClassWhereUniqueInput[]
    disconnect?: TrainClassWhereUniqueInput | TrainClassWhereUniqueInput[]
    delete?: TrainClassWhereUniqueInput | TrainClassWhereUniqueInput[]
    connect?: TrainClassWhereUniqueInput | TrainClassWhereUniqueInput[]
    update?: TrainClassUpdateWithWhereUniqueWithoutTrainInput | TrainClassUpdateWithWhereUniqueWithoutTrainInput[]
    updateMany?: TrainClassUpdateManyWithWhereWithoutTrainInput | TrainClassUpdateManyWithWhereWithoutTrainInput[]
    deleteMany?: TrainClassScalarWhereInput | TrainClassScalarWhereInput[]
  }

  export type RouteStopUpdateManyWithoutTrainNestedInput = {
    create?: XOR<RouteStopCreateWithoutTrainInput, RouteStopUncheckedCreateWithoutTrainInput> | RouteStopCreateWithoutTrainInput[] | RouteStopUncheckedCreateWithoutTrainInput[]
    connectOrCreate?: RouteStopCreateOrConnectWithoutTrainInput | RouteStopCreateOrConnectWithoutTrainInput[]
    upsert?: RouteStopUpsertWithWhereUniqueWithoutTrainInput | RouteStopUpsertWithWhereUniqueWithoutTrainInput[]
    createMany?: RouteStopCreateManyTrainInputEnvelope
    set?: RouteStopWhereUniqueInput | RouteStopWhereUniqueInput[]
    disconnect?: RouteStopWhereUniqueInput | RouteStopWhereUniqueInput[]
    delete?: RouteStopWhereUniqueInput | RouteStopWhereUniqueInput[]
    connect?: RouteStopWhereUniqueInput | RouteStopWhereUniqueInput[]
    update?: RouteStopUpdateWithWhereUniqueWithoutTrainInput | RouteStopUpdateWithWhereUniqueWithoutTrainInput[]
    updateMany?: RouteStopUpdateManyWithWhereWithoutTrainInput | RouteStopUpdateManyWithWhereWithoutTrainInput[]
    deleteMany?: RouteStopScalarWhereInput | RouteStopScalarWhereInput[]
  }

  export type ScheduleUpdateManyWithoutTrainNestedInput = {
    create?: XOR<ScheduleCreateWithoutTrainInput, ScheduleUncheckedCreateWithoutTrainInput> | ScheduleCreateWithoutTrainInput[] | ScheduleUncheckedCreateWithoutTrainInput[]
    connectOrCreate?: ScheduleCreateOrConnectWithoutTrainInput | ScheduleCreateOrConnectWithoutTrainInput[]
    upsert?: ScheduleUpsertWithWhereUniqueWithoutTrainInput | ScheduleUpsertWithWhereUniqueWithoutTrainInput[]
    createMany?: ScheduleCreateManyTrainInputEnvelope
    set?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    disconnect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    delete?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    connect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    update?: ScheduleUpdateWithWhereUniqueWithoutTrainInput | ScheduleUpdateWithWhereUniqueWithoutTrainInput[]
    updateMany?: ScheduleUpdateManyWithWhereWithoutTrainInput | ScheduleUpdateManyWithWhereWithoutTrainInput[]
    deleteMany?: ScheduleScalarWhereInput | ScheduleScalarWhereInput[]
  }

  export type TrainClassUncheckedUpdateManyWithoutTrainNestedInput = {
    create?: XOR<TrainClassCreateWithoutTrainInput, TrainClassUncheckedCreateWithoutTrainInput> | TrainClassCreateWithoutTrainInput[] | TrainClassUncheckedCreateWithoutTrainInput[]
    connectOrCreate?: TrainClassCreateOrConnectWithoutTrainInput | TrainClassCreateOrConnectWithoutTrainInput[]
    upsert?: TrainClassUpsertWithWhereUniqueWithoutTrainInput | TrainClassUpsertWithWhereUniqueWithoutTrainInput[]
    createMany?: TrainClassCreateManyTrainInputEnvelope
    set?: TrainClassWhereUniqueInput | TrainClassWhereUniqueInput[]
    disconnect?: TrainClassWhereUniqueInput | TrainClassWhereUniqueInput[]
    delete?: TrainClassWhereUniqueInput | TrainClassWhereUniqueInput[]
    connect?: TrainClassWhereUniqueInput | TrainClassWhereUniqueInput[]
    update?: TrainClassUpdateWithWhereUniqueWithoutTrainInput | TrainClassUpdateWithWhereUniqueWithoutTrainInput[]
    updateMany?: TrainClassUpdateManyWithWhereWithoutTrainInput | TrainClassUpdateManyWithWhereWithoutTrainInput[]
    deleteMany?: TrainClassScalarWhereInput | TrainClassScalarWhereInput[]
  }

  export type RouteStopUncheckedUpdateManyWithoutTrainNestedInput = {
    create?: XOR<RouteStopCreateWithoutTrainInput, RouteStopUncheckedCreateWithoutTrainInput> | RouteStopCreateWithoutTrainInput[] | RouteStopUncheckedCreateWithoutTrainInput[]
    connectOrCreate?: RouteStopCreateOrConnectWithoutTrainInput | RouteStopCreateOrConnectWithoutTrainInput[]
    upsert?: RouteStopUpsertWithWhereUniqueWithoutTrainInput | RouteStopUpsertWithWhereUniqueWithoutTrainInput[]
    createMany?: RouteStopCreateManyTrainInputEnvelope
    set?: RouteStopWhereUniqueInput | RouteStopWhereUniqueInput[]
    disconnect?: RouteStopWhereUniqueInput | RouteStopWhereUniqueInput[]
    delete?: RouteStopWhereUniqueInput | RouteStopWhereUniqueInput[]
    connect?: RouteStopWhereUniqueInput | RouteStopWhereUniqueInput[]
    update?: RouteStopUpdateWithWhereUniqueWithoutTrainInput | RouteStopUpdateWithWhereUniqueWithoutTrainInput[]
    updateMany?: RouteStopUpdateManyWithWhereWithoutTrainInput | RouteStopUpdateManyWithWhereWithoutTrainInput[]
    deleteMany?: RouteStopScalarWhereInput | RouteStopScalarWhereInput[]
  }

  export type ScheduleUncheckedUpdateManyWithoutTrainNestedInput = {
    create?: XOR<ScheduleCreateWithoutTrainInput, ScheduleUncheckedCreateWithoutTrainInput> | ScheduleCreateWithoutTrainInput[] | ScheduleUncheckedCreateWithoutTrainInput[]
    connectOrCreate?: ScheduleCreateOrConnectWithoutTrainInput | ScheduleCreateOrConnectWithoutTrainInput[]
    upsert?: ScheduleUpsertWithWhereUniqueWithoutTrainInput | ScheduleUpsertWithWhereUniqueWithoutTrainInput[]
    createMany?: ScheduleCreateManyTrainInputEnvelope
    set?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    disconnect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    delete?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    connect?: ScheduleWhereUniqueInput | ScheduleWhereUniqueInput[]
    update?: ScheduleUpdateWithWhereUniqueWithoutTrainInput | ScheduleUpdateWithWhereUniqueWithoutTrainInput[]
    updateMany?: ScheduleUpdateManyWithWhereWithoutTrainInput | ScheduleUpdateManyWithWhereWithoutTrainInput[]
    deleteMany?: ScheduleScalarWhereInput | ScheduleScalarWhereInput[]
  }

  export type TrainCreateNestedOneWithoutClassesInput = {
    create?: XOR<TrainCreateWithoutClassesInput, TrainUncheckedCreateWithoutClassesInput>
    connectOrCreate?: TrainCreateOrConnectWithoutClassesInput
    connect?: TrainWhereUniqueInput
  }

  export type TrainUpdateOneRequiredWithoutClassesNestedInput = {
    create?: XOR<TrainCreateWithoutClassesInput, TrainUncheckedCreateWithoutClassesInput>
    connectOrCreate?: TrainCreateOrConnectWithoutClassesInput
    upsert?: TrainUpsertWithoutClassesInput
    connect?: TrainWhereUniqueInput
    update?: XOR<XOR<TrainUpdateToOneWithWhereWithoutClassesInput, TrainUpdateWithoutClassesInput>, TrainUncheckedUpdateWithoutClassesInput>
  }

  export type TrainCreateNestedOneWithoutRouteStopsInput = {
    create?: XOR<TrainCreateWithoutRouteStopsInput, TrainUncheckedCreateWithoutRouteStopsInput>
    connectOrCreate?: TrainCreateOrConnectWithoutRouteStopsInput
    connect?: TrainWhereUniqueInput
  }

  export type StationCreateNestedOneWithoutRoutesInput = {
    create?: XOR<StationCreateWithoutRoutesInput, StationUncheckedCreateWithoutRoutesInput>
    connectOrCreate?: StationCreateOrConnectWithoutRoutesInput
    connect?: StationWhereUniqueInput
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type TrainUpdateOneRequiredWithoutRouteStopsNestedInput = {
    create?: XOR<TrainCreateWithoutRouteStopsInput, TrainUncheckedCreateWithoutRouteStopsInput>
    connectOrCreate?: TrainCreateOrConnectWithoutRouteStopsInput
    upsert?: TrainUpsertWithoutRouteStopsInput
    connect?: TrainWhereUniqueInput
    update?: XOR<XOR<TrainUpdateToOneWithWhereWithoutRouteStopsInput, TrainUpdateWithoutRouteStopsInput>, TrainUncheckedUpdateWithoutRouteStopsInput>
  }

  export type StationUpdateOneRequiredWithoutRoutesNestedInput = {
    create?: XOR<StationCreateWithoutRoutesInput, StationUncheckedCreateWithoutRoutesInput>
    connectOrCreate?: StationCreateOrConnectWithoutRoutesInput
    upsert?: StationUpsertWithoutRoutesInput
    connect?: StationWhereUniqueInput
    update?: XOR<XOR<StationUpdateToOneWithWhereWithoutRoutesInput, StationUpdateWithoutRoutesInput>, StationUncheckedUpdateWithoutRoutesInput>
  }

  export type TrainCreateNestedOneWithoutSchedulesInput = {
    create?: XOR<TrainCreateWithoutSchedulesInput, TrainUncheckedCreateWithoutSchedulesInput>
    connectOrCreate?: TrainCreateOrConnectWithoutSchedulesInput
    connect?: TrainWhereUniqueInput
  }

  export type StationCreateNestedOneWithoutDepartureSchedulesInput = {
    create?: XOR<StationCreateWithoutDepartureSchedulesInput, StationUncheckedCreateWithoutDepartureSchedulesInput>
    connectOrCreate?: StationCreateOrConnectWithoutDepartureSchedulesInput
    connect?: StationWhereUniqueInput
  }

  export type StationCreateNestedOneWithoutArrivalSchedulesInput = {
    create?: XOR<StationCreateWithoutArrivalSchedulesInput, StationUncheckedCreateWithoutArrivalSchedulesInput>
    connectOrCreate?: StationCreateOrConnectWithoutArrivalSchedulesInput
    connect?: StationWhereUniqueInput
  }

  export type BookingCreateNestedManyWithoutScheduleInput = {
    create?: XOR<BookingCreateWithoutScheduleInput, BookingUncheckedCreateWithoutScheduleInput> | BookingCreateWithoutScheduleInput[] | BookingUncheckedCreateWithoutScheduleInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutScheduleInput | BookingCreateOrConnectWithoutScheduleInput[]
    createMany?: BookingCreateManyScheduleInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type BookingUncheckedCreateNestedManyWithoutScheduleInput = {
    create?: XOR<BookingCreateWithoutScheduleInput, BookingUncheckedCreateWithoutScheduleInput> | BookingCreateWithoutScheduleInput[] | BookingUncheckedCreateWithoutScheduleInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutScheduleInput | BookingCreateOrConnectWithoutScheduleInput[]
    createMany?: BookingCreateManyScheduleInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type TrainUpdateOneRequiredWithoutSchedulesNestedInput = {
    create?: XOR<TrainCreateWithoutSchedulesInput, TrainUncheckedCreateWithoutSchedulesInput>
    connectOrCreate?: TrainCreateOrConnectWithoutSchedulesInput
    upsert?: TrainUpsertWithoutSchedulesInput
    connect?: TrainWhereUniqueInput
    update?: XOR<XOR<TrainUpdateToOneWithWhereWithoutSchedulesInput, TrainUpdateWithoutSchedulesInput>, TrainUncheckedUpdateWithoutSchedulesInput>
  }

  export type StationUpdateOneRequiredWithoutDepartureSchedulesNestedInput = {
    create?: XOR<StationCreateWithoutDepartureSchedulesInput, StationUncheckedCreateWithoutDepartureSchedulesInput>
    connectOrCreate?: StationCreateOrConnectWithoutDepartureSchedulesInput
    upsert?: StationUpsertWithoutDepartureSchedulesInput
    connect?: StationWhereUniqueInput
    update?: XOR<XOR<StationUpdateToOneWithWhereWithoutDepartureSchedulesInput, StationUpdateWithoutDepartureSchedulesInput>, StationUncheckedUpdateWithoutDepartureSchedulesInput>
  }

  export type StationUpdateOneRequiredWithoutArrivalSchedulesNestedInput = {
    create?: XOR<StationCreateWithoutArrivalSchedulesInput, StationUncheckedCreateWithoutArrivalSchedulesInput>
    connectOrCreate?: StationCreateOrConnectWithoutArrivalSchedulesInput
    upsert?: StationUpsertWithoutArrivalSchedulesInput
    connect?: StationWhereUniqueInput
    update?: XOR<XOR<StationUpdateToOneWithWhereWithoutArrivalSchedulesInput, StationUpdateWithoutArrivalSchedulesInput>, StationUncheckedUpdateWithoutArrivalSchedulesInput>
  }

  export type BookingUpdateManyWithoutScheduleNestedInput = {
    create?: XOR<BookingCreateWithoutScheduleInput, BookingUncheckedCreateWithoutScheduleInput> | BookingCreateWithoutScheduleInput[] | BookingUncheckedCreateWithoutScheduleInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutScheduleInput | BookingCreateOrConnectWithoutScheduleInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutScheduleInput | BookingUpsertWithWhereUniqueWithoutScheduleInput[]
    createMany?: BookingCreateManyScheduleInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutScheduleInput | BookingUpdateWithWhereUniqueWithoutScheduleInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutScheduleInput | BookingUpdateManyWithWhereWithoutScheduleInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type BookingUncheckedUpdateManyWithoutScheduleNestedInput = {
    create?: XOR<BookingCreateWithoutScheduleInput, BookingUncheckedCreateWithoutScheduleInput> | BookingCreateWithoutScheduleInput[] | BookingUncheckedCreateWithoutScheduleInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutScheduleInput | BookingCreateOrConnectWithoutScheduleInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutScheduleInput | BookingUpsertWithWhereUniqueWithoutScheduleInput[]
    createMany?: BookingCreateManyScheduleInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutScheduleInput | BookingUpdateWithWhereUniqueWithoutScheduleInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutScheduleInput | BookingUpdateManyWithWhereWithoutScheduleInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type StationCreateNestedOneWithoutFavoriteOriginRoutesInput = {
    create?: XOR<StationCreateWithoutFavoriteOriginRoutesInput, StationUncheckedCreateWithoutFavoriteOriginRoutesInput>
    connectOrCreate?: StationCreateOrConnectWithoutFavoriteOriginRoutesInput
    connect?: StationWhereUniqueInput
  }

  export type StationCreateNestedOneWithoutFavoriteDestinationRoutesInput = {
    create?: XOR<StationCreateWithoutFavoriteDestinationRoutesInput, StationUncheckedCreateWithoutFavoriteDestinationRoutesInput>
    connectOrCreate?: StationCreateOrConnectWithoutFavoriteDestinationRoutesInput
    connect?: StationWhereUniqueInput
  }

  export type StationUpdateOneRequiredWithoutFavoriteOriginRoutesNestedInput = {
    create?: XOR<StationCreateWithoutFavoriteOriginRoutesInput, StationUncheckedCreateWithoutFavoriteOriginRoutesInput>
    connectOrCreate?: StationCreateOrConnectWithoutFavoriteOriginRoutesInput
    upsert?: StationUpsertWithoutFavoriteOriginRoutesInput
    connect?: StationWhereUniqueInput
    update?: XOR<XOR<StationUpdateToOneWithWhereWithoutFavoriteOriginRoutesInput, StationUpdateWithoutFavoriteOriginRoutesInput>, StationUncheckedUpdateWithoutFavoriteOriginRoutesInput>
  }

  export type StationUpdateOneRequiredWithoutFavoriteDestinationRoutesNestedInput = {
    create?: XOR<StationCreateWithoutFavoriteDestinationRoutesInput, StationUncheckedCreateWithoutFavoriteDestinationRoutesInput>
    connectOrCreate?: StationCreateOrConnectWithoutFavoriteDestinationRoutesInput
    upsert?: StationUpsertWithoutFavoriteDestinationRoutesInput
    connect?: StationWhereUniqueInput
    update?: XOR<XOR<StationUpdateToOneWithWhereWithoutFavoriteDestinationRoutesInput, StationUpdateWithoutFavoriteDestinationRoutesInput>, StationUncheckedUpdateWithoutFavoriteDestinationRoutesInput>
  }

  export type StationCreateNestedOneWithoutHistoryOriginRoutesInput = {
    create?: XOR<StationCreateWithoutHistoryOriginRoutesInput, StationUncheckedCreateWithoutHistoryOriginRoutesInput>
    connectOrCreate?: StationCreateOrConnectWithoutHistoryOriginRoutesInput
    connect?: StationWhereUniqueInput
  }

  export type StationCreateNestedOneWithoutHistoryDestinationRoutesInput = {
    create?: XOR<StationCreateWithoutHistoryDestinationRoutesInput, StationUncheckedCreateWithoutHistoryDestinationRoutesInput>
    connectOrCreate?: StationCreateOrConnectWithoutHistoryDestinationRoutesInput
    connect?: StationWhereUniqueInput
  }

  export type StationUpdateOneRequiredWithoutHistoryOriginRoutesNestedInput = {
    create?: XOR<StationCreateWithoutHistoryOriginRoutesInput, StationUncheckedCreateWithoutHistoryOriginRoutesInput>
    connectOrCreate?: StationCreateOrConnectWithoutHistoryOriginRoutesInput
    upsert?: StationUpsertWithoutHistoryOriginRoutesInput
    connect?: StationWhereUniqueInput
    update?: XOR<XOR<StationUpdateToOneWithWhereWithoutHistoryOriginRoutesInput, StationUpdateWithoutHistoryOriginRoutesInput>, StationUncheckedUpdateWithoutHistoryOriginRoutesInput>
  }

  export type StationUpdateOneRequiredWithoutHistoryDestinationRoutesNestedInput = {
    create?: XOR<StationCreateWithoutHistoryDestinationRoutesInput, StationUncheckedCreateWithoutHistoryDestinationRoutesInput>
    connectOrCreate?: StationCreateOrConnectWithoutHistoryDestinationRoutesInput
    upsert?: StationUpsertWithoutHistoryDestinationRoutesInput
    connect?: StationWhereUniqueInput
    update?: XOR<XOR<StationUpdateToOneWithWhereWithoutHistoryDestinationRoutesInput, StationUpdateWithoutHistoryDestinationRoutesInput>, StationUncheckedUpdateWithoutHistoryDestinationRoutesInput>
  }

  export type ScheduleCreateNestedOneWithoutBookingsInput = {
    create?: XOR<ScheduleCreateWithoutBookingsInput, ScheduleUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: ScheduleCreateOrConnectWithoutBookingsInput
    connect?: ScheduleWhereUniqueInput
  }

  export type PaymentCreateNestedOneWithoutBookingInput = {
    create?: XOR<PaymentCreateWithoutBookingInput, PaymentUncheckedCreateWithoutBookingInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutBookingInput
    connect?: PaymentWhereUniqueInput
  }

  export type PaymentUncheckedCreateNestedOneWithoutBookingInput = {
    create?: XOR<PaymentCreateWithoutBookingInput, PaymentUncheckedCreateWithoutBookingInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutBookingInput
    connect?: PaymentWhereUniqueInput
  }

  export type ScheduleUpdateOneRequiredWithoutBookingsNestedInput = {
    create?: XOR<ScheduleCreateWithoutBookingsInput, ScheduleUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: ScheduleCreateOrConnectWithoutBookingsInput
    upsert?: ScheduleUpsertWithoutBookingsInput
    connect?: ScheduleWhereUniqueInput
    update?: XOR<XOR<ScheduleUpdateToOneWithWhereWithoutBookingsInput, ScheduleUpdateWithoutBookingsInput>, ScheduleUncheckedUpdateWithoutBookingsInput>
  }

  export type PaymentUpdateOneWithoutBookingNestedInput = {
    create?: XOR<PaymentCreateWithoutBookingInput, PaymentUncheckedCreateWithoutBookingInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutBookingInput
    upsert?: PaymentUpsertWithoutBookingInput
    disconnect?: PaymentWhereInput | boolean
    delete?: PaymentWhereInput | boolean
    connect?: PaymentWhereUniqueInput
    update?: XOR<XOR<PaymentUpdateToOneWithWhereWithoutBookingInput, PaymentUpdateWithoutBookingInput>, PaymentUncheckedUpdateWithoutBookingInput>
  }

  export type PaymentUncheckedUpdateOneWithoutBookingNestedInput = {
    create?: XOR<PaymentCreateWithoutBookingInput, PaymentUncheckedCreateWithoutBookingInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutBookingInput
    upsert?: PaymentUpsertWithoutBookingInput
    disconnect?: PaymentWhereInput | boolean
    delete?: PaymentWhereInput | boolean
    connect?: PaymentWhereUniqueInput
    update?: XOR<XOR<PaymentUpdateToOneWithWhereWithoutBookingInput, PaymentUpdateWithoutBookingInput>, PaymentUncheckedUpdateWithoutBookingInput>
  }

  export type BookingCreateNestedOneWithoutPaymentInput = {
    create?: XOR<BookingCreateWithoutPaymentInput, BookingUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: BookingCreateOrConnectWithoutPaymentInput
    connect?: BookingWhereUniqueInput
  }

  export type BookingUpdateOneRequiredWithoutPaymentNestedInput = {
    create?: XOR<BookingCreateWithoutPaymentInput, BookingUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: BookingCreateOrConnectWithoutPaymentInput
    upsert?: BookingUpsertWithoutPaymentInput
    connect?: BookingWhereUniqueInput
    update?: XOR<XOR<BookingUpdateToOneWithWhereWithoutPaymentInput, BookingUpdateWithoutPaymentInput>, BookingUncheckedUpdateWithoutPaymentInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type RouteStopCreateWithoutStationInput = {
    stopOrder: number
    arrivalTime?: Date | string | null
    departureTime?: Date | string | null
    train: TrainCreateNestedOneWithoutRouteStopsInput
  }

  export type RouteStopUncheckedCreateWithoutStationInput = {
    id?: number
    stopOrder: number
    trainId: number
    arrivalTime?: Date | string | null
    departureTime?: Date | string | null
  }

  export type RouteStopCreateOrConnectWithoutStationInput = {
    where: RouteStopWhereUniqueInput
    create: XOR<RouteStopCreateWithoutStationInput, RouteStopUncheckedCreateWithoutStationInput>
  }

  export type RouteStopCreateManyStationInputEnvelope = {
    data: RouteStopCreateManyStationInput | RouteStopCreateManyStationInput[]
  }

  export type ScheduleCreateWithoutDepartureStationInput = {
    departureTime: Date | string
    arrivalTime: Date | string
    train: TrainCreateNestedOneWithoutSchedulesInput
    arrivalStation: StationCreateNestedOneWithoutArrivalSchedulesInput
    bookings?: BookingCreateNestedManyWithoutScheduleInput
  }

  export type ScheduleUncheckedCreateWithoutDepartureStationInput = {
    id?: number
    departureTime: Date | string
    arrivalTime: Date | string
    trainId: number
    arrivalStationId: number
    bookings?: BookingUncheckedCreateNestedManyWithoutScheduleInput
  }

  export type ScheduleCreateOrConnectWithoutDepartureStationInput = {
    where: ScheduleWhereUniqueInput
    create: XOR<ScheduleCreateWithoutDepartureStationInput, ScheduleUncheckedCreateWithoutDepartureStationInput>
  }

  export type ScheduleCreateManyDepartureStationInputEnvelope = {
    data: ScheduleCreateManyDepartureStationInput | ScheduleCreateManyDepartureStationInput[]
  }

  export type ScheduleCreateWithoutArrivalStationInput = {
    departureTime: Date | string
    arrivalTime: Date | string
    train: TrainCreateNestedOneWithoutSchedulesInput
    departureStation: StationCreateNestedOneWithoutDepartureSchedulesInput
    bookings?: BookingCreateNestedManyWithoutScheduleInput
  }

  export type ScheduleUncheckedCreateWithoutArrivalStationInput = {
    id?: number
    departureTime: Date | string
    arrivalTime: Date | string
    trainId: number
    departureStationId: number
    bookings?: BookingUncheckedCreateNestedManyWithoutScheduleInput
  }

  export type ScheduleCreateOrConnectWithoutArrivalStationInput = {
    where: ScheduleWhereUniqueInput
    create: XOR<ScheduleCreateWithoutArrivalStationInput, ScheduleUncheckedCreateWithoutArrivalStationInput>
  }

  export type ScheduleCreateManyArrivalStationInputEnvelope = {
    data: ScheduleCreateManyArrivalStationInput | ScheduleCreateManyArrivalStationInput[]
  }

  export type FavoriteRouteCreateWithoutOriginInput = {
    userId: string
    destination: StationCreateNestedOneWithoutFavoriteDestinationRoutesInput
  }

  export type FavoriteRouteUncheckedCreateWithoutOriginInput = {
    id?: number
    userId: string
    destinationStationId: number
  }

  export type FavoriteRouteCreateOrConnectWithoutOriginInput = {
    where: FavoriteRouteWhereUniqueInput
    create: XOR<FavoriteRouteCreateWithoutOriginInput, FavoriteRouteUncheckedCreateWithoutOriginInput>
  }

  export type FavoriteRouteCreateManyOriginInputEnvelope = {
    data: FavoriteRouteCreateManyOriginInput | FavoriteRouteCreateManyOriginInput[]
  }

  export type FavoriteRouteCreateWithoutDestinationInput = {
    userId: string
    origin: StationCreateNestedOneWithoutFavoriteOriginRoutesInput
  }

  export type FavoriteRouteUncheckedCreateWithoutDestinationInput = {
    id?: number
    userId: string
    originStationId: number
  }

  export type FavoriteRouteCreateOrConnectWithoutDestinationInput = {
    where: FavoriteRouteWhereUniqueInput
    create: XOR<FavoriteRouteCreateWithoutDestinationInput, FavoriteRouteUncheckedCreateWithoutDestinationInput>
  }

  export type FavoriteRouteCreateManyDestinationInputEnvelope = {
    data: FavoriteRouteCreateManyDestinationInput | FavoriteRouteCreateManyDestinationInput[]
  }

  export type SearchHistoryCreateWithoutOriginInput = {
    userId: string
    searchDate?: Date | string
    destination: StationCreateNestedOneWithoutHistoryDestinationRoutesInput
  }

  export type SearchHistoryUncheckedCreateWithoutOriginInput = {
    id?: number
    userId: string
    searchDate?: Date | string
    destinationStationId: number
  }

  export type SearchHistoryCreateOrConnectWithoutOriginInput = {
    where: SearchHistoryWhereUniqueInput
    create: XOR<SearchHistoryCreateWithoutOriginInput, SearchHistoryUncheckedCreateWithoutOriginInput>
  }

  export type SearchHistoryCreateManyOriginInputEnvelope = {
    data: SearchHistoryCreateManyOriginInput | SearchHistoryCreateManyOriginInput[]
  }

  export type SearchHistoryCreateWithoutDestinationInput = {
    userId: string
    searchDate?: Date | string
    origin: StationCreateNestedOneWithoutHistoryOriginRoutesInput
  }

  export type SearchHistoryUncheckedCreateWithoutDestinationInput = {
    id?: number
    userId: string
    searchDate?: Date | string
    originStationId: number
  }

  export type SearchHistoryCreateOrConnectWithoutDestinationInput = {
    where: SearchHistoryWhereUniqueInput
    create: XOR<SearchHistoryCreateWithoutDestinationInput, SearchHistoryUncheckedCreateWithoutDestinationInput>
  }

  export type SearchHistoryCreateManyDestinationInputEnvelope = {
    data: SearchHistoryCreateManyDestinationInput | SearchHistoryCreateManyDestinationInput[]
  }

  export type RouteStopUpsertWithWhereUniqueWithoutStationInput = {
    where: RouteStopWhereUniqueInput
    update: XOR<RouteStopUpdateWithoutStationInput, RouteStopUncheckedUpdateWithoutStationInput>
    create: XOR<RouteStopCreateWithoutStationInput, RouteStopUncheckedCreateWithoutStationInput>
  }

  export type RouteStopUpdateWithWhereUniqueWithoutStationInput = {
    where: RouteStopWhereUniqueInput
    data: XOR<RouteStopUpdateWithoutStationInput, RouteStopUncheckedUpdateWithoutStationInput>
  }

  export type RouteStopUpdateManyWithWhereWithoutStationInput = {
    where: RouteStopScalarWhereInput
    data: XOR<RouteStopUpdateManyMutationInput, RouteStopUncheckedUpdateManyWithoutStationInput>
  }

  export type RouteStopScalarWhereInput = {
    AND?: RouteStopScalarWhereInput | RouteStopScalarWhereInput[]
    OR?: RouteStopScalarWhereInput[]
    NOT?: RouteStopScalarWhereInput | RouteStopScalarWhereInput[]
    id?: IntFilter<"RouteStop"> | number
    stopOrder?: IntFilter<"RouteStop"> | number
    trainId?: IntFilter<"RouteStop"> | number
    stationId?: IntFilter<"RouteStop"> | number
    arrivalTime?: DateTimeNullableFilter<"RouteStop"> | Date | string | null
    departureTime?: DateTimeNullableFilter<"RouteStop"> | Date | string | null
  }

  export type ScheduleUpsertWithWhereUniqueWithoutDepartureStationInput = {
    where: ScheduleWhereUniqueInput
    update: XOR<ScheduleUpdateWithoutDepartureStationInput, ScheduleUncheckedUpdateWithoutDepartureStationInput>
    create: XOR<ScheduleCreateWithoutDepartureStationInput, ScheduleUncheckedCreateWithoutDepartureStationInput>
  }

  export type ScheduleUpdateWithWhereUniqueWithoutDepartureStationInput = {
    where: ScheduleWhereUniqueInput
    data: XOR<ScheduleUpdateWithoutDepartureStationInput, ScheduleUncheckedUpdateWithoutDepartureStationInput>
  }

  export type ScheduleUpdateManyWithWhereWithoutDepartureStationInput = {
    where: ScheduleScalarWhereInput
    data: XOR<ScheduleUpdateManyMutationInput, ScheduleUncheckedUpdateManyWithoutDepartureStationInput>
  }

  export type ScheduleScalarWhereInput = {
    AND?: ScheduleScalarWhereInput | ScheduleScalarWhereInput[]
    OR?: ScheduleScalarWhereInput[]
    NOT?: ScheduleScalarWhereInput | ScheduleScalarWhereInput[]
    id?: IntFilter<"Schedule"> | number
    departureTime?: DateTimeFilter<"Schedule"> | Date | string
    arrivalTime?: DateTimeFilter<"Schedule"> | Date | string
    trainId?: IntFilter<"Schedule"> | number
    departureStationId?: IntFilter<"Schedule"> | number
    arrivalStationId?: IntFilter<"Schedule"> | number
  }

  export type ScheduleUpsertWithWhereUniqueWithoutArrivalStationInput = {
    where: ScheduleWhereUniqueInput
    update: XOR<ScheduleUpdateWithoutArrivalStationInput, ScheduleUncheckedUpdateWithoutArrivalStationInput>
    create: XOR<ScheduleCreateWithoutArrivalStationInput, ScheduleUncheckedCreateWithoutArrivalStationInput>
  }

  export type ScheduleUpdateWithWhereUniqueWithoutArrivalStationInput = {
    where: ScheduleWhereUniqueInput
    data: XOR<ScheduleUpdateWithoutArrivalStationInput, ScheduleUncheckedUpdateWithoutArrivalStationInput>
  }

  export type ScheduleUpdateManyWithWhereWithoutArrivalStationInput = {
    where: ScheduleScalarWhereInput
    data: XOR<ScheduleUpdateManyMutationInput, ScheduleUncheckedUpdateManyWithoutArrivalStationInput>
  }

  export type FavoriteRouteUpsertWithWhereUniqueWithoutOriginInput = {
    where: FavoriteRouteWhereUniqueInput
    update: XOR<FavoriteRouteUpdateWithoutOriginInput, FavoriteRouteUncheckedUpdateWithoutOriginInput>
    create: XOR<FavoriteRouteCreateWithoutOriginInput, FavoriteRouteUncheckedCreateWithoutOriginInput>
  }

  export type FavoriteRouteUpdateWithWhereUniqueWithoutOriginInput = {
    where: FavoriteRouteWhereUniqueInput
    data: XOR<FavoriteRouteUpdateWithoutOriginInput, FavoriteRouteUncheckedUpdateWithoutOriginInput>
  }

  export type FavoriteRouteUpdateManyWithWhereWithoutOriginInput = {
    where: FavoriteRouteScalarWhereInput
    data: XOR<FavoriteRouteUpdateManyMutationInput, FavoriteRouteUncheckedUpdateManyWithoutOriginInput>
  }

  export type FavoriteRouteScalarWhereInput = {
    AND?: FavoriteRouteScalarWhereInput | FavoriteRouteScalarWhereInput[]
    OR?: FavoriteRouteScalarWhereInput[]
    NOT?: FavoriteRouteScalarWhereInput | FavoriteRouteScalarWhereInput[]
    id?: IntFilter<"FavoriteRoute"> | number
    userId?: StringFilter<"FavoriteRoute"> | string
    originStationId?: IntFilter<"FavoriteRoute"> | number
    destinationStationId?: IntFilter<"FavoriteRoute"> | number
  }

  export type FavoriteRouteUpsertWithWhereUniqueWithoutDestinationInput = {
    where: FavoriteRouteWhereUniqueInput
    update: XOR<FavoriteRouteUpdateWithoutDestinationInput, FavoriteRouteUncheckedUpdateWithoutDestinationInput>
    create: XOR<FavoriteRouteCreateWithoutDestinationInput, FavoriteRouteUncheckedCreateWithoutDestinationInput>
  }

  export type FavoriteRouteUpdateWithWhereUniqueWithoutDestinationInput = {
    where: FavoriteRouteWhereUniqueInput
    data: XOR<FavoriteRouteUpdateWithoutDestinationInput, FavoriteRouteUncheckedUpdateWithoutDestinationInput>
  }

  export type FavoriteRouteUpdateManyWithWhereWithoutDestinationInput = {
    where: FavoriteRouteScalarWhereInput
    data: XOR<FavoriteRouteUpdateManyMutationInput, FavoriteRouteUncheckedUpdateManyWithoutDestinationInput>
  }

  export type SearchHistoryUpsertWithWhereUniqueWithoutOriginInput = {
    where: SearchHistoryWhereUniqueInput
    update: XOR<SearchHistoryUpdateWithoutOriginInput, SearchHistoryUncheckedUpdateWithoutOriginInput>
    create: XOR<SearchHistoryCreateWithoutOriginInput, SearchHistoryUncheckedCreateWithoutOriginInput>
  }

  export type SearchHistoryUpdateWithWhereUniqueWithoutOriginInput = {
    where: SearchHistoryWhereUniqueInput
    data: XOR<SearchHistoryUpdateWithoutOriginInput, SearchHistoryUncheckedUpdateWithoutOriginInput>
  }

  export type SearchHistoryUpdateManyWithWhereWithoutOriginInput = {
    where: SearchHistoryScalarWhereInput
    data: XOR<SearchHistoryUpdateManyMutationInput, SearchHistoryUncheckedUpdateManyWithoutOriginInput>
  }

  export type SearchHistoryScalarWhereInput = {
    AND?: SearchHistoryScalarWhereInput | SearchHistoryScalarWhereInput[]
    OR?: SearchHistoryScalarWhereInput[]
    NOT?: SearchHistoryScalarWhereInput | SearchHistoryScalarWhereInput[]
    id?: IntFilter<"SearchHistory"> | number
    userId?: StringFilter<"SearchHistory"> | string
    searchDate?: DateTimeFilter<"SearchHistory"> | Date | string
    originStationId?: IntFilter<"SearchHistory"> | number
    destinationStationId?: IntFilter<"SearchHistory"> | number
  }

  export type SearchHistoryUpsertWithWhereUniqueWithoutDestinationInput = {
    where: SearchHistoryWhereUniqueInput
    update: XOR<SearchHistoryUpdateWithoutDestinationInput, SearchHistoryUncheckedUpdateWithoutDestinationInput>
    create: XOR<SearchHistoryCreateWithoutDestinationInput, SearchHistoryUncheckedCreateWithoutDestinationInput>
  }

  export type SearchHistoryUpdateWithWhereUniqueWithoutDestinationInput = {
    where: SearchHistoryWhereUniqueInput
    data: XOR<SearchHistoryUpdateWithoutDestinationInput, SearchHistoryUncheckedUpdateWithoutDestinationInput>
  }

  export type SearchHistoryUpdateManyWithWhereWithoutDestinationInput = {
    where: SearchHistoryScalarWhereInput
    data: XOR<SearchHistoryUpdateManyMutationInput, SearchHistoryUncheckedUpdateManyWithoutDestinationInput>
  }

  export type TrainClassCreateWithoutTrainInput = {
    className: string
    price: number
  }

  export type TrainClassUncheckedCreateWithoutTrainInput = {
    id?: number
    className: string
    price: number
  }

  export type TrainClassCreateOrConnectWithoutTrainInput = {
    where: TrainClassWhereUniqueInput
    create: XOR<TrainClassCreateWithoutTrainInput, TrainClassUncheckedCreateWithoutTrainInput>
  }

  export type TrainClassCreateManyTrainInputEnvelope = {
    data: TrainClassCreateManyTrainInput | TrainClassCreateManyTrainInput[]
  }

  export type RouteStopCreateWithoutTrainInput = {
    stopOrder: number
    arrivalTime?: Date | string | null
    departureTime?: Date | string | null
    station: StationCreateNestedOneWithoutRoutesInput
  }

  export type RouteStopUncheckedCreateWithoutTrainInput = {
    id?: number
    stopOrder: number
    stationId: number
    arrivalTime?: Date | string | null
    departureTime?: Date | string | null
  }

  export type RouteStopCreateOrConnectWithoutTrainInput = {
    where: RouteStopWhereUniqueInput
    create: XOR<RouteStopCreateWithoutTrainInput, RouteStopUncheckedCreateWithoutTrainInput>
  }

  export type RouteStopCreateManyTrainInputEnvelope = {
    data: RouteStopCreateManyTrainInput | RouteStopCreateManyTrainInput[]
  }

  export type ScheduleCreateWithoutTrainInput = {
    departureTime: Date | string
    arrivalTime: Date | string
    departureStation: StationCreateNestedOneWithoutDepartureSchedulesInput
    arrivalStation: StationCreateNestedOneWithoutArrivalSchedulesInput
    bookings?: BookingCreateNestedManyWithoutScheduleInput
  }

  export type ScheduleUncheckedCreateWithoutTrainInput = {
    id?: number
    departureTime: Date | string
    arrivalTime: Date | string
    departureStationId: number
    arrivalStationId: number
    bookings?: BookingUncheckedCreateNestedManyWithoutScheduleInput
  }

  export type ScheduleCreateOrConnectWithoutTrainInput = {
    where: ScheduleWhereUniqueInput
    create: XOR<ScheduleCreateWithoutTrainInput, ScheduleUncheckedCreateWithoutTrainInput>
  }

  export type ScheduleCreateManyTrainInputEnvelope = {
    data: ScheduleCreateManyTrainInput | ScheduleCreateManyTrainInput[]
  }

  export type TrainClassUpsertWithWhereUniqueWithoutTrainInput = {
    where: TrainClassWhereUniqueInput
    update: XOR<TrainClassUpdateWithoutTrainInput, TrainClassUncheckedUpdateWithoutTrainInput>
    create: XOR<TrainClassCreateWithoutTrainInput, TrainClassUncheckedCreateWithoutTrainInput>
  }

  export type TrainClassUpdateWithWhereUniqueWithoutTrainInput = {
    where: TrainClassWhereUniqueInput
    data: XOR<TrainClassUpdateWithoutTrainInput, TrainClassUncheckedUpdateWithoutTrainInput>
  }

  export type TrainClassUpdateManyWithWhereWithoutTrainInput = {
    where: TrainClassScalarWhereInput
    data: XOR<TrainClassUpdateManyMutationInput, TrainClassUncheckedUpdateManyWithoutTrainInput>
  }

  export type TrainClassScalarWhereInput = {
    AND?: TrainClassScalarWhereInput | TrainClassScalarWhereInput[]
    OR?: TrainClassScalarWhereInput[]
    NOT?: TrainClassScalarWhereInput | TrainClassScalarWhereInput[]
    id?: IntFilter<"TrainClass"> | number
    className?: StringFilter<"TrainClass"> | string
    price?: IntFilter<"TrainClass"> | number
    trainId?: IntFilter<"TrainClass"> | number
  }

  export type RouteStopUpsertWithWhereUniqueWithoutTrainInput = {
    where: RouteStopWhereUniqueInput
    update: XOR<RouteStopUpdateWithoutTrainInput, RouteStopUncheckedUpdateWithoutTrainInput>
    create: XOR<RouteStopCreateWithoutTrainInput, RouteStopUncheckedCreateWithoutTrainInput>
  }

  export type RouteStopUpdateWithWhereUniqueWithoutTrainInput = {
    where: RouteStopWhereUniqueInput
    data: XOR<RouteStopUpdateWithoutTrainInput, RouteStopUncheckedUpdateWithoutTrainInput>
  }

  export type RouteStopUpdateManyWithWhereWithoutTrainInput = {
    where: RouteStopScalarWhereInput
    data: XOR<RouteStopUpdateManyMutationInput, RouteStopUncheckedUpdateManyWithoutTrainInput>
  }

  export type ScheduleUpsertWithWhereUniqueWithoutTrainInput = {
    where: ScheduleWhereUniqueInput
    update: XOR<ScheduleUpdateWithoutTrainInput, ScheduleUncheckedUpdateWithoutTrainInput>
    create: XOR<ScheduleCreateWithoutTrainInput, ScheduleUncheckedCreateWithoutTrainInput>
  }

  export type ScheduleUpdateWithWhereUniqueWithoutTrainInput = {
    where: ScheduleWhereUniqueInput
    data: XOR<ScheduleUpdateWithoutTrainInput, ScheduleUncheckedUpdateWithoutTrainInput>
  }

  export type ScheduleUpdateManyWithWhereWithoutTrainInput = {
    where: ScheduleScalarWhereInput
    data: XOR<ScheduleUpdateManyMutationInput, ScheduleUncheckedUpdateManyWithoutTrainInput>
  }

  export type TrainCreateWithoutClassesInput = {
    name: string
    trainType: string
    routeStops?: RouteStopCreateNestedManyWithoutTrainInput
    schedules?: ScheduleCreateNestedManyWithoutTrainInput
  }

  export type TrainUncheckedCreateWithoutClassesInput = {
    id?: number
    name: string
    trainType: string
    routeStops?: RouteStopUncheckedCreateNestedManyWithoutTrainInput
    schedules?: ScheduleUncheckedCreateNestedManyWithoutTrainInput
  }

  export type TrainCreateOrConnectWithoutClassesInput = {
    where: TrainWhereUniqueInput
    create: XOR<TrainCreateWithoutClassesInput, TrainUncheckedCreateWithoutClassesInput>
  }

  export type TrainUpsertWithoutClassesInput = {
    update: XOR<TrainUpdateWithoutClassesInput, TrainUncheckedUpdateWithoutClassesInput>
    create: XOR<TrainCreateWithoutClassesInput, TrainUncheckedCreateWithoutClassesInput>
    where?: TrainWhereInput
  }

  export type TrainUpdateToOneWithWhereWithoutClassesInput = {
    where?: TrainWhereInput
    data: XOR<TrainUpdateWithoutClassesInput, TrainUncheckedUpdateWithoutClassesInput>
  }

  export type TrainUpdateWithoutClassesInput = {
    name?: StringFieldUpdateOperationsInput | string
    trainType?: StringFieldUpdateOperationsInput | string
    routeStops?: RouteStopUpdateManyWithoutTrainNestedInput
    schedules?: ScheduleUpdateManyWithoutTrainNestedInput
  }

  export type TrainUncheckedUpdateWithoutClassesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    trainType?: StringFieldUpdateOperationsInput | string
    routeStops?: RouteStopUncheckedUpdateManyWithoutTrainNestedInput
    schedules?: ScheduleUncheckedUpdateManyWithoutTrainNestedInput
  }

  export type TrainCreateWithoutRouteStopsInput = {
    name: string
    trainType: string
    classes?: TrainClassCreateNestedManyWithoutTrainInput
    schedules?: ScheduleCreateNestedManyWithoutTrainInput
  }

  export type TrainUncheckedCreateWithoutRouteStopsInput = {
    id?: number
    name: string
    trainType: string
    classes?: TrainClassUncheckedCreateNestedManyWithoutTrainInput
    schedules?: ScheduleUncheckedCreateNestedManyWithoutTrainInput
  }

  export type TrainCreateOrConnectWithoutRouteStopsInput = {
    where: TrainWhereUniqueInput
    create: XOR<TrainCreateWithoutRouteStopsInput, TrainUncheckedCreateWithoutRouteStopsInput>
  }

  export type StationCreateWithoutRoutesInput = {
    code: string
    name: string
    city: string
    stationType: string
    departureSchedules?: ScheduleCreateNestedManyWithoutDepartureStationInput
    arrivalSchedules?: ScheduleCreateNestedManyWithoutArrivalStationInput
    favoriteOriginRoutes?: FavoriteRouteCreateNestedManyWithoutOriginInput
    favoriteDestinationRoutes?: FavoriteRouteCreateNestedManyWithoutDestinationInput
    historyOriginRoutes?: SearchHistoryCreateNestedManyWithoutOriginInput
    historyDestinationRoutes?: SearchHistoryCreateNestedManyWithoutDestinationInput
  }

  export type StationUncheckedCreateWithoutRoutesInput = {
    id?: number
    code: string
    name: string
    city: string
    stationType: string
    departureSchedules?: ScheduleUncheckedCreateNestedManyWithoutDepartureStationInput
    arrivalSchedules?: ScheduleUncheckedCreateNestedManyWithoutArrivalStationInput
    favoriteOriginRoutes?: FavoriteRouteUncheckedCreateNestedManyWithoutOriginInput
    favoriteDestinationRoutes?: FavoriteRouteUncheckedCreateNestedManyWithoutDestinationInput
    historyOriginRoutes?: SearchHistoryUncheckedCreateNestedManyWithoutOriginInput
    historyDestinationRoutes?: SearchHistoryUncheckedCreateNestedManyWithoutDestinationInput
  }

  export type StationCreateOrConnectWithoutRoutesInput = {
    where: StationWhereUniqueInput
    create: XOR<StationCreateWithoutRoutesInput, StationUncheckedCreateWithoutRoutesInput>
  }

  export type TrainUpsertWithoutRouteStopsInput = {
    update: XOR<TrainUpdateWithoutRouteStopsInput, TrainUncheckedUpdateWithoutRouteStopsInput>
    create: XOR<TrainCreateWithoutRouteStopsInput, TrainUncheckedCreateWithoutRouteStopsInput>
    where?: TrainWhereInput
  }

  export type TrainUpdateToOneWithWhereWithoutRouteStopsInput = {
    where?: TrainWhereInput
    data: XOR<TrainUpdateWithoutRouteStopsInput, TrainUncheckedUpdateWithoutRouteStopsInput>
  }

  export type TrainUpdateWithoutRouteStopsInput = {
    name?: StringFieldUpdateOperationsInput | string
    trainType?: StringFieldUpdateOperationsInput | string
    classes?: TrainClassUpdateManyWithoutTrainNestedInput
    schedules?: ScheduleUpdateManyWithoutTrainNestedInput
  }

  export type TrainUncheckedUpdateWithoutRouteStopsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    trainType?: StringFieldUpdateOperationsInput | string
    classes?: TrainClassUncheckedUpdateManyWithoutTrainNestedInput
    schedules?: ScheduleUncheckedUpdateManyWithoutTrainNestedInput
  }

  export type StationUpsertWithoutRoutesInput = {
    update: XOR<StationUpdateWithoutRoutesInput, StationUncheckedUpdateWithoutRoutesInput>
    create: XOR<StationCreateWithoutRoutesInput, StationUncheckedCreateWithoutRoutesInput>
    where?: StationWhereInput
  }

  export type StationUpdateToOneWithWhereWithoutRoutesInput = {
    where?: StationWhereInput
    data: XOR<StationUpdateWithoutRoutesInput, StationUncheckedUpdateWithoutRoutesInput>
  }

  export type StationUpdateWithoutRoutesInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    stationType?: StringFieldUpdateOperationsInput | string
    departureSchedules?: ScheduleUpdateManyWithoutDepartureStationNestedInput
    arrivalSchedules?: ScheduleUpdateManyWithoutArrivalStationNestedInput
    favoriteOriginRoutes?: FavoriteRouteUpdateManyWithoutOriginNestedInput
    favoriteDestinationRoutes?: FavoriteRouteUpdateManyWithoutDestinationNestedInput
    historyOriginRoutes?: SearchHistoryUpdateManyWithoutOriginNestedInput
    historyDestinationRoutes?: SearchHistoryUpdateManyWithoutDestinationNestedInput
  }

  export type StationUncheckedUpdateWithoutRoutesInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    stationType?: StringFieldUpdateOperationsInput | string
    departureSchedules?: ScheduleUncheckedUpdateManyWithoutDepartureStationNestedInput
    arrivalSchedules?: ScheduleUncheckedUpdateManyWithoutArrivalStationNestedInput
    favoriteOriginRoutes?: FavoriteRouteUncheckedUpdateManyWithoutOriginNestedInput
    favoriteDestinationRoutes?: FavoriteRouteUncheckedUpdateManyWithoutDestinationNestedInput
    historyOriginRoutes?: SearchHistoryUncheckedUpdateManyWithoutOriginNestedInput
    historyDestinationRoutes?: SearchHistoryUncheckedUpdateManyWithoutDestinationNestedInput
  }

  export type TrainCreateWithoutSchedulesInput = {
    name: string
    trainType: string
    classes?: TrainClassCreateNestedManyWithoutTrainInput
    routeStops?: RouteStopCreateNestedManyWithoutTrainInput
  }

  export type TrainUncheckedCreateWithoutSchedulesInput = {
    id?: number
    name: string
    trainType: string
    classes?: TrainClassUncheckedCreateNestedManyWithoutTrainInput
    routeStops?: RouteStopUncheckedCreateNestedManyWithoutTrainInput
  }

  export type TrainCreateOrConnectWithoutSchedulesInput = {
    where: TrainWhereUniqueInput
    create: XOR<TrainCreateWithoutSchedulesInput, TrainUncheckedCreateWithoutSchedulesInput>
  }

  export type StationCreateWithoutDepartureSchedulesInput = {
    code: string
    name: string
    city: string
    stationType: string
    routes?: RouteStopCreateNestedManyWithoutStationInput
    arrivalSchedules?: ScheduleCreateNestedManyWithoutArrivalStationInput
    favoriteOriginRoutes?: FavoriteRouteCreateNestedManyWithoutOriginInput
    favoriteDestinationRoutes?: FavoriteRouteCreateNestedManyWithoutDestinationInput
    historyOriginRoutes?: SearchHistoryCreateNestedManyWithoutOriginInput
    historyDestinationRoutes?: SearchHistoryCreateNestedManyWithoutDestinationInput
  }

  export type StationUncheckedCreateWithoutDepartureSchedulesInput = {
    id?: number
    code: string
    name: string
    city: string
    stationType: string
    routes?: RouteStopUncheckedCreateNestedManyWithoutStationInput
    arrivalSchedules?: ScheduleUncheckedCreateNestedManyWithoutArrivalStationInput
    favoriteOriginRoutes?: FavoriteRouteUncheckedCreateNestedManyWithoutOriginInput
    favoriteDestinationRoutes?: FavoriteRouteUncheckedCreateNestedManyWithoutDestinationInput
    historyOriginRoutes?: SearchHistoryUncheckedCreateNestedManyWithoutOriginInput
    historyDestinationRoutes?: SearchHistoryUncheckedCreateNestedManyWithoutDestinationInput
  }

  export type StationCreateOrConnectWithoutDepartureSchedulesInput = {
    where: StationWhereUniqueInput
    create: XOR<StationCreateWithoutDepartureSchedulesInput, StationUncheckedCreateWithoutDepartureSchedulesInput>
  }

  export type StationCreateWithoutArrivalSchedulesInput = {
    code: string
    name: string
    city: string
    stationType: string
    routes?: RouteStopCreateNestedManyWithoutStationInput
    departureSchedules?: ScheduleCreateNestedManyWithoutDepartureStationInput
    favoriteOriginRoutes?: FavoriteRouteCreateNestedManyWithoutOriginInput
    favoriteDestinationRoutes?: FavoriteRouteCreateNestedManyWithoutDestinationInput
    historyOriginRoutes?: SearchHistoryCreateNestedManyWithoutOriginInput
    historyDestinationRoutes?: SearchHistoryCreateNestedManyWithoutDestinationInput
  }

  export type StationUncheckedCreateWithoutArrivalSchedulesInput = {
    id?: number
    code: string
    name: string
    city: string
    stationType: string
    routes?: RouteStopUncheckedCreateNestedManyWithoutStationInput
    departureSchedules?: ScheduleUncheckedCreateNestedManyWithoutDepartureStationInput
    favoriteOriginRoutes?: FavoriteRouteUncheckedCreateNestedManyWithoutOriginInput
    favoriteDestinationRoutes?: FavoriteRouteUncheckedCreateNestedManyWithoutDestinationInput
    historyOriginRoutes?: SearchHistoryUncheckedCreateNestedManyWithoutOriginInput
    historyDestinationRoutes?: SearchHistoryUncheckedCreateNestedManyWithoutDestinationInput
  }

  export type StationCreateOrConnectWithoutArrivalSchedulesInput = {
    where: StationWhereUniqueInput
    create: XOR<StationCreateWithoutArrivalSchedulesInput, StationUncheckedCreateWithoutArrivalSchedulesInput>
  }

  export type BookingCreateWithoutScheduleInput = {
    userId: string
    className: string
    totalPrice: number
    status?: string
    createdAt?: Date | string
    payment?: PaymentCreateNestedOneWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutScheduleInput = {
    id?: number
    userId: string
    className: string
    totalPrice: number
    status?: string
    createdAt?: Date | string
    payment?: PaymentUncheckedCreateNestedOneWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutScheduleInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutScheduleInput, BookingUncheckedCreateWithoutScheduleInput>
  }

  export type BookingCreateManyScheduleInputEnvelope = {
    data: BookingCreateManyScheduleInput | BookingCreateManyScheduleInput[]
  }

  export type TrainUpsertWithoutSchedulesInput = {
    update: XOR<TrainUpdateWithoutSchedulesInput, TrainUncheckedUpdateWithoutSchedulesInput>
    create: XOR<TrainCreateWithoutSchedulesInput, TrainUncheckedCreateWithoutSchedulesInput>
    where?: TrainWhereInput
  }

  export type TrainUpdateToOneWithWhereWithoutSchedulesInput = {
    where?: TrainWhereInput
    data: XOR<TrainUpdateWithoutSchedulesInput, TrainUncheckedUpdateWithoutSchedulesInput>
  }

  export type TrainUpdateWithoutSchedulesInput = {
    name?: StringFieldUpdateOperationsInput | string
    trainType?: StringFieldUpdateOperationsInput | string
    classes?: TrainClassUpdateManyWithoutTrainNestedInput
    routeStops?: RouteStopUpdateManyWithoutTrainNestedInput
  }

  export type TrainUncheckedUpdateWithoutSchedulesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    trainType?: StringFieldUpdateOperationsInput | string
    classes?: TrainClassUncheckedUpdateManyWithoutTrainNestedInput
    routeStops?: RouteStopUncheckedUpdateManyWithoutTrainNestedInput
  }

  export type StationUpsertWithoutDepartureSchedulesInput = {
    update: XOR<StationUpdateWithoutDepartureSchedulesInput, StationUncheckedUpdateWithoutDepartureSchedulesInput>
    create: XOR<StationCreateWithoutDepartureSchedulesInput, StationUncheckedCreateWithoutDepartureSchedulesInput>
    where?: StationWhereInput
  }

  export type StationUpdateToOneWithWhereWithoutDepartureSchedulesInput = {
    where?: StationWhereInput
    data: XOR<StationUpdateWithoutDepartureSchedulesInput, StationUncheckedUpdateWithoutDepartureSchedulesInput>
  }

  export type StationUpdateWithoutDepartureSchedulesInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    stationType?: StringFieldUpdateOperationsInput | string
    routes?: RouteStopUpdateManyWithoutStationNestedInput
    arrivalSchedules?: ScheduleUpdateManyWithoutArrivalStationNestedInput
    favoriteOriginRoutes?: FavoriteRouteUpdateManyWithoutOriginNestedInput
    favoriteDestinationRoutes?: FavoriteRouteUpdateManyWithoutDestinationNestedInput
    historyOriginRoutes?: SearchHistoryUpdateManyWithoutOriginNestedInput
    historyDestinationRoutes?: SearchHistoryUpdateManyWithoutDestinationNestedInput
  }

  export type StationUncheckedUpdateWithoutDepartureSchedulesInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    stationType?: StringFieldUpdateOperationsInput | string
    routes?: RouteStopUncheckedUpdateManyWithoutStationNestedInput
    arrivalSchedules?: ScheduleUncheckedUpdateManyWithoutArrivalStationNestedInput
    favoriteOriginRoutes?: FavoriteRouteUncheckedUpdateManyWithoutOriginNestedInput
    favoriteDestinationRoutes?: FavoriteRouteUncheckedUpdateManyWithoutDestinationNestedInput
    historyOriginRoutes?: SearchHistoryUncheckedUpdateManyWithoutOriginNestedInput
    historyDestinationRoutes?: SearchHistoryUncheckedUpdateManyWithoutDestinationNestedInput
  }

  export type StationUpsertWithoutArrivalSchedulesInput = {
    update: XOR<StationUpdateWithoutArrivalSchedulesInput, StationUncheckedUpdateWithoutArrivalSchedulesInput>
    create: XOR<StationCreateWithoutArrivalSchedulesInput, StationUncheckedCreateWithoutArrivalSchedulesInput>
    where?: StationWhereInput
  }

  export type StationUpdateToOneWithWhereWithoutArrivalSchedulesInput = {
    where?: StationWhereInput
    data: XOR<StationUpdateWithoutArrivalSchedulesInput, StationUncheckedUpdateWithoutArrivalSchedulesInput>
  }

  export type StationUpdateWithoutArrivalSchedulesInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    stationType?: StringFieldUpdateOperationsInput | string
    routes?: RouteStopUpdateManyWithoutStationNestedInput
    departureSchedules?: ScheduleUpdateManyWithoutDepartureStationNestedInput
    favoriteOriginRoutes?: FavoriteRouteUpdateManyWithoutOriginNestedInput
    favoriteDestinationRoutes?: FavoriteRouteUpdateManyWithoutDestinationNestedInput
    historyOriginRoutes?: SearchHistoryUpdateManyWithoutOriginNestedInput
    historyDestinationRoutes?: SearchHistoryUpdateManyWithoutDestinationNestedInput
  }

  export type StationUncheckedUpdateWithoutArrivalSchedulesInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    stationType?: StringFieldUpdateOperationsInput | string
    routes?: RouteStopUncheckedUpdateManyWithoutStationNestedInput
    departureSchedules?: ScheduleUncheckedUpdateManyWithoutDepartureStationNestedInput
    favoriteOriginRoutes?: FavoriteRouteUncheckedUpdateManyWithoutOriginNestedInput
    favoriteDestinationRoutes?: FavoriteRouteUncheckedUpdateManyWithoutDestinationNestedInput
    historyOriginRoutes?: SearchHistoryUncheckedUpdateManyWithoutOriginNestedInput
    historyDestinationRoutes?: SearchHistoryUncheckedUpdateManyWithoutDestinationNestedInput
  }

  export type BookingUpsertWithWhereUniqueWithoutScheduleInput = {
    where: BookingWhereUniqueInput
    update: XOR<BookingUpdateWithoutScheduleInput, BookingUncheckedUpdateWithoutScheduleInput>
    create: XOR<BookingCreateWithoutScheduleInput, BookingUncheckedCreateWithoutScheduleInput>
  }

  export type BookingUpdateWithWhereUniqueWithoutScheduleInput = {
    where: BookingWhereUniqueInput
    data: XOR<BookingUpdateWithoutScheduleInput, BookingUncheckedUpdateWithoutScheduleInput>
  }

  export type BookingUpdateManyWithWhereWithoutScheduleInput = {
    where: BookingScalarWhereInput
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyWithoutScheduleInput>
  }

  export type BookingScalarWhereInput = {
    AND?: BookingScalarWhereInput | BookingScalarWhereInput[]
    OR?: BookingScalarWhereInput[]
    NOT?: BookingScalarWhereInput | BookingScalarWhereInput[]
    id?: IntFilter<"Booking"> | number
    userId?: StringFilter<"Booking"> | string
    scheduleId?: IntFilter<"Booking"> | number
    className?: StringFilter<"Booking"> | string
    totalPrice?: IntFilter<"Booking"> | number
    status?: StringFilter<"Booking"> | string
    createdAt?: DateTimeFilter<"Booking"> | Date | string
  }

  export type StationCreateWithoutFavoriteOriginRoutesInput = {
    code: string
    name: string
    city: string
    stationType: string
    routes?: RouteStopCreateNestedManyWithoutStationInput
    departureSchedules?: ScheduleCreateNestedManyWithoutDepartureStationInput
    arrivalSchedules?: ScheduleCreateNestedManyWithoutArrivalStationInput
    favoriteDestinationRoutes?: FavoriteRouteCreateNestedManyWithoutDestinationInput
    historyOriginRoutes?: SearchHistoryCreateNestedManyWithoutOriginInput
    historyDestinationRoutes?: SearchHistoryCreateNestedManyWithoutDestinationInput
  }

  export type StationUncheckedCreateWithoutFavoriteOriginRoutesInput = {
    id?: number
    code: string
    name: string
    city: string
    stationType: string
    routes?: RouteStopUncheckedCreateNestedManyWithoutStationInput
    departureSchedules?: ScheduleUncheckedCreateNestedManyWithoutDepartureStationInput
    arrivalSchedules?: ScheduleUncheckedCreateNestedManyWithoutArrivalStationInput
    favoriteDestinationRoutes?: FavoriteRouteUncheckedCreateNestedManyWithoutDestinationInput
    historyOriginRoutes?: SearchHistoryUncheckedCreateNestedManyWithoutOriginInput
    historyDestinationRoutes?: SearchHistoryUncheckedCreateNestedManyWithoutDestinationInput
  }

  export type StationCreateOrConnectWithoutFavoriteOriginRoutesInput = {
    where: StationWhereUniqueInput
    create: XOR<StationCreateWithoutFavoriteOriginRoutesInput, StationUncheckedCreateWithoutFavoriteOriginRoutesInput>
  }

  export type StationCreateWithoutFavoriteDestinationRoutesInput = {
    code: string
    name: string
    city: string
    stationType: string
    routes?: RouteStopCreateNestedManyWithoutStationInput
    departureSchedules?: ScheduleCreateNestedManyWithoutDepartureStationInput
    arrivalSchedules?: ScheduleCreateNestedManyWithoutArrivalStationInput
    favoriteOriginRoutes?: FavoriteRouteCreateNestedManyWithoutOriginInput
    historyOriginRoutes?: SearchHistoryCreateNestedManyWithoutOriginInput
    historyDestinationRoutes?: SearchHistoryCreateNestedManyWithoutDestinationInput
  }

  export type StationUncheckedCreateWithoutFavoriteDestinationRoutesInput = {
    id?: number
    code: string
    name: string
    city: string
    stationType: string
    routes?: RouteStopUncheckedCreateNestedManyWithoutStationInput
    departureSchedules?: ScheduleUncheckedCreateNestedManyWithoutDepartureStationInput
    arrivalSchedules?: ScheduleUncheckedCreateNestedManyWithoutArrivalStationInput
    favoriteOriginRoutes?: FavoriteRouteUncheckedCreateNestedManyWithoutOriginInput
    historyOriginRoutes?: SearchHistoryUncheckedCreateNestedManyWithoutOriginInput
    historyDestinationRoutes?: SearchHistoryUncheckedCreateNestedManyWithoutDestinationInput
  }

  export type StationCreateOrConnectWithoutFavoriteDestinationRoutesInput = {
    where: StationWhereUniqueInput
    create: XOR<StationCreateWithoutFavoriteDestinationRoutesInput, StationUncheckedCreateWithoutFavoriteDestinationRoutesInput>
  }

  export type StationUpsertWithoutFavoriteOriginRoutesInput = {
    update: XOR<StationUpdateWithoutFavoriteOriginRoutesInput, StationUncheckedUpdateWithoutFavoriteOriginRoutesInput>
    create: XOR<StationCreateWithoutFavoriteOriginRoutesInput, StationUncheckedCreateWithoutFavoriteOriginRoutesInput>
    where?: StationWhereInput
  }

  export type StationUpdateToOneWithWhereWithoutFavoriteOriginRoutesInput = {
    where?: StationWhereInput
    data: XOR<StationUpdateWithoutFavoriteOriginRoutesInput, StationUncheckedUpdateWithoutFavoriteOriginRoutesInput>
  }

  export type StationUpdateWithoutFavoriteOriginRoutesInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    stationType?: StringFieldUpdateOperationsInput | string
    routes?: RouteStopUpdateManyWithoutStationNestedInput
    departureSchedules?: ScheduleUpdateManyWithoutDepartureStationNestedInput
    arrivalSchedules?: ScheduleUpdateManyWithoutArrivalStationNestedInput
    favoriteDestinationRoutes?: FavoriteRouteUpdateManyWithoutDestinationNestedInput
    historyOriginRoutes?: SearchHistoryUpdateManyWithoutOriginNestedInput
    historyDestinationRoutes?: SearchHistoryUpdateManyWithoutDestinationNestedInput
  }

  export type StationUncheckedUpdateWithoutFavoriteOriginRoutesInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    stationType?: StringFieldUpdateOperationsInput | string
    routes?: RouteStopUncheckedUpdateManyWithoutStationNestedInput
    departureSchedules?: ScheduleUncheckedUpdateManyWithoutDepartureStationNestedInput
    arrivalSchedules?: ScheduleUncheckedUpdateManyWithoutArrivalStationNestedInput
    favoriteDestinationRoutes?: FavoriteRouteUncheckedUpdateManyWithoutDestinationNestedInput
    historyOriginRoutes?: SearchHistoryUncheckedUpdateManyWithoutOriginNestedInput
    historyDestinationRoutes?: SearchHistoryUncheckedUpdateManyWithoutDestinationNestedInput
  }

  export type StationUpsertWithoutFavoriteDestinationRoutesInput = {
    update: XOR<StationUpdateWithoutFavoriteDestinationRoutesInput, StationUncheckedUpdateWithoutFavoriteDestinationRoutesInput>
    create: XOR<StationCreateWithoutFavoriteDestinationRoutesInput, StationUncheckedCreateWithoutFavoriteDestinationRoutesInput>
    where?: StationWhereInput
  }

  export type StationUpdateToOneWithWhereWithoutFavoriteDestinationRoutesInput = {
    where?: StationWhereInput
    data: XOR<StationUpdateWithoutFavoriteDestinationRoutesInput, StationUncheckedUpdateWithoutFavoriteDestinationRoutesInput>
  }

  export type StationUpdateWithoutFavoriteDestinationRoutesInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    stationType?: StringFieldUpdateOperationsInput | string
    routes?: RouteStopUpdateManyWithoutStationNestedInput
    departureSchedules?: ScheduleUpdateManyWithoutDepartureStationNestedInput
    arrivalSchedules?: ScheduleUpdateManyWithoutArrivalStationNestedInput
    favoriteOriginRoutes?: FavoriteRouteUpdateManyWithoutOriginNestedInput
    historyOriginRoutes?: SearchHistoryUpdateManyWithoutOriginNestedInput
    historyDestinationRoutes?: SearchHistoryUpdateManyWithoutDestinationNestedInput
  }

  export type StationUncheckedUpdateWithoutFavoriteDestinationRoutesInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    stationType?: StringFieldUpdateOperationsInput | string
    routes?: RouteStopUncheckedUpdateManyWithoutStationNestedInput
    departureSchedules?: ScheduleUncheckedUpdateManyWithoutDepartureStationNestedInput
    arrivalSchedules?: ScheduleUncheckedUpdateManyWithoutArrivalStationNestedInput
    favoriteOriginRoutes?: FavoriteRouteUncheckedUpdateManyWithoutOriginNestedInput
    historyOriginRoutes?: SearchHistoryUncheckedUpdateManyWithoutOriginNestedInput
    historyDestinationRoutes?: SearchHistoryUncheckedUpdateManyWithoutDestinationNestedInput
  }

  export type StationCreateWithoutHistoryOriginRoutesInput = {
    code: string
    name: string
    city: string
    stationType: string
    routes?: RouteStopCreateNestedManyWithoutStationInput
    departureSchedules?: ScheduleCreateNestedManyWithoutDepartureStationInput
    arrivalSchedules?: ScheduleCreateNestedManyWithoutArrivalStationInput
    favoriteOriginRoutes?: FavoriteRouteCreateNestedManyWithoutOriginInput
    favoriteDestinationRoutes?: FavoriteRouteCreateNestedManyWithoutDestinationInput
    historyDestinationRoutes?: SearchHistoryCreateNestedManyWithoutDestinationInput
  }

  export type StationUncheckedCreateWithoutHistoryOriginRoutesInput = {
    id?: number
    code: string
    name: string
    city: string
    stationType: string
    routes?: RouteStopUncheckedCreateNestedManyWithoutStationInput
    departureSchedules?: ScheduleUncheckedCreateNestedManyWithoutDepartureStationInput
    arrivalSchedules?: ScheduleUncheckedCreateNestedManyWithoutArrivalStationInput
    favoriteOriginRoutes?: FavoriteRouteUncheckedCreateNestedManyWithoutOriginInput
    favoriteDestinationRoutes?: FavoriteRouteUncheckedCreateNestedManyWithoutDestinationInput
    historyDestinationRoutes?: SearchHistoryUncheckedCreateNestedManyWithoutDestinationInput
  }

  export type StationCreateOrConnectWithoutHistoryOriginRoutesInput = {
    where: StationWhereUniqueInput
    create: XOR<StationCreateWithoutHistoryOriginRoutesInput, StationUncheckedCreateWithoutHistoryOriginRoutesInput>
  }

  export type StationCreateWithoutHistoryDestinationRoutesInput = {
    code: string
    name: string
    city: string
    stationType: string
    routes?: RouteStopCreateNestedManyWithoutStationInput
    departureSchedules?: ScheduleCreateNestedManyWithoutDepartureStationInput
    arrivalSchedules?: ScheduleCreateNestedManyWithoutArrivalStationInput
    favoriteOriginRoutes?: FavoriteRouteCreateNestedManyWithoutOriginInput
    favoriteDestinationRoutes?: FavoriteRouteCreateNestedManyWithoutDestinationInput
    historyOriginRoutes?: SearchHistoryCreateNestedManyWithoutOriginInput
  }

  export type StationUncheckedCreateWithoutHistoryDestinationRoutesInput = {
    id?: number
    code: string
    name: string
    city: string
    stationType: string
    routes?: RouteStopUncheckedCreateNestedManyWithoutStationInput
    departureSchedules?: ScheduleUncheckedCreateNestedManyWithoutDepartureStationInput
    arrivalSchedules?: ScheduleUncheckedCreateNestedManyWithoutArrivalStationInput
    favoriteOriginRoutes?: FavoriteRouteUncheckedCreateNestedManyWithoutOriginInput
    favoriteDestinationRoutes?: FavoriteRouteUncheckedCreateNestedManyWithoutDestinationInput
    historyOriginRoutes?: SearchHistoryUncheckedCreateNestedManyWithoutOriginInput
  }

  export type StationCreateOrConnectWithoutHistoryDestinationRoutesInput = {
    where: StationWhereUniqueInput
    create: XOR<StationCreateWithoutHistoryDestinationRoutesInput, StationUncheckedCreateWithoutHistoryDestinationRoutesInput>
  }

  export type StationUpsertWithoutHistoryOriginRoutesInput = {
    update: XOR<StationUpdateWithoutHistoryOriginRoutesInput, StationUncheckedUpdateWithoutHistoryOriginRoutesInput>
    create: XOR<StationCreateWithoutHistoryOriginRoutesInput, StationUncheckedCreateWithoutHistoryOriginRoutesInput>
    where?: StationWhereInput
  }

  export type StationUpdateToOneWithWhereWithoutHistoryOriginRoutesInput = {
    where?: StationWhereInput
    data: XOR<StationUpdateWithoutHistoryOriginRoutesInput, StationUncheckedUpdateWithoutHistoryOriginRoutesInput>
  }

  export type StationUpdateWithoutHistoryOriginRoutesInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    stationType?: StringFieldUpdateOperationsInput | string
    routes?: RouteStopUpdateManyWithoutStationNestedInput
    departureSchedules?: ScheduleUpdateManyWithoutDepartureStationNestedInput
    arrivalSchedules?: ScheduleUpdateManyWithoutArrivalStationNestedInput
    favoriteOriginRoutes?: FavoriteRouteUpdateManyWithoutOriginNestedInput
    favoriteDestinationRoutes?: FavoriteRouteUpdateManyWithoutDestinationNestedInput
    historyDestinationRoutes?: SearchHistoryUpdateManyWithoutDestinationNestedInput
  }

  export type StationUncheckedUpdateWithoutHistoryOriginRoutesInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    stationType?: StringFieldUpdateOperationsInput | string
    routes?: RouteStopUncheckedUpdateManyWithoutStationNestedInput
    departureSchedules?: ScheduleUncheckedUpdateManyWithoutDepartureStationNestedInput
    arrivalSchedules?: ScheduleUncheckedUpdateManyWithoutArrivalStationNestedInput
    favoriteOriginRoutes?: FavoriteRouteUncheckedUpdateManyWithoutOriginNestedInput
    favoriteDestinationRoutes?: FavoriteRouteUncheckedUpdateManyWithoutDestinationNestedInput
    historyDestinationRoutes?: SearchHistoryUncheckedUpdateManyWithoutDestinationNestedInput
  }

  export type StationUpsertWithoutHistoryDestinationRoutesInput = {
    update: XOR<StationUpdateWithoutHistoryDestinationRoutesInput, StationUncheckedUpdateWithoutHistoryDestinationRoutesInput>
    create: XOR<StationCreateWithoutHistoryDestinationRoutesInput, StationUncheckedCreateWithoutHistoryDestinationRoutesInput>
    where?: StationWhereInput
  }

  export type StationUpdateToOneWithWhereWithoutHistoryDestinationRoutesInput = {
    where?: StationWhereInput
    data: XOR<StationUpdateWithoutHistoryDestinationRoutesInput, StationUncheckedUpdateWithoutHistoryDestinationRoutesInput>
  }

  export type StationUpdateWithoutHistoryDestinationRoutesInput = {
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    stationType?: StringFieldUpdateOperationsInput | string
    routes?: RouteStopUpdateManyWithoutStationNestedInput
    departureSchedules?: ScheduleUpdateManyWithoutDepartureStationNestedInput
    arrivalSchedules?: ScheduleUpdateManyWithoutArrivalStationNestedInput
    favoriteOriginRoutes?: FavoriteRouteUpdateManyWithoutOriginNestedInput
    favoriteDestinationRoutes?: FavoriteRouteUpdateManyWithoutDestinationNestedInput
    historyOriginRoutes?: SearchHistoryUpdateManyWithoutOriginNestedInput
  }

  export type StationUncheckedUpdateWithoutHistoryDestinationRoutesInput = {
    id?: IntFieldUpdateOperationsInput | number
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    stationType?: StringFieldUpdateOperationsInput | string
    routes?: RouteStopUncheckedUpdateManyWithoutStationNestedInput
    departureSchedules?: ScheduleUncheckedUpdateManyWithoutDepartureStationNestedInput
    arrivalSchedules?: ScheduleUncheckedUpdateManyWithoutArrivalStationNestedInput
    favoriteOriginRoutes?: FavoriteRouteUncheckedUpdateManyWithoutOriginNestedInput
    favoriteDestinationRoutes?: FavoriteRouteUncheckedUpdateManyWithoutDestinationNestedInput
    historyOriginRoutes?: SearchHistoryUncheckedUpdateManyWithoutOriginNestedInput
  }

  export type ScheduleCreateWithoutBookingsInput = {
    departureTime: Date | string
    arrivalTime: Date | string
    train: TrainCreateNestedOneWithoutSchedulesInput
    departureStation: StationCreateNestedOneWithoutDepartureSchedulesInput
    arrivalStation: StationCreateNestedOneWithoutArrivalSchedulesInput
  }

  export type ScheduleUncheckedCreateWithoutBookingsInput = {
    id?: number
    departureTime: Date | string
    arrivalTime: Date | string
    trainId: number
    departureStationId: number
    arrivalStationId: number
  }

  export type ScheduleCreateOrConnectWithoutBookingsInput = {
    where: ScheduleWhereUniqueInput
    create: XOR<ScheduleCreateWithoutBookingsInput, ScheduleUncheckedCreateWithoutBookingsInput>
  }

  export type PaymentCreateWithoutBookingInput = {
    method: string
    paidAmount: number
    paidAt?: Date | string
  }

  export type PaymentUncheckedCreateWithoutBookingInput = {
    id?: number
    method: string
    paidAmount: number
    paidAt?: Date | string
  }

  export type PaymentCreateOrConnectWithoutBookingInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutBookingInput, PaymentUncheckedCreateWithoutBookingInput>
  }

  export type ScheduleUpsertWithoutBookingsInput = {
    update: XOR<ScheduleUpdateWithoutBookingsInput, ScheduleUncheckedUpdateWithoutBookingsInput>
    create: XOR<ScheduleCreateWithoutBookingsInput, ScheduleUncheckedCreateWithoutBookingsInput>
    where?: ScheduleWhereInput
  }

  export type ScheduleUpdateToOneWithWhereWithoutBookingsInput = {
    where?: ScheduleWhereInput
    data: XOR<ScheduleUpdateWithoutBookingsInput, ScheduleUncheckedUpdateWithoutBookingsInput>
  }

  export type ScheduleUpdateWithoutBookingsInput = {
    departureTime?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalTime?: DateTimeFieldUpdateOperationsInput | Date | string
    train?: TrainUpdateOneRequiredWithoutSchedulesNestedInput
    departureStation?: StationUpdateOneRequiredWithoutDepartureSchedulesNestedInput
    arrivalStation?: StationUpdateOneRequiredWithoutArrivalSchedulesNestedInput
  }

  export type ScheduleUncheckedUpdateWithoutBookingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    departureTime?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalTime?: DateTimeFieldUpdateOperationsInput | Date | string
    trainId?: IntFieldUpdateOperationsInput | number
    departureStationId?: IntFieldUpdateOperationsInput | number
    arrivalStationId?: IntFieldUpdateOperationsInput | number
  }

  export type PaymentUpsertWithoutBookingInput = {
    update: XOR<PaymentUpdateWithoutBookingInput, PaymentUncheckedUpdateWithoutBookingInput>
    create: XOR<PaymentCreateWithoutBookingInput, PaymentUncheckedCreateWithoutBookingInput>
    where?: PaymentWhereInput
  }

  export type PaymentUpdateToOneWithWhereWithoutBookingInput = {
    where?: PaymentWhereInput
    data: XOR<PaymentUpdateWithoutBookingInput, PaymentUncheckedUpdateWithoutBookingInput>
  }

  export type PaymentUpdateWithoutBookingInput = {
    method?: StringFieldUpdateOperationsInput | string
    paidAmount?: IntFieldUpdateOperationsInput | number
    paidAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateWithoutBookingInput = {
    id?: IntFieldUpdateOperationsInput | number
    method?: StringFieldUpdateOperationsInput | string
    paidAmount?: IntFieldUpdateOperationsInput | number
    paidAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingCreateWithoutPaymentInput = {
    userId: string
    className: string
    totalPrice: number
    status?: string
    createdAt?: Date | string
    schedule: ScheduleCreateNestedOneWithoutBookingsInput
  }

  export type BookingUncheckedCreateWithoutPaymentInput = {
    id?: number
    userId: string
    scheduleId: number
    className: string
    totalPrice: number
    status?: string
    createdAt?: Date | string
  }

  export type BookingCreateOrConnectWithoutPaymentInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutPaymentInput, BookingUncheckedCreateWithoutPaymentInput>
  }

  export type BookingUpsertWithoutPaymentInput = {
    update: XOR<BookingUpdateWithoutPaymentInput, BookingUncheckedUpdateWithoutPaymentInput>
    create: XOR<BookingCreateWithoutPaymentInput, BookingUncheckedCreateWithoutPaymentInput>
    where?: BookingWhereInput
  }

  export type BookingUpdateToOneWithWhereWithoutPaymentInput = {
    where?: BookingWhereInput
    data: XOR<BookingUpdateWithoutPaymentInput, BookingUncheckedUpdateWithoutPaymentInput>
  }

  export type BookingUpdateWithoutPaymentInput = {
    userId?: StringFieldUpdateOperationsInput | string
    className?: StringFieldUpdateOperationsInput | string
    totalPrice?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schedule?: ScheduleUpdateOneRequiredWithoutBookingsNestedInput
  }

  export type BookingUncheckedUpdateWithoutPaymentInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    scheduleId?: IntFieldUpdateOperationsInput | number
    className?: StringFieldUpdateOperationsInput | string
    totalPrice?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RouteStopCreateManyStationInput = {
    id?: number
    stopOrder: number
    trainId: number
    arrivalTime?: Date | string | null
    departureTime?: Date | string | null
  }

  export type ScheduleCreateManyDepartureStationInput = {
    id?: number
    departureTime: Date | string
    arrivalTime: Date | string
    trainId: number
    arrivalStationId: number
  }

  export type ScheduleCreateManyArrivalStationInput = {
    id?: number
    departureTime: Date | string
    arrivalTime: Date | string
    trainId: number
    departureStationId: number
  }

  export type FavoriteRouteCreateManyOriginInput = {
    id?: number
    userId: string
    destinationStationId: number
  }

  export type FavoriteRouteCreateManyDestinationInput = {
    id?: number
    userId: string
    originStationId: number
  }

  export type SearchHistoryCreateManyOriginInput = {
    id?: number
    userId: string
    searchDate?: Date | string
    destinationStationId: number
  }

  export type SearchHistoryCreateManyDestinationInput = {
    id?: number
    userId: string
    searchDate?: Date | string
    originStationId: number
  }

  export type RouteStopUpdateWithoutStationInput = {
    stopOrder?: IntFieldUpdateOperationsInput | number
    arrivalTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departureTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    train?: TrainUpdateOneRequiredWithoutRouteStopsNestedInput
  }

  export type RouteStopUncheckedUpdateWithoutStationInput = {
    id?: IntFieldUpdateOperationsInput | number
    stopOrder?: IntFieldUpdateOperationsInput | number
    trainId?: IntFieldUpdateOperationsInput | number
    arrivalTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departureTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RouteStopUncheckedUpdateManyWithoutStationInput = {
    id?: IntFieldUpdateOperationsInput | number
    stopOrder?: IntFieldUpdateOperationsInput | number
    trainId?: IntFieldUpdateOperationsInput | number
    arrivalTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departureTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ScheduleUpdateWithoutDepartureStationInput = {
    departureTime?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalTime?: DateTimeFieldUpdateOperationsInput | Date | string
    train?: TrainUpdateOneRequiredWithoutSchedulesNestedInput
    arrivalStation?: StationUpdateOneRequiredWithoutArrivalSchedulesNestedInput
    bookings?: BookingUpdateManyWithoutScheduleNestedInput
  }

  export type ScheduleUncheckedUpdateWithoutDepartureStationInput = {
    id?: IntFieldUpdateOperationsInput | number
    departureTime?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalTime?: DateTimeFieldUpdateOperationsInput | Date | string
    trainId?: IntFieldUpdateOperationsInput | number
    arrivalStationId?: IntFieldUpdateOperationsInput | number
    bookings?: BookingUncheckedUpdateManyWithoutScheduleNestedInput
  }

  export type ScheduleUncheckedUpdateManyWithoutDepartureStationInput = {
    id?: IntFieldUpdateOperationsInput | number
    departureTime?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalTime?: DateTimeFieldUpdateOperationsInput | Date | string
    trainId?: IntFieldUpdateOperationsInput | number
    arrivalStationId?: IntFieldUpdateOperationsInput | number
  }

  export type ScheduleUpdateWithoutArrivalStationInput = {
    departureTime?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalTime?: DateTimeFieldUpdateOperationsInput | Date | string
    train?: TrainUpdateOneRequiredWithoutSchedulesNestedInput
    departureStation?: StationUpdateOneRequiredWithoutDepartureSchedulesNestedInput
    bookings?: BookingUpdateManyWithoutScheduleNestedInput
  }

  export type ScheduleUncheckedUpdateWithoutArrivalStationInput = {
    id?: IntFieldUpdateOperationsInput | number
    departureTime?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalTime?: DateTimeFieldUpdateOperationsInput | Date | string
    trainId?: IntFieldUpdateOperationsInput | number
    departureStationId?: IntFieldUpdateOperationsInput | number
    bookings?: BookingUncheckedUpdateManyWithoutScheduleNestedInput
  }

  export type ScheduleUncheckedUpdateManyWithoutArrivalStationInput = {
    id?: IntFieldUpdateOperationsInput | number
    departureTime?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalTime?: DateTimeFieldUpdateOperationsInput | Date | string
    trainId?: IntFieldUpdateOperationsInput | number
    departureStationId?: IntFieldUpdateOperationsInput | number
  }

  export type FavoriteRouteUpdateWithoutOriginInput = {
    userId?: StringFieldUpdateOperationsInput | string
    destination?: StationUpdateOneRequiredWithoutFavoriteDestinationRoutesNestedInput
  }

  export type FavoriteRouteUncheckedUpdateWithoutOriginInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    destinationStationId?: IntFieldUpdateOperationsInput | number
  }

  export type FavoriteRouteUncheckedUpdateManyWithoutOriginInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    destinationStationId?: IntFieldUpdateOperationsInput | number
  }

  export type FavoriteRouteUpdateWithoutDestinationInput = {
    userId?: StringFieldUpdateOperationsInput | string
    origin?: StationUpdateOneRequiredWithoutFavoriteOriginRoutesNestedInput
  }

  export type FavoriteRouteUncheckedUpdateWithoutDestinationInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    originStationId?: IntFieldUpdateOperationsInput | number
  }

  export type FavoriteRouteUncheckedUpdateManyWithoutDestinationInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    originStationId?: IntFieldUpdateOperationsInput | number
  }

  export type SearchHistoryUpdateWithoutOriginInput = {
    userId?: StringFieldUpdateOperationsInput | string
    searchDate?: DateTimeFieldUpdateOperationsInput | Date | string
    destination?: StationUpdateOneRequiredWithoutHistoryDestinationRoutesNestedInput
  }

  export type SearchHistoryUncheckedUpdateWithoutOriginInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    searchDate?: DateTimeFieldUpdateOperationsInput | Date | string
    destinationStationId?: IntFieldUpdateOperationsInput | number
  }

  export type SearchHistoryUncheckedUpdateManyWithoutOriginInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    searchDate?: DateTimeFieldUpdateOperationsInput | Date | string
    destinationStationId?: IntFieldUpdateOperationsInput | number
  }

  export type SearchHistoryUpdateWithoutDestinationInput = {
    userId?: StringFieldUpdateOperationsInput | string
    searchDate?: DateTimeFieldUpdateOperationsInput | Date | string
    origin?: StationUpdateOneRequiredWithoutHistoryOriginRoutesNestedInput
  }

  export type SearchHistoryUncheckedUpdateWithoutDestinationInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    searchDate?: DateTimeFieldUpdateOperationsInput | Date | string
    originStationId?: IntFieldUpdateOperationsInput | number
  }

  export type SearchHistoryUncheckedUpdateManyWithoutDestinationInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    searchDate?: DateTimeFieldUpdateOperationsInput | Date | string
    originStationId?: IntFieldUpdateOperationsInput | number
  }

  export type TrainClassCreateManyTrainInput = {
    id?: number
    className: string
    price: number
  }

  export type RouteStopCreateManyTrainInput = {
    id?: number
    stopOrder: number
    stationId: number
    arrivalTime?: Date | string | null
    departureTime?: Date | string | null
  }

  export type ScheduleCreateManyTrainInput = {
    id?: number
    departureTime: Date | string
    arrivalTime: Date | string
    departureStationId: number
    arrivalStationId: number
  }

  export type TrainClassUpdateWithoutTrainInput = {
    className?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
  }

  export type TrainClassUncheckedUpdateWithoutTrainInput = {
    id?: IntFieldUpdateOperationsInput | number
    className?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
  }

  export type TrainClassUncheckedUpdateManyWithoutTrainInput = {
    id?: IntFieldUpdateOperationsInput | number
    className?: StringFieldUpdateOperationsInput | string
    price?: IntFieldUpdateOperationsInput | number
  }

  export type RouteStopUpdateWithoutTrainInput = {
    stopOrder?: IntFieldUpdateOperationsInput | number
    arrivalTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departureTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    station?: StationUpdateOneRequiredWithoutRoutesNestedInput
  }

  export type RouteStopUncheckedUpdateWithoutTrainInput = {
    id?: IntFieldUpdateOperationsInput | number
    stopOrder?: IntFieldUpdateOperationsInput | number
    stationId?: IntFieldUpdateOperationsInput | number
    arrivalTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departureTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RouteStopUncheckedUpdateManyWithoutTrainInput = {
    id?: IntFieldUpdateOperationsInput | number
    stopOrder?: IntFieldUpdateOperationsInput | number
    stationId?: IntFieldUpdateOperationsInput | number
    arrivalTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    departureTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ScheduleUpdateWithoutTrainInput = {
    departureTime?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalTime?: DateTimeFieldUpdateOperationsInput | Date | string
    departureStation?: StationUpdateOneRequiredWithoutDepartureSchedulesNestedInput
    arrivalStation?: StationUpdateOneRequiredWithoutArrivalSchedulesNestedInput
    bookings?: BookingUpdateManyWithoutScheduleNestedInput
  }

  export type ScheduleUncheckedUpdateWithoutTrainInput = {
    id?: IntFieldUpdateOperationsInput | number
    departureTime?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalTime?: DateTimeFieldUpdateOperationsInput | Date | string
    departureStationId?: IntFieldUpdateOperationsInput | number
    arrivalStationId?: IntFieldUpdateOperationsInput | number
    bookings?: BookingUncheckedUpdateManyWithoutScheduleNestedInput
  }

  export type ScheduleUncheckedUpdateManyWithoutTrainInput = {
    id?: IntFieldUpdateOperationsInput | number
    departureTime?: DateTimeFieldUpdateOperationsInput | Date | string
    arrivalTime?: DateTimeFieldUpdateOperationsInput | Date | string
    departureStationId?: IntFieldUpdateOperationsInput | number
    arrivalStationId?: IntFieldUpdateOperationsInput | number
  }

  export type BookingCreateManyScheduleInput = {
    id?: number
    userId: string
    className: string
    totalPrice: number
    status?: string
    createdAt?: Date | string
  }

  export type BookingUpdateWithoutScheduleInput = {
    userId?: StringFieldUpdateOperationsInput | string
    className?: StringFieldUpdateOperationsInput | string
    totalPrice?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payment?: PaymentUpdateOneWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutScheduleInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    className?: StringFieldUpdateOperationsInput | string
    totalPrice?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payment?: PaymentUncheckedUpdateOneWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateManyWithoutScheduleInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: StringFieldUpdateOperationsInput | string
    className?: StringFieldUpdateOperationsInput | string
    totalPrice?: IntFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use StationCountOutputTypeDefaultArgs instead
     */
    export type StationCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StationCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TrainCountOutputTypeDefaultArgs instead
     */
    export type TrainCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TrainCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ScheduleCountOutputTypeDefaultArgs instead
     */
    export type ScheduleCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ScheduleCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StationDefaultArgs instead
     */
    export type StationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TrainDefaultArgs instead
     */
    export type TrainArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TrainDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TrainClassDefaultArgs instead
     */
    export type TrainClassArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TrainClassDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RouteStopDefaultArgs instead
     */
    export type RouteStopArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RouteStopDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ScheduleDefaultArgs instead
     */
    export type ScheduleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ScheduleDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FavoriteRouteDefaultArgs instead
     */
    export type FavoriteRouteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FavoriteRouteDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SearchHistoryDefaultArgs instead
     */
    export type SearchHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SearchHistoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BookingDefaultArgs instead
     */
    export type BookingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BookingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PaymentDefaultArgs instead
     */
    export type PaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PaymentDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}